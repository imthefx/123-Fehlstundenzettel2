<!DOCTYPE html>
<html lang="de">
<head>
  <!-- Favicon: 123 branding -->
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"%3E%3Crect width="64" height="64" rx="12" fill="%2301222b"/%3E%3Cdefs%3E%3ClinearGradient id="g" x1="0" y1="0" x2="64" y2="64" gradientUnits="userSpaceOnUse"%3E%3Cstop offset="0" stop-color="%23e6f3ff"/%3E%3Cstop offset="1" stop-color="%23b3e5fc"/%3E%3C/linearGradient%3E%3C/defs%3E%3Ctext x="32" y="36" text-anchor="middle" dominant-baseline="middle" font-family="Segoe UI, Arial, sans-serif" font-size="34" font-weight="700" fill="url(%23g)"%3E123%3C/text%3E%3C/svg%3E' />
  <!-- PNG fallback for older browsers -->
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAABQ2C5HAAAACXBIWXMAAAsSAAALEgHS3X78AAAAI0lEQVR4nO3OwQkAMAwEwQqf/5c3gY1mJ5JmA1q3gYzC3T5bqf7mJw3c1M9gQ7QG+6cJwAAAABJRU5ErkJggg==" />
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>123 ist die Zahl</title>

<style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  background:#f2f4f8;
  color:#111;
  position: relative;
  --name-default-color: #333333;
}

/* Rainbow Text Animation */
@keyframes rainbow-flow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.rainbow-text {
  background: linear-gradient(90deg, 
    #ff0000, #ff7f00, #ffff00, #00ff00, 
    #0000ff, #4b0082, #9400d3, #ff0000
  );
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow-flow 3s linear infinite;
}

/* Gold Glow Animation */
@keyframes gold-glow {
  0%, 100% { 
    text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700, 0 0 30px #FFA500;
  }
  50% { 
    text-shadow: 0 0 20px #FFD700, 0 0 30px #FFD700, 0 0 40px #FFA500, 0 0 50px #FF8C00;
  }
}

.gold-text {
  color: #FFD700;
  animation: gold-glow 2s ease-in-out infinite;
}

/* Ruby Red Exclusive - enhanced crimson pulse with gem sparkle */
@keyframes ruby-pulse {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(224,17,95,0.8), 
      0 0 10px rgba(224,17,95,0.5),
      0 0 15px rgba(139,0,0,0.4),
      2px 2px 3px rgba(255,0,100,0.3);
    filter: brightness(1) saturate(1.3);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(224,17,95,1), 
      0 0 20px rgba(224,17,95,0.8),
      0 0 30px rgba(139,0,0,0.6),
      3px 3px 5px rgba(255,0,100,0.5),
      -2px -2px 8px rgba(255,20,147,0.4);
    filter: brightness(1.2) saturate(1.6);
  }
}
.ruby-text { color: #E0115F; animation: ruby-pulse 2s ease-in-out infinite; }

/* Emerald Exclusive - deep green glow with nature shimmer */
@keyframes emerald-glow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(80,200,120,0.9), 
      0 0 10px rgba(80,200,120,0.6),
      0 0 15px rgba(34,139,34,0.4),
      2px 2px 4px rgba(0,255,127,0.3);
    filter: brightness(1.05) saturate(1.4);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(80,200,120,1), 
      0 0 20px rgba(80,200,120,0.8),
      0 0 30px rgba(34,139,34,0.6),
      3px 3px 6px rgba(0,255,127,0.5),
      -2px -2px 8px rgba(144,238,144,0.4);
    filter: brightness(1.15) saturate(1.7) hue-rotate(5deg);
  }
}
.emerald-text { color: #50C878; animation: emerald-glow 2s ease-in-out infinite; }

/* Diamond Exclusive - ice crystal shimmer with prismatic refraction */
@keyframes diamond-shimmer {
  0% {
    text-shadow: 
      0 0 5px rgba(185,242,255,0.9), 
      0 0 10px rgba(185,242,255,0.6),
      2px 2px 4px rgba(173,216,230,0.5),
      -2px -2px 4px rgba(224,255,255,0.5);
    filter: brightness(1.1) saturate(1.2);
  }
  33% {
    text-shadow: 
      0 0 8px rgba(185,242,255,1), 
      0 0 16px rgba(185,242,255,0.8),
      3px 3px 6px rgba(135,206,250,0.6),
      -3px -3px 6px rgba(240,248,255,0.6),
      0 0 20px rgba(176,224,230,0.4);
    filter: brightness(1.25) saturate(1.5) hue-rotate(-10deg);
  }
  66% {
    text-shadow: 
      0 0 10px rgba(185,242,255,1), 
      0 0 20px rgba(185,242,255,0.9),
      4px 4px 8px rgba(70,130,180,0.7),
      -4px -4px 8px rgba(255,250,250,0.7),
      0 0 25px rgba(135,206,235,0.5);
    filter: brightness(1.3) saturate(1.6) hue-rotate(10deg);
  }
  100% {
    text-shadow: 
      0 0 5px rgba(185,242,255,0.9), 
      0 0 10px rgba(185,242,255,0.6),
      2px 2px 4px rgba(173,216,230,0.5),
      -2px -2px 4px rgba(224,255,255,0.5);
    filter: brightness(1.1) saturate(1.2);
  }
}
.diamond-text { color: #B9F2FF; animation: diamond-shimmer 3s ease-in-out infinite; }

.nav-auth-btn {
  border:none;
  border-radius:5px;
  cursor:pointer;
  font-size:14px;
}
body.dark-mode .nav-auth-btn {
  background:#0056b3;
}

/* Slot Machine */
.slot-box {
  width: 80px;
  height: 80px;
  background: linear-gradient(135deg, #FFD700, #FFA500);
  border: 3px solid #FF6B6B;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: bold;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  transition: transform 0.1s;
}

body.dark-mode .slot-box {
  background: linear-gradient(135deg, #FF6B6B, #FF4444);
  border-color: #FFD700;
  box-shadow: 0 4px 10px rgba(255,255,255,0.2);
}

.slot-box.spinning {
  animation: slotSpin 0.1s infinite;
}

@keyframes slotSpin {
  0%, 100% { transform: rotateY(0deg); }
  50% { transform: rotateY(10deg); }
}

#slotSpinBtn {
  background: linear-gradient(135deg, #FF6B6B, #FF4444) !important;
  font-weight: bold;
  font-size: 16px;
}

#slotSpinBtn:hover {
  background: linear-gradient(135deg, #FF4444, #CC0000) !important;
}

#slotSpinBtn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Auth-Modal */
.auth-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  display: none;              /* Start: unsichtbar */
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

/* Notification Modal immer ganz vorne */
#notificationModal {
  z-index: 5000 !important;
}

.auth-modal-content {
  background: #fff;
  padding: 20px;
  border-radius: 8px;
  max-width: 600px;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}

.auth-close {
  float: right;
  font-size: 24px;
  cursor: pointer;
}

/* Darkmode für Modal */
body.dark-mode .auth-modal-content {
  background:#222;
  color:#f2f4f8;
}

/* User Profile Modal */
.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10000;
}

.modal-content {
  background: #fff;
  padding: 25px;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  position: relative;
  max-height: 90vh;
  overflow-y: auto;
}

.modal .close {
  position: absolute;
  top: 15px;
  right: 20px;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  color: #999;
}

.modal .close:hover {
  color: #333;
}

body.dark-mode .modal-content {
  background: #222;
  color: #f2f4f8;
}

body.dark-mode .modal .close {
  color: #ccc;
}

body.dark-mode .modal .close:hover {
  color: #fff;
}

/* Default name color adapts to dark mode */
body.dark-mode {
  --name-default-color: #f0f0f0;
}

/* Quest Completion Popup */
.quest-popup {
  position: fixed;
  right: -400px;
  top: 20px;
  width: 350px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  z-index: 9999;
  transition: right 0.5s ease;
  animation: questSlideIn 0.5s ease forwards;
}

@keyframes questSlideIn {
  to {
    right: 20px;
  }
}

.quest-popup.slide-out {
  animation: questSlideOut 0.5s ease forwards;
}

@keyframes questSlideOut {
  to {
    right: -400px;
  }
}

.quest-popup-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
  font-size: 20px;
  font-weight: bold;
}

.quest-popup-icon {
  font-size: 32px;
}

.quest-popup-body {
  font-size: 14px;
  line-height: 1.6;
}

.quest-popup-points {
  margin-top: 10px;
  padding: 10px;
  background: rgba(255,255,255,0.2);
  border-radius: 8px;
  text-align: center;
  font-size: 16px;
  font-weight: bold;
}

body.dark-mode .quest-popup {
  background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
}

#navUserInfo {
  font-size: 14px;
  margin-right: 10px;
  opacity: 0.8;
  cursor: pointer;
  transition: opacity 0.2s;
}

#navUserInfo:hover {
  opacity: 1;
}

#navAuthLink {
  text-decoration: none;
  font-weight: bold;
  margin-right: 10px;
}
nav a {
  text-decoration: none;
  color:#333;
  font-weight: bold;
}

/* Fixiere die Navigationsleiste am oberen Bildschirmrand */
nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  width: 100%;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 16px;
  z-index: 1000; /* über allen Inhalten */
}

.nav-spacer { flex: 1; }

#themeToggle {
  margin-left:auto;
  padding:7px 12px;
  background:#007bff;
  color:#fff;
  border-radius:5px;
  cursor:pointer;
  border:none;
  font-size:14px;
}

.section { padding: 120px 20px 20px 20px; max-width: 900px; margin:auto; position: relative; z-index: 1; }

.date-box {
  margin-left: 10px;
  margin-right: 24px; /* etwas weiter nach links rücken */
  background: #fff;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.card {
  background:white;
  padding:20px;
  border-radius:8px;
  margin-bottom:15px;
  box-shadow:0 2px 4px rgba(0,0,0,0.1);
  position: relative;
  z-index: 1;
}

input, textarea {
  width:100%;
  padding:10px;
  margin:8px 0;
  border-radius:6px;
  border:1px solid #ccc;
  font-size:16px;
}
button {
  padding:10px 15px;
  background:#007bff;
  border:none;
  color:white;
  border-radius:6px;
  cursor:pointer;
}
button:hover { background:#0056b3; }

.chat-box {
  max-height:300px;
  overflow-y:auto;
  background:#fff;
  padding:10px;
  border-radius:8px;
}
.message {
  padding:5px 8px;
  margin-bottom:8px;
  background:#e9ecef;
  border-radius:5px;
}
.game-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }

/* TicTacToe */
.ttt-btn {
  width:60px;
  height:60px;
  font-size:26px;
}

/* Snake */
canvas { border: 1px solid #ccc; }

/* Schach */
#chessBoard {
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.chess-square {
  width: 45px;
  height: 45px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 34px;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

/* Weiße Figuren - deutlicher Unterschied */
.chess-square.white-piece {
  color: #ffffff;
  text-shadow: 
    -1px -1px 0 #000,
    1px -1px 0 #000,
    -1px 1px 0 #000,
    1px 1px 0 #000,
    0 0 3px #000,
    0 0 5px rgba(0,0,0,0.5);
}

/* Schwarze Figuren - deutlicher Unterschied */
.chess-square.black-piece {
  color: #1a1a1a;
  text-shadow: 
    -1px -1px 0 #fff,
    1px -1px 0 #fff,
    -1px 1px 0 #fff,
    1px 1px 0 #fff,
    0 0 3px #fff,
    0 0 5px rgba(255,255,255,0.5);
}

/* Standard Mode - klassisches Schachbrett */
.chess-square.light { 
  background: #eeeed2;
}
.chess-square.dark { 
  background: #769656;
}

/* Ausgewähltes Feld */
.chess-square.selected { 
  background: #f6f669 !important;
  box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
  transform: scale(0.95);
}

/* Mögliche Züge */
.chess-square.possible-move {
  background: #baca44 !important;
  position: relative;
}
.chess-square.possible-move::after {
  content: '●';
  position: absolute;
  font-size: 12px;
  color: rgba(0,0,0,0.3);
  pointer-events: none;
}

.chess-square:hover {
  transform: scale(1.05);
  filter: brightness(1.1);
}

/* Dark Mode - kontrastreicheres Schachbrett */
body.dark-mode #chessBoard {
  box-shadow: 0 4px 15px rgba(255,255,255,0.1);
}

body.dark-mode .chess-square.white-piece {
  color: #f0f0f0;
  text-shadow: 
    -1px -1px 0 #000,
    1px -1px 0 #000,
    -1px 1px 0 #000,
    1px 1px 0 #000,
    0 0 4px #000,
    0 0 6px rgba(0,0,0,0.8);
}

body.dark-mode .chess-square.black-piece {
  color: #0a0a0a;
  text-shadow: 
    -1px -1px 0 #fff,
    1px -1px 0 #fff,
    -1px 1px 0 #fff,
    1px 1px 0 #fff,
    0 0 4px #fff,
    0 0 6px rgba(255,255,255,0.8);
}

body.dark-mode .chess-square.light { 
  background: #4a6fa5;
  color: #fff;
}
body.dark-mode .chess-square.dark { 
  background: #2d4263;
  color: #f0f0f0;
}

body.dark-mode .chess-square.selected {
  background: #ff6b6b !important;
  box-shadow: inset 0 0 15px rgba(255,255,255,0.3);
}

body.dark-mode .chess-square.possible-move {
  background: #e63946 !important;
}

body.dark-mode .chess-square.possible-move::after {
  color: rgba(255,255,255,0.5);
}

/* Darkmode für Elemente */
body.dark-mode nav,
body.dark-mode .card,
body.dark-mode .date-box,
body.dark-mode .chat-box {
  background:#222;
  color:#f2f4f8;
}

/* 123 Theme Styling (Alias für fehlenden Bindestrich) */
body.numbers-123-theme,
body.numbers123-theme {
  background: #0d0d0d;
  color: #ffffff;
  position: relative;
  overflow-x: hidden;
}

/* Weiß schwebende 1 2 3 (dezent) nur im 123 Theme */
body.numbers-123-theme .floating-123,
body.numbers123-theme .floating-123 {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 160px;
  pointer-events: none;
  z-index: 1;
  display: block; /* JS blendet komplett aus wenn Theme nicht aktiv */
}
body.numbers-123-theme .floating-123 span,
body.numbers123-theme .floating-123 span {
  position: absolute;
  font-family: 'Courier New', monospace;
  font-weight: 600;
  font-size: 34px;
  color: rgba(255,255,255,0.85);
  text-shadow: 0 0 6px rgba(255,255,255,0.6), 0 0 12px rgba(255,255,255,0.3);
  animation: float123 7s ease-in-out infinite;
}
@keyframes float123 {
  0% { transform: translateY(0px) translateX(0); opacity:0.9; }
  25% { transform: translateY(12px) translateX(6px); opacity:0.95; }
  50% { transform: translateY(0px) translateX(0); opacity:0.9; }
  75% { transform: translateY(-10px) translateX(-4px); opacity:0.85; }
  100% { transform: translateY(0px) translateX(0); opacity:0.9; }
}

/* Neue einzelne Ziffern direkt im Body (.number-floating) */
body.numbers-123-theme .number-floating,
body.numbers123-theme .number-floating {
  position: fixed;
  pointer-events: none;
  font-family: 'Courier New', monospace;
  font-weight: 600;
  font-size: 40px;
  line-height: 1;
  color: rgba(255,255,255,0.9);
  text-shadow: 0 0 6px rgba(255,255,255,0.7), 0 0 14px rgba(255,255,255,0.45), 0 0 28px rgba(255,255,255,0.25);
  animation: float123 7s ease-in-out infinite;
  z-index: 2;
  will-change: transform;
}

/* Binäre Zahlen-Layer (1, 2, 3) */
body.numbers-123-theme .number-layer-1,
body.numbers-123-theme .number-layer-2,
body.numbers-123-theme .number-layer-3,
body.numbers123-theme .number-layer-1,
body.numbers123-theme .number-layer-2,
body.numbers123-theme .number-layer-3 {
  display: none !important; /* Matrix-Hintergrund entfernt, nur wenige schwebende Ziffern */
}

body.numbers-123-theme .number-layer-1 {
  animation: pulse-1 6s ease-in-out infinite;
}

body.numbers-123-theme .number-layer-2 {
  animation: pulse-2 6s ease-in-out infinite;
}

body.numbers-123-theme .number-layer-3 {
  animation: pulse-3 6s ease-in-out infinite;
}

@keyframes pulse-1 {
  0% { 
    opacity: 1;
    color: rgba(0, 255, 65, 0.4);
    text-shadow: 
      0 0 20px rgba(0, 255, 65, 0.8),
      0 0 40px rgba(0, 255, 65, 0.6),
      0 0 60px rgba(0, 255, 65, 0.4),
      0 0 80px rgba(0, 255, 65, 0.2);
  }
  16.66% { 
    opacity: 1;
    color: rgba(0, 255, 65, 0.4);
    text-shadow: 
      0 0 20px rgba(0, 255, 65, 0.8),
      0 0 40px rgba(0, 255, 65, 0.6),
      0 0 60px rgba(0, 255, 65, 0.4),
      0 0 80px rgba(0, 255, 65, 0.2);
  }
  25% { 
    opacity: 0.5;
    color: rgba(0, 255, 65, 0.2);
    text-shadow: 
      0 0 15px rgba(0, 255, 65, 0.5),
      0 0 30px rgba(0, 255, 65, 0.3);
  }
  33.33%, 100% { 
    opacity: 0.3;
    color: rgba(0, 255, 65, 0.1);
    text-shadow: 
      0 0 10px rgba(0, 255, 65, 0.3),
      0 0 20px rgba(0, 255, 65, 0.15);
  }
}

@keyframes pulse-2 {
  0%, 25% { 
    opacity: 0.3;
    color: rgba(0, 255, 65, 0.1);
    text-shadow: 
      0 0 10px rgba(0, 255, 65, 0.3),
      0 0 20px rgba(0, 255, 65, 0.15);
  }
  33.33% { 
    opacity: 1;
    color: rgba(0, 255, 65, 0.4);
    text-shadow: 
      0 0 20px rgba(0, 255, 65, 0.8),
      0 0 40px rgba(0, 255, 65, 0.6),
      0 0 60px rgba(0, 255, 65, 0.4),
      0 0 80px rgba(0, 255, 65, 0.2);
  }
  49.99% { 
    opacity: 1;
    color: rgba(0, 255, 65, 0.4);
    text-shadow: 
      0 0 20px rgba(0, 255, 65, 0.8),
      0 0 40px rgba(0, 255, 65, 0.6),
      0 0 60px rgba(0, 255, 65, 0.4),
      0 0 80px rgba(0, 255, 65, 0.2);
  }
  58.33% { 
    opacity: 0.5;
    color: rgba(0, 255, 65, 0.2);
    text-shadow: 
      0 0 15px rgba(0, 255, 65, 0.5),
      0 0 30px rgba(0, 255, 65, 0.3);
  }
  66.66%, 100% { 
    opacity: 0.3;
    color: rgba(0, 255, 65, 0.1);
    text-shadow: 
      0 0 10px rgba(0, 255, 65, 0.3),
      0 0 20px rgba(0, 255, 65, 0.15);
  }
}

@keyframes pulse-3 {
  0%, 58.33% { 
    opacity: 0.3;
    color: rgba(0, 255, 65, 0.1);
    text-shadow: 
      0 0 10px rgba(0, 255, 65, 0.3),
      0 0 20px rgba(0, 255, 65, 0.15);
  }
  66.66% { 
    opacity: 1;
    color: rgba(0, 255, 65, 0.4);
    text-shadow: 
      0 0 20px rgba(0, 255, 65, 0.8),
      0 0 40px rgba(0, 255, 65, 0.6),
      0 0 60px rgba(0, 255, 65, 0.4),
      0 0 80px rgba(0, 255, 65, 0.2);
  }
  83.32% { 
    opacity: 1;
    color: rgba(0, 255, 65, 0.4);
    text-shadow: 
      0 0 20px rgba(0, 255, 65, 0.8),
      0 0 40px rgba(0, 255, 65, 0.6),
      0 0 60px rgba(0, 255, 65, 0.4),
      0 0 80px rgba(0, 255, 65, 0.2);
  }
  91.66% { 
    opacity: 0.5;
    color: rgba(0, 255, 65, 0.2);
    text-shadow: 
      0 0 15px rgba(0, 255, 65, 0.5),
      0 0 30px rgba(0, 255, 65, 0.3);
  }
  100% { 
    opacity: 0.3;
    color: rgba(0, 255, 65, 0.1);
    text-shadow: 
      0 0 10px rgba(0, 255, 65, 0.3),
      0 0 20px rgba(0, 255, 65, 0.15);
  }
}

body.numbers-123-theme .card,
body.numbers-123-theme .date-box,
body.numbers-123-theme .chat-box,
body.numbers123-theme .card,
body.numbers123-theme .date-box,
body.numbers123-theme .chat-box {
  background:#1a1a1a;
  color:#ffffff;
  border: 1px solid #333;
}

body.numbers-123-theme nav,
body.numbers123-theme nav {
  background: #1a1a1a;
  border-bottom: 1px solid #333;
}

body.numbers-123-theme nav a,
body.numbers-123-theme nav span,
body.numbers-123-theme nav button,
body.numbers123-theme nav a,
body.numbers123-theme nav span,
body.numbers123-theme nav button {
  color: #ffffff;
}

body.numbers-123-theme #navUserInfo,
body.numbers-123-theme #navAuthLink,
body.numbers123-theme #navUserInfo,
body.numbers123-theme #navAuthLink {
  color: #ffffff;
  text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
  font-weight: bold;
}

body.numbers-123-theme .nav-auth-btn,
body.numbers-123-theme #accountBtn,
body.numbers-123-theme #themeToggle,
body.numbers123-theme .nav-auth-btn,
body.numbers123-theme #accountBtn,
body.numbers123-theme #themeToggle {
  background: #ffffff !important;
  color: #000000 !important;
  border: 2px solid #ffffff !important;
  font-weight: bold;
  text-shadow: none;
}

body.numbers-123-theme .nav-auth-btn:hover,
body.numbers-123-theme #accountBtn:hover,
body.numbers-123-theme #themeToggle:hover,
body.numbers123-theme .nav-auth-btn:hover,
body.numbers123-theme #accountBtn:hover,
body.numbers123-theme #themeToggle:hover {
  background: #dddddd !important;
  border-color: #dddddd !important;
}

body.numbers-123-theme input,
body.numbers-123-theme textarea,
body.numbers123-theme input,
body.numbers123-theme textarea {
  background: #2a2a2a;
  color: #ffffff;
  border-color: #444;
}

body.numbers-123-theme button,
body.numbers123-theme button {
  background: #ffffff;
  color: #000000;
  border: 1px solid #ffffff;
}

body.numbers-123-theme button:hover,
body.numbers123-theme button:hover {
  background: #dddddd;
}

body.numbers-123-theme .message,
body.numbers123-theme .message {
  background: #2a2a2a;
}

body.numbers-123-theme .shop-item,
body.numbers123-theme .shop-item {
  background: #1a1a1a;
  border: 1px solid #333;
  color: #ffffff;
}

body.numbers-123-theme .shop-item.owned,
body.numbers123-theme .shop-item.owned {
  border-color: #28a745;
}

body.numbers-123-theme .shop-item-price,
body.numbers123-theme .shop-item-price {
  color: #ffd700;
}

body.numbers-123-theme h1,
body.numbers-123-theme h2,
body.numbers-123-theme h3,
body.numbers123-theme h1,
body.numbers123-theme h2,
body.numbers123-theme h3 {
  color: #ffffff;
}

body.numbers-123-theme .color-preview,
body.numbers-123-theme .theme-preview,
body.numbers123-theme .color-preview,
body.numbers123-theme .theme-preview {
  border: 2px solid #444;
}

body.numbers-123-theme .auth-modal-content,
body.numbers-123-theme .modal-content,
body.numbers123-theme .auth-modal-content,
body.numbers123-theme .modal-content {
  background: #1a1a1a;
  color: #ffffff;
  border: 1px solid #333;
}

body.numbers-123-theme .auth-close,
body.numbers-123-theme .close,
body.numbers123-theme .auth-close,
body.numbers123-theme .close {
  color: #ffffff;
}

body.numbers-123-theme .auth-close:hover,
body.numbers-123-theme .close:hover,
body.numbers123-theme .auth-close:hover,
body.numbers123-theme .close:hover {
  color: #dddddd;
}

body.numbers-123-theme p,
body.numbers-123-theme span,
body.numbers-123-theme label,
body.numbers123-theme p,
body.numbers123-theme span,
body.numbers123-theme label {
  color: #ffffff;
}

body.numbers-123-theme .quest-popup,
body.numbers123-theme .quest-popup {
  background: linear-gradient(135deg, #333 0%, #111 100%);
  border: 1px solid #555;
}

/* Aurora Borealis Theme - Animated Gradient */
body.aurora-borealis-theme {
  background: linear-gradient(135deg, #0a1628, #1e3a5f, #2d5f7e, #1e3a5f, #0a1628);
  background-size: 400% 400%;
  animation: aurora-gradient 15s ease infinite;
  color: #ffffff;
}

@keyframes aurora-gradient {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

body.aurora-borealis-theme::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(ellipse at 20% 30%, rgba(5, 150, 105, 0.3) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 60%, rgba(139, 92, 246, 0.3) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 80%, rgba(6, 182, 212, 0.3) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 20%, rgba(236, 72, 153, 0.3) 0%, transparent 50%);
  animation: aurora-lights 20s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes aurora-lights {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

body.aurora-borealis-theme .card,
body.aurora-borealis-theme .date-box,
body.aurora-borealis-theme .chat-box {
  background: rgba(26, 54, 82, 0.8);
  backdrop-filter: blur(10px);
  color: #ffffff;
  border: 1px solid rgba(6, 182, 212, 0.3);
}

body.aurora-borealis-theme nav {
  background: rgba(10, 22, 40, 0.95);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(6, 182, 212, 0.3);
}

body.aurora-borealis-theme nav a,
body.aurora-borealis-theme nav span,
body.aurora-borealis-theme nav button {
  color: #ffffff;
}

body.aurora-borealis-theme h1,
body.aurora-borealis-theme h2,
body.aurora-borealis-theme h3 {
  color: #00ff88;
  text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
}

body.aurora-borealis-theme input,
body.aurora-borealis-theme textarea {
  background: rgba(10, 22, 40, 0.8);
  color: #ffffff;
  border-color: rgba(6, 182, 212, 0.5);
}

body.aurora-borealis-theme button {
  background: linear-gradient(135deg, #059669, #06b6d4);
  color: #ffffff;
  border: 1px solid rgba(6, 182, 212, 0.5);
}

body.aurora-borealis-theme button:hover {
  background: linear-gradient(135deg, #047857, #0891b2);
}

body.aurora-borealis-theme .message {
  background: rgba(10, 22, 40, 0.6);
}

body.aurora-borealis-theme .shop-item {
  background: rgba(26, 54, 82, 0.6);
  border: 1px solid rgba(6, 182, 212, 0.3);
  color: #ffffff;
}

body.aurora-borealis-theme p,
body.aurora-borealis-theme span,
body.aurora-borealis-theme label {
  color: #ffffff;
}

body.aurora-borealis-theme .auth-modal-content,
body.aurora-borealis-theme .modal-content {
  background: rgba(10, 22, 40, 0.95);
  backdrop-filter: blur(10px);
  color: #ffffff;
  border: 1px solid rgba(6, 182, 212, 0.3);
}

body.aurora-borealis-theme .auth-close,
body.aurora-borealis-theme .close {
  color: #00ff88;
}

body.aurora-borealis-theme .auth-close:hover,
body.aurora-borealis-theme .close:hover {
  color: #06b6d4;
}

/* Midnight Purple Theme - Mystischer Effekt */
body.midnight-purple-theme {
  background: linear-gradient(135deg, #1a0033, #2d1b4e, #4c1d95, #2d1b4e, #1a0033);
  background-size: 400% 400%;
  animation: purple-gradient 20s ease infinite;
  color: #ffffff;
}

@keyframes purple-gradient {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

body.midnight-purple-theme::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(ellipse at 30% 40%, rgba(147, 51, 234, 0.2) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 60%, rgba(124, 58, 237, 0.2) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 20%, rgba(168, 85, 247, 0.15) 0%, transparent 50%);
  animation: purple-glow 15s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes purple-glow {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 0.8; }
}

body.midnight-purple-theme .card,
body.midnight-purple-theme .date-box,
body.midnight-purple-theme .chat-box {
  background: rgba(45, 27, 78, 0.7);
  backdrop-filter: blur(10px);
  color: #ffffff;
  border: 1px solid rgba(147, 51, 234, 0.3);
  box-shadow: 0 4px 15px rgba(147, 51, 234, 0.2);
}

body.midnight-purple-theme nav {
  background: rgba(26, 0, 51, 0.95);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(147, 51, 234, 0.4);
}

body.midnight-purple-theme nav a,
body.midnight-purple-theme nav span,
body.midnight-purple-theme nav button {
  color: #ffffff;
}

body.midnight-purple-theme h1,
body.midnight-purple-theme h2,
body.midnight-purple-theme h3 {
  color: #c084fc;
  text-shadow: 0 0 15px rgba(192, 132, 252, 0.6);
}

body.midnight-purple-theme input,
body.midnight-purple-theme textarea {
  background: rgba(26, 0, 51, 0.8);
  color: #ffffff;
  border-color: rgba(147, 51, 234, 0.5);
}

body.midnight-purple-theme button {
  background: linear-gradient(135deg, #7c3aed, #9333ea);
  color: #ffffff;
  border: 1px solid rgba(147, 51, 234, 0.5);
}

body.midnight-purple-theme button:hover {
  background: linear-gradient(135deg, #6d28d9, #7c3aed);
}

body.midnight-purple-theme .message {
  background: rgba(26, 0, 51, 0.5);
}

body.midnight-purple-theme .shop-item {
  background: rgba(45, 27, 78, 0.5);
  border: 1px solid rgba(147, 51, 234, 0.3);
  color: #ffffff;
}

body.midnight-purple-theme p,
body.midnight-purple-theme span,
body.midnight-purple-theme label {
  color: #ffffff;
}

body.midnight-purple-theme .auth-modal-content,
body.midnight-purple-theme .modal-content {
  background: rgba(26, 0, 51, 0.95);
  backdrop-filter: blur(10px);
  color: #ffffff;
  border: 1px solid rgba(147, 51, 234, 0.4);
  box-shadow: 0 8px 32px rgba(147, 51, 234, 0.3);
}

body.midnight-purple-theme .auth-close,
body.midnight-purple-theme .close {
  color: #c084fc;
}

body.midnight-purple-theme .auth-close:hover,
body.midnight-purple-theme .close:hover {
  color: #a855f7;
}

/* Frosty Night Theme - Eisiges Design mit Glow-Effekten */
body.frosty-night-theme {
  background: #0d1b2a;
  color: #e0f7ff;
}

body.frosty-night-theme::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(ellipse at 20% 30%, rgba(0, 212, 255, 0.15) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 70%, rgba(100, 200, 255, 0.1) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 50%, rgba(0, 150, 255, 0.08) 0%, transparent 60%);
  animation: frosty-glow 20s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes frosty-glow {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

body.frosty-night-theme .card,
body.frosty-night-theme .date-box,
body.frosty-night-theme .chat-box {
  background: rgba(27, 43, 66, 0.8);
  backdrop-filter: blur(12px);
  color: #e0f7ff;
  border: 1px solid rgba(0, 212, 255, 0.3);
  box-shadow: 0 4px 20px rgba(0, 212, 255, 0.2), inset 0 1px 2px rgba(255, 255, 255, 0.1);
}

body.frosty-night-theme nav {
  background: rgba(13, 27, 42, 0.95);
  backdrop-filter: blur(12px);
  border-bottom: 2px solid rgba(0, 212, 255, 0.4);
  box-shadow: 0 2px 15px rgba(0, 212, 255, 0.3);
}

body.frosty-night-theme nav a,
body.frosty-night-theme nav span,
body.frosty-night-theme nav button {
  color: #e0f7ff;
  text-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
}

body.frosty-night-theme h1,
body.frosty-night-theme h2,
body.frosty-night-theme h3 {
  color: #00d4ff;
  text-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.4);
  font-weight: 700;
}

body.frosty-night-theme input,
body.frosty-night-theme textarea {
  background: rgba(13, 27, 42, 0.9);
  color: #e0f7ff;
  border: 1px solid rgba(0, 212, 255, 0.4);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
}

body.frosty-night-theme input::placeholder,
body.frosty-night-theme textarea::placeholder {
  color: rgba(224, 247, 255, 0.5);
}

body.frosty-night-theme button {
  background: linear-gradient(135deg, #00d4ff, #0088cc);
  color: #0d1b2a;
  font-weight: 700;
  border: 1px solid rgba(0, 212, 255, 0.6);
  box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
  text-shadow: none;
}

body.frosty-night-theme button:hover {
  background: linear-gradient(135deg, #00eaff, #00b8e6);
  box-shadow: 0 6px 20px rgba(0, 212, 255, 0.6);
  transform: translateY(-1px);
}

body.frosty-night-theme .message {
  background: rgba(27, 43, 66, 0.6);
  border-left: 3px solid #00d4ff;
  color: #e0f7ff;
}

body.frosty-night-theme .shop-item {
  background: rgba(27, 43, 66, 0.7);
  border: 1px solid rgba(0, 212, 255, 0.3);
  color: #e0f7ff;
  transition: all 0.3s ease;
}

body.frosty-night-theme .shop-item:hover {
  border-color: rgba(0, 212, 255, 0.6);
  box-shadow: 0 6px 25px rgba(0, 212, 255, 0.3);
  transform: translateY(-2px);
}

body.frosty-night-theme p,
body.frosty-night-theme span,
body.frosty-night-theme label,
body.frosty-night-theme div {
  color: #e0f7ff;
}

body.frosty-night-theme .auth-modal-content,
body.frosty-night-theme .modal-content {
  background: rgba(13, 27, 42, 0.98);
  backdrop-filter: blur(15px);
  color: #e0f7ff;
  border: 2px solid rgba(0, 212, 255, 0.5);
  box-shadow: 0 10px 40px rgba(0, 212, 255, 0.4);
}

body.frosty-night-theme .auth-close,
body.frosty-night-theme .close {
  color: #00d4ff;
  text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
}

body.frosty-night-theme .auth-close:hover,
body.frosty-night-theme .close:hover {
  color: #00eaff;
  text-shadow: 0 0 15px rgba(0, 212, 255, 1);
}

/* Frosty Night: private chat bubbles inside modals (friends chat) */
body.frosty-night-theme .modal-content .message {
  background: #eaf4ff; /* very light, slightly blue-tinted for contrast */
  color: #0b2540;      /* deep navy for strong readability */
}
body.frosty-night-theme .modal-content .message .name {
  color: #0b2540;
}
body.frosty-night-theme .modal-content .message .time,
body.frosty-night-theme .modal-content .message .timestamp,
body.frosty-night-theme .modal-content .message .meta {
  color: #5b7a99; /* softer meta text on light bubble */
}
/* Force high contrast for incoming messages regardless of class names */
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) {
  background: #ffffff;
  color: #0b2540;
}
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .name { color: #0b2540; }
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .time,
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .timestamp,
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .meta { color: #5b7a99; }
/* Ensure all text inside incoming bubbles is dark and readable */
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) * {
  color: #0b2540 !important;
}
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .time,
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .timestamp,
body.frosty-night-theme .modal-content .message:not(.me):not(.outgoing) .meta {
  color: #5b7a99 !important;
}

/* ========================================================================= */
/* ADVENT EXCLUSIVE THEMES                                                   */
/* ========================================================================= */

/* Kristallpalast (Crystal Palace) - Icy shimmer with frost patterns */
@keyframes crystalShimmer {
  0%, 100% {
    background-position: 0% 50%;
    filter: brightness(1) saturate(1.1);
  }
  50% {
    background-position: 100% 50%;
    filter: brightness(1.15) saturate(1.3);
  }
}

@keyframes frostPulse {
  0%, 100% { opacity: 0.15; }
  50% { opacity: 0.3; }
}

body.advent-crystal-palace-theme {
  background: linear-gradient(135deg, #e8f4f8, #d4e9f0, #c5e1e6, #b8dae3, #a8d8e0);
  background-size: 400% 400%;
  animation: crystalShimmer 12s ease-in-out infinite;
  color: #0a3d52;
}

body.advent-crystal-palace-theme::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: 
    radial-gradient(circle at 20% 30%, rgba(185, 242, 255, 0.3) 0%, transparent 50%),
    radial-gradient(circle at 80% 70%, rgba(173, 216, 230, 0.25) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(224, 255, 255, 0.2) 0%, transparent 60%);
  animation: frostPulse 8s ease-in-out infinite;
  pointer-events: none;
  z-index: -1;
}

body.advent-crystal-palace-theme .card,
body.advent-crystal-palace-theme .date-box,
body.advent-crystal-palace-theme .chat-box {
  background: rgba(255, 255, 255, 0.85);
  backdrop-filter: blur(12px);
  border: 2px solid rgba(185, 242, 255, 0.4);
  box-shadow: 0 8px 32px rgba(173, 216, 230, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.6);
  color: #0a3d52;
}

body.advent-crystal-palace-theme nav {
  background: rgba(200, 230, 245, 0.9);
  backdrop-filter: blur(15px);
  border-bottom: 2px solid rgba(185, 242, 255, 0.5);
  box-shadow: 0 4px 20px rgba(173, 216, 230, 0.4);
}

body.advent-crystal-palace-theme h1,
body.advent-crystal-palace-theme h2,
body.advent-crystal-palace-theme h3 {
  color: #0a3d52;
  text-shadow: 0 0 10px rgba(185, 242, 255, 0.5), 0 2px 4px rgba(173, 216, 230, 0.3);
}

body.advent-crystal-palace-theme button {
  background: linear-gradient(135deg, #b8dae3, #a8d8e0);
  color: #0a3d52;
  border: 2px solid rgba(185, 242, 255, 0.6);
  box-shadow: 0 4px 15px rgba(173, 216, 230, 0.3);
  font-weight: 600;
}

body.advent-crystal-palace-theme button:hover {
  background: linear-gradient(135deg, #a8d8e0, #9ad0da);
  box-shadow: 0 6px 25px rgba(173, 216, 230, 0.5);
  transform: translateY(-2px);
}

/* Nordlichter (Northern Lights) - Aurora waves animation */
@keyframes auroraWave {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

body.advent-northern-lights-theme {
  background: linear-gradient(135deg, 
    #1a237e 0%, 
    #00ff88 10%,
    #8b45ff 20%,
    #1b5e20 30%,
    #00ff88 40%,
    #4a148c 50%,
    #06b6d4 60%,
    #1a237e 70%,
    #8b45ff 80%,
    #004d40 90%,
    #1a237e 100%
  );
  background-size: 400% 400%;
  animation: auroraWave 20s ease-in-out infinite;
  color: #e0f7ff;
}

body.advent-northern-lights-theme .card,
body.advent-northern-lights-theme .date-box,
body.advent-northern-lights-theme .chat-box {
  background: rgba(10, 20, 40, 0.9);
  backdrop-filter: blur(15px);
  border: 2px solid rgba(0, 255, 136, 0.3);
  box-shadow: 
    0 8px 32px rgba(0, 255, 136, 0.2),
    0 0 20px rgba(139, 69, 255, 0.15),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  color: #e0f7ff;
}

body.advent-northern-lights-theme nav {
  background: rgba(10, 20, 40, 0.95);
  backdrop-filter: blur(20px);
  border-bottom: 2px solid rgba(0, 255, 136, 0.4);
  box-shadow: 
    0 4px 20px rgba(0, 255, 136, 0.3),
    0 0 40px rgba(139, 69, 255, 0.2);
}

body.advent-northern-lights-theme nav a,
body.advent-northern-lights-theme nav span,
body.advent-northern-lights-theme nav button {
  color: #e0f7ff;
}

body.advent-northern-lights-theme h1,
body.advent-northern-lights-theme h2,
body.advent-northern-lights-theme h3 {
  color: #00ff88;
  text-shadow: 
    0 0 20px rgba(0, 255, 136, 0.6),
    0 0 40px rgba(0, 255, 136, 0.3),
    0 2px 8px rgba(139, 69, 255, 0.2);
}

body.advent-northern-lights-theme input,
body.advent-northern-lights-theme textarea {
  background: rgba(10, 20, 40, 0.8);
  color: #e0f7ff;
  border: 2px solid rgba(0, 255, 136, 0.4);
}

body.advent-northern-lights-theme button {
  background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(139, 69, 255, 0.2));
  color: #e0f7ff;
  border: 2px solid rgba(0, 255, 136, 0.5);
  box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
  font-weight: 600;
}

body.advent-northern-lights-theme button:hover {
  background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(139, 69, 255, 0.3));
  box-shadow: 
    0 6px 25px rgba(0, 255, 136, 0.5),
    0 0 30px rgba(139, 69, 255, 0.4);
  transform: translateY(-2px);
}

body.advent-northern-lights-theme .message {
  background: rgba(10, 25, 45, 0.85);
  border-left: 3px solid rgba(0, 255, 136, 0.5);
}

body.advent-northern-lights-theme .shop-item {
  background: rgba(10, 20, 40, 0.85);
  border: 2px solid rgba(0, 255, 136, 0.3);
  box-shadow: 0 4px 15px rgba(0, 255, 136, 0.2);
}

body.advent-northern-lights-theme p,
body.advent-northern-lights-theme span,
body.advent-northern-lights-theme label {
  color: #e0f7ff;
}

/* Heilige Nacht (Holy Night) - Deep starry night with twinkling stars */
@keyframes starTwinkle {
  0%, 100% { opacity: 0.3; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.2); }
}

@keyframes holyGlow {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(30, 58, 95, 0.5),
                inset 0 0 30px rgba(10, 25, 48, 0.3);
  }
  50% { 
    box-shadow: 0 0 40px rgba(30, 58, 95, 0.8),
                inset 0 0 50px rgba(10, 25, 48, 0.5);
  }
}

body.advent-holy-night-theme {
  background: 
    radial-gradient(2px 2px at 20% 30%, white, transparent),
    radial-gradient(2px 2px at 60% 70%, white, transparent),
    radial-gradient(1px 1px at 50% 50%, white, transparent),
    radial-gradient(1px 1px at 80% 10%, white, transparent),
    radial-gradient(2px 2px at 90% 60%, white, transparent),
    radial-gradient(1px 1px at 33% 80%, white, transparent),
    radial-gradient(2px 2px at 15% 90%, white, transparent),
    linear-gradient(135deg, #0a1930 0%, #1e3a5f 50%, #0d2540 100%);
  background-size: 200% 200%, 200% 200%, 200% 200%, 200% 200%, 200% 200%, 200% 200%, 200% 200%, 100% 100%;
  background-position: 0% 0%, 40% 60%, 130% 270%, 70% 100%, 50% 120%, 230% 20%, 90% 180%, 0% 0%;
  color: #d4e4f7;
}

body.advent-holy-night-theme::before {
  content: '';
  position: fixed;
  top: 50%; left: 50%;
  width: 150%; height: 150%;
  transform: translate(-50%, -50%);
  background: radial-gradient(ellipse at center, rgba(30, 58, 95, 0.3) 0%, transparent 70%);
  animation: holyGlow 8s ease-in-out infinite;
  pointer-events: none;
  z-index: -1;
}

body.advent-holy-night-theme .card,
body.advent-holy-night-theme .date-box,
body.advent-holy-night-theme .chat-box {
  background: rgba(13, 27, 64, 0.9);
  backdrop-filter: blur(12px);
  border: 2px solid rgba(30, 58, 95, 0.6);
  box-shadow: 
    0 8px 32px rgba(10, 25, 48, 0.5),
    0 0 20px rgba(30, 58, 95, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  color: #d4e4f7;
  position: relative;
  z-index: 1;
}

body.advent-holy-night-theme nav {
  background: rgba(10, 25, 48, 0.95);
  backdrop-filter: blur(15px);
  border-bottom: 2px solid rgba(30, 58, 95, 0.7);
  box-shadow: 0 4px 20px rgba(10, 25, 48, 0.6);
}

body.advent-holy-night-theme nav a,
body.advent-holy-night-theme nav span,
body.advent-holy-night-theme nav button {
  color: #d4e4f7;
}

body.advent-holy-night-theme h1,
body.advent-holy-night-theme h2,
body.advent-holy-night-theme h3 {
  color: #89b4d8;
  text-shadow: 
    0 0 10px rgba(30, 58, 95, 0.5),
    0 2px 4px rgba(10, 25, 48, 0.3);
}

body.advent-holy-night-theme input,
body.advent-holy-night-theme textarea {
  background: rgba(10, 25, 48, 0.8);
  color: #d4e4f7;
  border: 2px solid rgba(30, 58, 95, 0.6);
}

body.advent-holy-night-theme button {
  background: linear-gradient(135deg, rgba(30, 58, 95, 0.6), rgba(13, 37, 64, 0.6));
  color: #d4e4f7;
  border: 2px solid rgba(30, 58, 95, 0.8);
  box-shadow: 0 4px 15px rgba(10, 25, 48, 0.4);
  font-weight: 600;
}

body.advent-holy-night-theme button:hover {
  background: linear-gradient(135deg, rgba(30, 58, 95, 0.8), rgba(13, 37, 64, 0.8));
  box-shadow: 0 6px 25px rgba(30, 58, 95, 0.6);
  transform: translateY(-2px);
}

body.advent-holy-night-theme .message {
  background: rgba(13, 30, 55, 0.85);
  border-left: 3px solid rgba(30, 58, 95, 0.7);
}

body.advent-holy-night-theme .shop-item {
  background: rgba(13, 27, 64, 0.85);
  border: 2px solid rgba(30, 58, 95, 0.5);
  box-shadow: 0 4px 15px rgba(10, 25, 48, 0.4);
}

body.advent-holy-night-theme p,
body.advent-holy-night-theme span,
body.advent-holy-night-theme label {
  color: #d4e4f7;
}

/* Neutral chat modal: no theme effects, high readability */
.modal-content .chat-box {
  background: #ffffff !important;
  color: #111111 !important;
  text-shadow: none !important;
  filter: none !important;
}
.modal-content .message {
  background: #f2f3f5 !important;
  color: #111111 !important;
  text-shadow: none !important;
  filter: none !important;
}
.modal-content .message .name,
.modal-content .message .timestamp,
.modal-content .message .time,
.modal-content .message .meta {
  color: #111111 !important;
  text-shadow: none !important;
}
/* Other user messages: force plain black text */
.modal-content .message:not(.me):not(.outgoing),
.modal-content .message:not(.me):not(.outgoing) * {
  color: #000000 !important;
}
.modal-content .message:not(.me):not(.outgoing) {
  background: #ffffff !important;
}

/* Private chat: force ALL message text to black */
.modal-content .message,
.modal-content .message * {
  color: #000000 !important;
  -webkit-text-fill-color: initial !important;
  text-shadow: none !important;
}
/* Outgoing bubble variant (common classes: .me, .outgoing) */
body.frosty-night-theme .modal-content .message.me,
body.frosty-night-theme .modal-content .message.outgoing {
  background: #1e6bd7; /* bright blue */
  color: #ffffff;
}
body.frosty-night-theme .modal-content .message.me .name,
body.frosty-night-theme .modal-content .message.outgoing .name {
  color: #ffffff;
}
body.frosty-night-theme .modal-content .message.me .time,
body.frosty-night-theme .modal-content .message.me .timestamp,
body.frosty-night-theme .modal-content .message.me .meta,
body.frosty-night-theme .modal-content .message.outgoing .time,
body.frosty-night-theme .modal-content .message.outgoing .timestamp,
body.frosty-night-theme .modal-content .message.outgoing .meta {
  color: #d6e8ff; /* readable meta on dark bubble */
}

/* Ranking tables: improve contrast in dark/frosty themes */
body.frosty-night-theme .ranking-table,
body.dark-mode .ranking-table,
body.midnight-purple-theme .ranking-table,
body.aurora-borealis-theme .ranking-table {
  color: #e0f7ff;
}
body.frosty-night-theme .ranking-table tr,
body.dark-mode .ranking-table tr,
body.midnight-purple-theme .ranking-table tr,
body.aurora-borealis-theme .ranking-table tr {
  background: rgba(27, 43, 66, 0.7);
}
body.frosty-night-theme .ranking-table tr:nth-child(even),
body.dark-mode .ranking-table tr:nth-child(even),
body.midnight-purple-theme .ranking-table tr:nth-child(even),
body.aurora-borealis-theme .ranking-table tr:nth-child(even) {
  background: rgba(20, 32, 50, 0.7);
}
body.frosty-night-theme .ranking-table td,
body.frosty-night-theme .ranking-table th,
body.dark-mode .ranking-table td,
body.dark-mode .ranking-table th,
body.midnight-purple-theme .ranking-table td,
body.midnight-purple-theme .ranking-table th,
body.aurora-borealis-theme .ranking-table td,
body.aurora-borealis-theme .ranking-table th {
  border-bottom: 1px solid rgba(255,255,255,0.15);
}

/* Universal Ranking Table: always black text on white background */
.ranking-table,
.ranking-table thead,
.ranking-table tbody,
.ranking-table tr,
.ranking-table th,
.ranking-table td {
  background: #ffffff !important;
  color: #000000 !important;
  text-shadow: none !important;
  filter: none !important;
}
.ranking-table tr:nth-child(even) {
  background: #f5f7fa !important;
}
.ranking-table th {
  border-bottom: 2px solid #e0e6ed !important;
}
.ranking-table td {
  border-bottom: 1px solid #e0e6ed !important;
}
/* Disable name color effects inside ranking tables */
.ranking-table [data-color-id],
.ranking-table .santa-text,
.ranking-table .holly-text,
.ranking-table .icy-text,
.ranking-table .gold-text,
.ranking-table .ruby-text,
.ranking-table .emerald-text,
.ranking-table .diamond-text,
.ranking-table .rainbow-text {
  color: #000000 !important;
  -webkit-text-fill-color: initial !important;
  background: none !important;
  animation: none !important;
  text-shadow: none !important;
}

/* Private chat panel readability (requires #privateChatPanel container) */
#privateChatPanel {
  background: rgba(27, 43, 66, 0.85);
  color: #e0f7ff;
  border: 1px solid rgba(255,255,255,0.15);
}
#privateChatPanel .message {
  background: rgba(20, 32, 50, 0.85);
  color: #e0f7ff;
}
#privateChatPanel input,
#privateChatPanel textarea {
  background: rgba(16, 24, 40, 0.9);
  color: #e0f7ff;
  border-color: rgba(255,255,255,0.2);
}

body.dark-mode nav a { color:#f2f4f8; }

body.dark-mode input,
body.dark-mode textarea {
  background:#333;
  color:#f2f4f8;
  border-color:#555;
}
body.dark-mode .message {
  background:#444;
  color:#fff;
}

/* TicTacToe Dark-Mode */
body.dark-mode #tttCurrentPlayer {
  background:#444 !important;
  color:#f2f4f8 !important;
}

body.dark-mode #tttOpponent {
  color:#f2f4f8 !important;
}

body.dark-mode #tttStatus {
  color:#f2f4f8 !important;
}

body.dark-mode #tttBoard button {
  background:#333;
  color:#f2f4f8;
  border:1px solid #555;
}

body.dark-mode #tttBoard button:hover:not(:disabled) {
  background:#444;
}

body.dark-mode #tttBoard button:disabled {
  opacity:0.6;
}

/* Game Horizontal Scroller */
.game-container {
  display: flex;
  gap: 20px;
  overflow-x: auto;
  scroll-behavior: smooth;
  padding: 10px 0;
  margin-bottom: 20px;
}

.game-container::-webkit-scrollbar {
  height: 8px;
}

.game-container::-webkit-scrollbar-track {
  background: #e0e0e0;
  border-radius: 5px;
}

body.dark-mode .game-container::-webkit-scrollbar-track {
  background: #333;
}

.game-container::-webkit-scrollbar-thumb {
  background: #007bff;
  border-radius: 5px;
}

.game-container::-webkit-scrollbar-thumb:hover {
  background: #0056b3;
}

.game-item {
  flex: 0 0 360px;
  min-width: 360px;
}

.scroll-button {
  padding: 10px 15px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 18px;
  margin: 0 5px;
}

.scroll-button:hover {
  background: #0056b3;
}

body.dark-mode .scroll-button {
  background: #0056b3;
}

/* Shop */
.shop-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 20px;
}

.shop-item {
  padding: 12px;
  margin: 8px 0;
  border: 2px solid #ddd;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  transition: all 0.3s;
}

body.dark-mode .shop-item {
  border-color: #555;
}

.shop-item:hover {
  border-color: #007bff;
  background: #f0f8ff;
}

body.dark-mode .shop-item:hover {
  background: #333;
  border-color: #0056b3;
}

.shop-item.owned {
  border-color: #28a745;
  background: #f0fff4;
}

body.dark-mode .shop-item.owned {
  background: #1a3a1a;
}

.shop-item.active {
  border-color: #FFD700;
  background: #fffacd;
  box-shadow: 0 0 10px rgba(255,215,0,0.5);
}

body.dark-mode .shop-item.active {
  background: #2d2d00;
  box-shadow: 0 0 10px rgba(255,215,0,0.3);
}

.shop-item-info {
  flex: 1;
}

.shop-item-price {
  font-weight: bold;
  color: #FFD700;
  margin-left: 10px;
}

.shop-item-owned-badge {
  background: #28a745;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: bold;
}

.shop-item-active-badge {
  background: #FFD700;
  color: #000;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: bold;
}

.color-preview {
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 4px;
  margin-right: 8px;
  border: 1px solid #333;
}

/* Theme Preview */
.theme-preview {
  display: inline-block;
  width: 30px;
  height: 30px;
  border-radius: 4px;
  margin-right: 8px;
  border: 2px solid #333;
}

 /* Theme-Variablen */
:root {
  --theme-bg: #f2f4f8;
  --theme-accent: #007bff;
  --theme-card-bg: #ffffff;
  --theme-text: #111;
  --theme-chat-msg: #e9ecef;
}

/* Basis auf Variablen */
body {
  background: var(--theme-bg);
  color: var(--theme-text);
}
.nav-auth-btn,
#themeToggle,
.scroll-button,
button { background: var(--theme-accent); }
.card, .date-box, .chat-box { background: var(--theme-card-bg); }
.message { background: var(--theme-chat-msg); }

/* Darkmode bleibt dunkel, Text hell */
body.dark-mode { background:#111; color:#f2f4f8; }
body.dark-mode nav,
body.dark-mode .card,
body.dark-mode .date-box,
body.dark-mode .chat-box { background:#222; color:#f2f4f8; }

/* Inventory sections: force three columns in one row */
#inventar-sections {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 16px;
}

#inventoryChatColors, #inventoryThemes, #inventoryBadges {
  /* Ensure sections behave as grid items and stretch */
  min-width: 0;
}

/* Responsive: stack on narrow screens */
@media (max-width: 900px) {
  #inventar-sections { grid-template-columns: 1fr 1fr; }
}
@media (max-width: 640px) {
  #inventar-sections { grid-template-columns: 1fr; }
}

/* Inventory controls bar above sections */
#inventar-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 10px;
  margin-bottom: 16px;
}

#inventar-controls .spacer { flex: 1 1 auto; }

/* BP Name Color Effects (Chat + Previews) */
@keyframes santaPulseGlow {
  0%, 100% {
    text-shadow: 0 0 2px rgba(211,47,47,0.30), 0 0 6px rgba(211,47,47,0.22);
  }
  50% {
    text-shadow: 0 0 6px rgba(211,47,47,0.55), 0 0 12px rgba(211,47,47,0.40);
  }
}
.santa-text { color:#D32F2F; animation: santaPulseGlow 2.2s ease-in-out infinite; font-weight:600; }

@keyframes hollyPulseGlow {
  0%, 100% {
    text-shadow: 0 0 2px rgba(27,94,32,0.28), 0 0 6px rgba(27,94,32,0.20);
  }
  50% {
    text-shadow: 0 0 6px rgba(27,94,32,0.50), 0 0 10px rgba(255,0,0,0.25);
  }
}
.holly-text { color:#1B5E20; animation: hollyPulseGlow 2.4s ease-in-out infinite; font-weight:600; }

@keyframes icyShimmerFlow {
  0% {
    background-position: 150% 0;
    text-shadow: 0 0 3px rgba(179,229,252,0.40), 0 0 8px rgba(179,229,252,0.24);
  }
  100% {
    background-position: -150% 0;
    text-shadow: 0 0 5px rgba(179,229,252,0.55), 0 0 12px rgba(179,229,252,0.36);
  }
}
.icy-text { color: transparent; background: linear-gradient(90deg, #ffffff, #B3E5FC, #ffffff); -webkit-background-clip: text; background-clip: text; background-size:200% 100%; animation: icyShimmerFlow 3s linear infinite; font-weight:600; }

@keyframes snowWhiteSnowfall {
  0%, 100% {
    text-shadow: 
      0 0 3px rgba(240,248,255,0.5), 
      0 0 6px rgba(240,248,255,0.3),
      2px 2px 1px rgba(255,255,255,0.4),
      -2px -2px 1px rgba(255,255,255,0.4),
      3px -3px 2px rgba(255,255,255,0.3),
      -3px 3px 2px rgba(255,255,255,0.3);
  }
  50% {
    text-shadow: 
      0 0 6px rgba(240,248,255,0.7), 
      0 0 10px rgba(240,248,255,0.5),
      -2px 3px 1px rgba(255,255,255,0.5),
      2px -3px 1px rgba(255,255,255,0.5),
      -3px 2px 2px rgba(255,255,255,0.4),
      3px -2px 2px rgba(255,255,255,0.4);
  }
}

@keyframes rudolfRedNose {
  0%, 100% {
    text-shadow: 
      0 0 4px rgba(196,30,58,0.6), 
      0 0 8px rgba(196,30,58,0.4),
      0 0 12px rgba(255,0,0,0.3);
    filter: brightness(1);
  }
  50% {
    text-shadow: 
      0 0 8px rgba(196,30,58,0.9), 
      0 0 16px rgba(196,30,58,0.6),
      0 0 24px rgba(255,0,0,0.5),
      0 0 32px rgba(255,100,100,0.3);
    filter: brightness(1.2);
  }
}

@keyframes goldenStarSparkle {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(255,215,0,0.8), 
      0 0 10px rgba(255,165,0,0.6),
      0 0 15px rgba(255,215,0,0.4),
      2px 2px 3px rgba(255,223,0,0.5),
      -2px -2px 3px rgba(255,223,0,0.5);
    filter: brightness(1.1) saturate(1.2);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(255,215,0,1), 
      0 0 20px rgba(255,165,0,0.8),
      0 0 30px rgba(255,215,0,0.6),
      3px 3px 5px rgba(255,255,0,0.7),
      -3px -3px 5px rgba(255,255,0,0.7);
    filter: brightness(1.3) saturate(1.5);
  }
}

@keyframes christmasMagicFlow {
  0% {
    background-position: 0% 50%;
  }
  100% {
    background-position: 200% 50%;
  }
}

/* Auto-apply effects without JS based on data-color-id */
.message .name[data-color-id="santa"],
.color-preview .color-preview-label[data-color-id="santa"],
#profileModalNickname[data-color-id="santa"],
#navUserInfo [data-color-id="santa"] {
  color:#D32F2F;
  animation: santaPulseGlow 2.2s ease-in-out infinite;
  font-weight:600;
}

.message .name[data-color-id="holly"],
.color-preview .color-preview-label[data-color-id="holly"],
#profileModalNickname[data-color-id="holly"],
#navUserInfo [data-color-id="holly"] {
  color:#1B5E20;
  animation: hollyPulseGlow 2.4s ease-in-out infinite;
  font-weight:600;
}

.message .name[data-color-id="icy"],
.color-preview .color-preview-label[data-color-id="icy"],
#profileModalNickname[data-color-id="icy"],
#navUserInfo [data-color-id="icy"] {
  color: transparent;
  background: linear-gradient(90deg, #ffffff, #B3E5FC, #ffffff);
  -webkit-background-clip: text;
  background-clip: text;
  background-size:200% 100%;
  animation: icyShimmerFlow 3s linear infinite;
  font-weight:600;
}

/* Gold shimmer */
.message .name[data-color-id="gold"],
.color-preview .color-preview-label[data-color-id="gold"],
#profileModalNickname[data-color-id="gold"],
#navUserInfo [data-color-id="gold"] {
  color:#FFD700;
  animation: gold-glow 2s ease-in-out infinite;
  font-weight:600;
}

/* Ruby pulse */
.message .name[data-color-id="ruby"],
.color-preview .color-preview-label[data-color-id="ruby"],
#profileModalNickname[data-color-id="ruby"],
#navUserInfo [data-color-id="ruby"] {
  color:#E0115F;
  animation: ruby-pulse 2.5s ease-in-out infinite;
  font-weight:700;
}

/* Emerald glow */
.message .name[data-color-id="emerald"],
.color-preview .color-preview-label[data-color-id="emerald"],
#profileModalNickname[data-color-id="emerald"],
#navUserInfo [data-color-id="emerald"] {
  color:#50C878;
  animation: emerald-glow 2.8s ease-in-out infinite;
  font-weight:700;
}

/* Diamond shimmer */
.message .name[data-color-id="diamond"],
.color-preview .color-preview-label[data-color-id="diamond"],
#profileModalNickname[data-color-id="diamond"],
#navUserInfo [data-color-id="diamond"] {
  color:#B9F2FF;
  animation: diamond-shimmer 3.5s ease-in-out infinite;
  font-weight:700;
}

/* Rainbow flow */
.message .name[data-color-id="rainbow"],
.color-preview .color-preview-label[data-color-id="rainbow"],
#profileModalNickname[data-color-id="rainbow"],
#navUserInfo [data-color-id="rainbow"] {
  background: linear-gradient(90deg, 
    #ff0000, #ff7f00, #ffff00, #00ff00,
    #0000ff, #4b0082, #9400d3, #ff0000
  );
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow-flow 3s linear infinite;
}

/* Schneeweiß (Advent Snow White) - static snowflakes decoration */
.message .name[data-color-id="advent_snow"],
.color-preview .color-preview-label[data-color-id="advent_snow"],
#profileModalNickname[data-color-id="advent_snow"],
#navUserInfo [data-color-id="advent_snow"] {
  color:#F0F8FF;
  font-weight:600;
}

.message .name[data-color-id="advent_snow"]::before,
#profileModalNickname[data-color-id="advent_snow"]::before,
#navUserInfo [data-color-id="advent_snow"]::before {
  content: '❄️ ';
  font-size: 0.85em;
  opacity: 0.8;
}

.message .name[data-color-id="advent_snow"]::after,
#profileModalNickname[data-color-id="advent_snow"]::after,
#navUserInfo [data-color-id="advent_snow"]::after {
  content: ' ❄️';
  font-size: 0.85em;
  opacity: 0.8;
}

/* Weihnachtsrot (Advent Christmas Red) - Rudolf red nose effect */
.message .name[data-color-id="advent_xmas"],
.color-preview .color-preview-label[data-color-id="advent_xmas"],
#profileModalNickname[data-color-id="advent_xmas"],
#navUserInfo [data-color-id="advent_xmas"] {
  color:#C41E3A;
  animation: rudolfRedNose 1.8s ease-in-out infinite;
  font-weight:700;
}

/* Goldener Stern (Advent Golden Star) - sparkle effect */
.message .name[data-color-id="advent_gold_star"],
.color-preview .color-preview-label[data-color-id="advent_gold_star"],
#profileModalNickname[data-color-id="advent_gold_star"],
#navUserInfo [data-color-id="advent_gold_star"] {
  color: transparent;
  background: linear-gradient(90deg, #FFD700, #FFA500, #FFED4E, #FFA500, #FFD700);
  -webkit-background-clip: text;
  background-clip: text;
  background-size: 200% auto;
  animation: goldenStarSparkle 2s ease-in-out infinite;
  font-weight: 700;
}

/* Weihnachtszauber (Advent Christmas Magic) - festive rainbow flow */
.message .name[data-color-id="advent_magic"],
.color-preview .color-preview-label[data-color-id="advent_magic"],
#profileModalNickname[data-color-id="advent_magic"],
#navUserInfo [data-color-id="advent_magic"] {
  background: linear-gradient(
    90deg, 
    #ff0000, #00ff00, #ffffff, #FFD700,
    #ff0000, #00ff00, #ffffff, #FFD700
  );
  background-size: 200% auto;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: christmasMagicFlow 3s linear infinite;
  font-weight: 700;
}

/* Advent Calendar Styles */
.advent-door {
  position: relative;
  height: 64px;
  background: linear-gradient(135deg, #ffca28, #ffd54f);
  color: #111;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 800;
  font-size: 18px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  transition: transform .15s ease, box-shadow .15s ease;
}
.advent-door:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(0,0,0,0.2); }
.advent-door.locked { opacity: 0.55; cursor: not-allowed; filter: grayscale(0.2); }
.advent-door.claimed { background: linear-gradient(135deg, #a5d6a7, #66bb6a); color: #0b3d20; }
.advent-door .corner {
  position: absolute; right: 6px; top: 6px;
  font-size: 16px; opacity: 0.9;
}
.advent-door .label { position:absolute; left: 10px; bottom: 8px; }

@keyframes doorOpen {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(-25deg); }
}
.advent-door.opening { transform-origin: left center; animation: doorOpen .5s ease forwards; }
</style>
</head>

<body>

<!-- Binäre Zahlen für 123 Theme (werden nur bei aktivem Theme angezeigt) -->
<div class="number-layer-1" id="numbers1" style="display:none;"></div>
<div class="number-layer-2" id="numbers2" style="display:none;"></div>
<div class="number-layer-3" id="numbers3" style="display:none;"></div>
<!-- Schwebende weiße 1 2 3 am Seitenanfang -->
<div class="floating-123" id="floating123" style="display:none;">
  <span style="left:4%; animation-delay:0s;">1</span>
  <span style="left:14%; animation-delay:1.2s;">2</span>
  <span style="left:26%; animation-delay:2.4s;">3</span>
  <span style="left:38%; animation-delay:3.1s;">1</span>
  <span style="left:50%; animation-delay:0.9s;">2</span>
  <span style="left:62%; animation-delay:2.9s;">3</span>
  <span style="left:74%; animation-delay:1.7s;">1</span>
  <span style="left:86%; animation-delay:3.6s;">2</span>
  <span style="left:94%; animation-delay:2.2s;">3</span>
</div>
<!-- Vollflächig verteilte schwebende Ziffern für 123 Theme -->
<div id="floatingAll123" style="display:none;"></div>

<script>
// Generiere genug Zahlen um den ganzen Bildschirm zu füllen
function fillNumberLayers() {
  // Nur ausführen wenn Theme aktiv ist
  const themeActive = document.body.classList.contains('numbers-123-theme') || document.body.classList.contains('numbers123-theme');
  const layer1 = document.getElementById('numbers1');
  const layer2 = document.getElementById('numbers2');
  const layer3 = document.getElementById('numbers3');
  const floating = document.getElementById('floating123');
  const floatingAll = document.getElementById('floatingAll123');
  if (!themeActive) {
  if (!layer1 || !layer2 || !layer3) return;
  if (!themeActive) {
    // Wenn Theme nicht aktiv -> verstecken und Inhalt leeren
    layer1.style.display = 'none';
    layer2.style.display = 'none';
    layer3.style.display = 'none';
    if (floating) floating.style.display = 'none'; // dauerhaft deaktiviert für Reduktion
    if (floatingAll) {
      floatingAll.style.display = 'none';
      floatingAll.innerHTML = '';
    }
    layer1.textContent = '';
    layer2.textContent = '';
    layer3.textContent = '';
    // Matrix Layer nicht mehr anzeigen
    layer1.style.display = 'none';
    layer2.style.display = 'none';
    layer3.style.display = 'none';
    layer2.style.display = 'block';
    layer3.style.display = 'block';
    if (floating) floating.style.display = 'none'; // oberer Cluster ausgeblendet damit Gesamtmenge ~10 bleibt
    if (floatingAll) {
      floatingAll.style.display = 'block';
      // Nur generieren wenn leer
      if (!floatingAll.children.length) {
        generateFloatingDigits();
      }
  container.style.position = 'fixed';
  container.style.inset = '0';
  container.style.pointerEvents = 'none';
  container.style.zIndex = '1';
  // Feste Menge: genau 10 Digits gewünscht
  const count = 6; // nur ein paar Ziffern
  const digits = ['1','2','3'];
  for (let i=0; i<count; i++) {
    const span = document.createElement('span');
    span.textContent = digits[i % 3];
    const x = Math.random() * 100; // vw Prozent
    const y = Math.random() * 100; // vh Prozent
    const dur = 8 + Math.random()*4; // etwas ruhiger 8-12s
    const delay = Math.random()*5; // 0-5s
    const driftX = (Math.random()*40 - 20); // -20 bis +20 px horizontale Drift
    const upDown = (Math.random()*30 - 15); // -15 bis +15 px vertikale Drift
    span.style.position = 'absolute';
    span.style.left = x + 'vw';
    span.style.top = y + 'vh';
    span.style.fontFamily = 'Courier New, monospace';
    span.style.fontWeight = '600';
    span.style.fontSize = '38px';
    span.style.color = '#ffffff';
    span.style.textShadow = '0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px rgba(255,255,255,0.6)';
    // Kombinierte Animation: Float + Flicker
    span.style.animation = `floatAll123 ${dur}s ease-in-out ${delay}s infinite, flicker123 ${3+Math.random()*3}s linear ${Math.random()*2}s infinite`;
    span.style.willChange = 'transform';
    // Individuelle CSS-Variablen für Keyframe Nutzung
    span.style.setProperty('--dx', driftX + 'px');
    span.style.setProperty('--dy', upDown + 'px');
    container.appendChild(span);
  }
}

// Keyframes für flächige Digits (einmalig anhängen falls nicht vorhanden)
(function ensureFloatAllKeyframes(){
  if (document.getElementById('floatAll123Style')) return;
  const style = document.createElement('style');
  style.id = 'floatAll123Style';
  style.textContent = `@keyframes floatAll123 {\n  0% { transform: translate(0,0); }\n  25% { transform: translate(var(--dx), calc(var(--dy) * 0.5)); }\n  50% { transform: translate(calc(var(--dx) * 0.6), var(--dy)); }\n  75% { transform: translate(calc(var(--dx) * 0.3), calc(var(--dy) * -0.3)); }\n  100% { transform: translate(0,0); }\n}\n@keyframes flicker123 {\n  0%, 100% { opacity:0.9; filter:brightness(1); }\n  45% { opacity:0.95; filter:brightness(1.15); }\n  50% { opacity:0.75; filter:brightness(0.85); }\n  55% { opacity:0.98; filter:brightness(1.2); }\n  70% { opacity:0.85; filter:brightness(0.95); }\n}`;
  document.head.appendChild(style);
})();

// Regenerieren bei Resize wenn aktiv
window.addEventListener('resize', () => {
  if (document.body.classList.contains('numbers-123-theme')) {
    generateFloatingDigits();
  }
});

// Beobachte Klassenänderungen am Body und triggere Ziffern-Generierung bei Aktivierung
(function observeThemeActivation(){
  const obs = new MutationObserver(() => {
    if (document.body.classList.contains('numbers-123-theme') || document.body.classList.contains('numbers123-theme')) {
      generateFloatingDigits();
      fillNumberLayers();
    }
  });
  obs.observe(document.body, { attributes:true, attributeFilter:['class'] });
})();

// Initial füllen und bei Resize neu füllen
fillNumberLayers();
window.addEventListener('resize', fillNumberLayers);
</script>
<!-- Advent rewards + music default off + settings toggle wiring -->
<script>
  // Ensure music is OFF by default; initialize by saved toggle only
  document.addEventListener('DOMContentLoaded', () => {
    const saved = localStorage.getItem('christmasMusicEnabled');
    const enabled = saved === 'true';
    if (enabled && typeof initChristmasMusic === 'function') initChristmasMusic();
  });

  // Award exclusive Advent rewards per day, including music on day 3
  function __getAdventReward(day) {
    // 100% brandneue Advent-exklusiv Items, keine BP/Shop-Duplikate, inkl. Münzen
    const rewards = {
      1: { type: 'badge', id: 'advent_penguin_party', text: '🐧 Advent: Penguin Party Badge' },
      2: { type: 'music', id: 'advent_snowstorm_swing', text: '🎵 Advent: Snowstorm Swing Musik' },
      3: { type: 'coins', amount: 100, text: '💰 Advent: 100 Münzen' },
      4: { type: 'font', id: 'advent_candy_script', text: '🖋️ Advent: Candy Script Schriftstyle' },
      5: { type: 'theme', id: 'advent_galaxy_winter', text: '✨ Advent: Galaxy Winter Theme' },
      6: { type: 'badge', id: 'advent_cookie_craze', text: '🍪 Advent: Cookie Craze Badge' },
      7: { type: 'music', id: 'advent_ice_disco', text: '🎵 Advent: Ice Disco Musik' },
      8: { type: 'coins', amount: 200, text: '💰 Advent: 200 Münzen' },
      9: { type: 'font', id: 'advent_sparkle_hand', text: '🖋️ Advent: Sparkle Hand Schriftstyle' },
      10:{ type: 'theme', id: 'advent_candy_galaxy', text: '✨ Advent: Candy Galaxy Theme' },
      11:{ type: 'badge', id: 'advent_reindeer_rush', text: '🦌 Advent: Reindeer Rush Badge' },
      12:{ type: 'music', id: 'advent_frosty_funk', text: '🎵 Advent: Frosty Funk Musik' },
      13:{ type: 'coins', amount: 300, text: '💰 Advent: 300 Münzen' },
      14:{ type: 'font', id: 'advent_gift_serif', text: '🖋️ Advent: Gift Serif Schriftstyle' },
      15:{ type: 'theme', id: 'advent_northern_lights', text: '✨ Advent: Northern Lights Theme' },
      16:{ type: 'badge', id: 'advent_snowman_squad', text: '⛄ Advent: Snowman Squad Badge' },
      17:{ type: 'music', id: 'advent_jolly_jam', text: '🎵 Advent: Jolly Jam Musik' },
      18:{ type: 'coins', amount: 400, text: '💰 Advent: 400 Münzen' },
      19:{ type: 'font', id: 'advent_ice_pixel', text: '🖋️ Advent: Ice Pixel Schriftstyle' },
      20:{ type: 'theme', id: 'advent_starlit_snow', text: '✨ Advent: Starlit Snow Theme' },
      21:{ type: 'badge', id: 'advent_gift_guru', text: '🎁 Advent: Gift Guru Badge' },
      22:{ type: 'music', id: 'advent_mistletoe_melody', text: '🎵 Advent: Mistletoe Melody Musik' },
      23:{ type: 'coins', amount: 500, text: '💰 Advent: 500 Münzen' },
      24:{ type: 'badge', id: 'advent_winter_legend', text: '🏆 Advent: Winter Legend Badge' },
    };
    return rewards[day] || null;
  }

  async function __grantAdventReward(day) {
    const reward = __getAdventReward(day);
    if (!reward || !window.currentUser || !window.db) return;
    const uid = currentUser.uid;
    try {
      if (reward.type === 'badge') {
        await setDoc(doc(db, 'inventory', uid, 'badges', reward.id), { ts: Date.now() });
      } else if (reward.type === 'color') {
        await setDoc(doc(db, 'inventory', uid, 'chatColors', reward.id), { ts: Date.now() });
      } else if (reward.type === 'theme') {
        await setDoc(doc(db, 'inventory', uid, 'themes', reward.id), { ts: Date.now() });
      } else if (reward.type === 'font') {
        await setDoc(doc(db, 'inventory', uid, 'fonts', reward.id), { ts: Date.now() });
      } else if (reward.type === 'music') {
        await setDoc(doc(db, 'inventory', uid, 'music', reward.id), { ts: Date.now() });
        localStorage.setItem('lastUnlockedMusicTrack', reward.id);
      } else if (reward.type === 'coins') {
        if (typeof addCoins === 'function') await addCoins(reward.amount);
      }
      if (typeof pushNotification === 'function') pushNotification('rewards', 'Advent', reward.text);
    } catch (e) {
      console.warn('Grant Advent reward failed', e);
    }
  }

  // Wrap claimTodayAdvent to grant mapped rewards
  if (typeof window.claimTodayAdvent === 'function') {
    const __origClaim = window.claimTodayAdvent;
    window.claimTodayAdvent = async function(...args) {
      const today = new Date();
      const day = today.getDate();
      const month = today.getMonth();
      await __origClaim.apply(this, args);
      if (month === 11 && day >= 1 && day <= 24) {
        await __grantAdventReward(day);
      }
    };
  }
</script>

<!-- Live Spielplan (football-data.org) – sicherer Wrapper -->
<script>
(function(){
  // Token setzen (aus deiner Nachricht)	42525aa12c0d4f478c1627432b66b0d0
  try { localStorage.setItem('footballDataToken', '42525aa12c0d4f478c1627432b66b0d0'); } catch(e) {}
  window.setFootballDataToken = function(token){ try { localStorage.setItem('footballDataToken', token || ''); } catch(e){} };

  var LEAGUE_CODES = { EPL: 'PL', LL: 'PD', BL: 'BL1', SA: 'SA', L1: 'FL1' };
  function getFDToken(){ try { return localStorage.getItem('footballDataToken') || ''; } catch(e){ return ''; } }

  function fetchLiveFixtures(leagueKey){
    return new Promise(function(resolve){
      var token = getFDToken();
      if (!token) { resolve(null); return; }
      var code = LEAGUE_CODES[leagueKey] || 'PL';
      var url = 'https://one23-fehlstundenzettel2.onrender.com/api/football/' + code;
      fetch(url)
        .then(function(res){ if (!res.ok) throw new Error('HTTP ' + res.status); return res.json(); })
        .then(function(data){
          var matches = Array.isArray(data.matches) ? data.matches : [];
          if (!matches.length) { resolve(null); return; }
          matches.sort(function(a,b){ return new Date(a.utcDate) - new Date(b.utcDate); });
          var nextRound = (matches[0] && matches[0].matchday) ? matches[0].matchday : null;
          var roundMatches = matches.filter(function(m){ return m.matchday === nextRound; });
          var fixtures = roundMatches.map(function(m){
            return { id: m.id,
                     home: (m.homeTeam && m.homeTeam.name) ? m.homeTeam.name : 'Heim',
                     away: (m.awayTeam && m.awayTeam.name) ? m.awayTeam.name : 'Auswärts',
                     kickoff: new Date(m.utcDate).getTime() };
          });
          resolve({ matchday: 'Spieltag ' + nextRound, fixtures: fixtures });
        })
        .catch(function(){ resolve(null); });
    });
  }

  function renderLiveOrFallback(){
    var leagueSelect = document.getElementById('leagueSelect');
    var fixturesList = document.getElementById('fixturesList');
    var infoEl = document.getElementById('matchdayInfo');
    if (!leagueSelect || !fixturesList || !infoEl) {
      // If elements not found, try legacy renderer
      try { if (window.loadMatchday) window.loadMatchday(); } catch(_) {}
      return;
    }
    // Ensure a valid default
    if (!leagueSelect.value) { leagueSelect.value = 'EPL'; }
    var leagueKey = leagueSelect.value || 'EPL';
    fetchLiveFixtures(leagueKey).then(function(dataset){
      if (!dataset || !(dataset.fixtures && dataset.fixtures.length)){
        // Fallback: nutze bestehendes Rendering IMMER ausführen
        try { if (window.loadMatchday) window.loadMatchday(); } catch(_) {}
        // Optional Hinweis, wenn Token existiert aber keine Daten
        var token = (function(){ try { return localStorage.getItem('footballDataToken')||''; } catch(e){ return ''; } })();
        if (token && infoEl) { infoEl.textContent = 'Live-Plan nicht verfügbar – zeige Fallback-Spieltag.'; }
        return;
      }
      fixturesList.innerHTML = '';
      infoEl.textContent = dataset.matchday;
      // Map live fixtures for global lookup by placeBet
      try {
        window.__liveFixtures = window.__liveFixtures || {};
        window.__liveFixtures[leagueKey] = {};
      } catch(_) {}
      var now = Date.now();
      dataset.fixtures.forEach(function(fx){
        var locked = fx.kickoff <= now;
        try { if (window.__liveFixtures) { window.__liveFixtures[leagueKey][String(fx.id)] = { id: fx.id, home: fx.home, away: fx.away, kickoff: fx.kickoff }; } } catch(_) {}
        var row = document.createElement('div');
        row.className = 'fixture-row';
        row.innerHTML =
          '<div><strong>' + fx.home + '</strong> vs <strong>' + fx.away + '</strong></div>' +
          '<div>Kickoff: ' + new Date(fx.kickoff).toLocaleString() + '</div>' +
          '<div>' +
            'Einsatz: <input type="number" id="stake_' + fx.id + '" min="5" max="100" value="5" ' + (locked? 'disabled':'') + ' />' +
            ' Ergebnis: ' +
              '<input type="number" id="home_' + fx.id + '" min="0" value="0" style="width:50px" ' + (locked? 'disabled':'') + ' /> :' +
              '<input type="number" id="away_' + fx.id + '" min="0" value="0" style="width:50px" ' + (locked? 'disabled':'') + ' />' +
            ' <button ' + (locked? 'disabled':'') + ' id="betbtn_' + fx.id + '" onclick="window.placeBet && window.placeBet(\'' + leagueKey + '\',\'' + fx.id + '\')">Wetten</button>' +
            (locked? '<span style="color:#b00;margin-left:8px;">Gesperrt nach Spielstart</span>':'' ) +
          '</div>';
        fixturesList.appendChild(row);
        var btn = row.querySelector('#betbtn_' + fx.id);
        if (btn && !locked){ btn.addEventListener('click', function(){ if (window.placeBet) window.placeBet(leagueKey, fx.id); }); }
      });
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    var leagueSelect = document.getElementById('leagueSelect');
    var refreshBtn = document.getElementById('refreshLocksBtn');
    if (leagueSelect) {
      if (!leagueSelect.value) { leagueSelect.value = 'EPL'; }
      leagueSelect.addEventListener('change', renderLiveOrFallback);
    }
    if (refreshBtn) refreshBtn.addEventListener('click', renderLiveOrFallback);
    // Extra delegated listener here as well (in case module script isn't ready yet)
    try {
      var container = document.getElementById('fixturesList');
      if (container && !container.getAttribute('data-live-delegate')) {
        container.addEventListener('click', function(e){
          var btn = e.target && e.target.closest && e.target.closest('button');
          if (!btn) return;
          var id = null;
          if (btn.id && btn.id.indexOf('betbtn_') === 0) id = btn.id.substring('betbtn_'.length);
          if (!id && btn.id && btn.id.indexOf('bet-btn-') === 0) id = btn.id.substring('bet-btn-'.length);
          if (!id) return;
          var leagueKey = (leagueSelect && leagueSelect.value) ? leagueSelect.value : 'EPL';
          console.debug('[live-delegate] click', leagueKey, id);
          if (window.placeBet) {
            try { window.placeBet(leagueKey, id); } catch(err){ console.error('placeBet error', err); }
          }
        }, true);
        container.setAttribute('data-live-delegate','1');
      }
    } catch(_) {}
    // Always attempt live, then fallback via internal logic
    renderLiveOrFallback();
  });
})();
</script>
<!-- Matchday Tips Logic -->
<script type="module">
// Minimal Firebase imports to work independently of existing module
import { getAuth } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, collection, doc, setDoc, updateDoc, getDocs, query, where, serverTimestamp, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

// Use auth/db lazily to avoid race with main Firebase init
let __matchdayAuth = null;
try { __matchdayAuth = getAuth(); } catch(e) { /* initialized later; fall back to window.auth in getter */ }
let __matchdayDb = null;
function __getDb(){
  if (__matchdayDb) return __matchdayDb;
  // Prefer main app's db if already created
  if (window.db) { __matchdayDb = window.db; return __matchdayDb; }
  try { __matchdayDb = getFirestore(); } catch(e) { /* will retry on first use */ }
  return __matchdayDb;
}

// Helper: get current user
function getCurrentUid() {
  const u = (window.auth && window.auth.currentUser)
    || (__matchdayAuth && __matchdayAuth.currentUser)
    || (window.firebase && firebase.auth ? firebase.auth().currentUser : null);
  return u ? u.uid : null;
}

// Minimal coin updater (independent of existing addCoins)
async function addCoinsSimple(amount) {
  const uid = getCurrentUid();
  if (!uid) throw new Error('no-user');
  const userRef = doc(__getDb(), 'users', uid);
  await updateDoc(userRef, { coins: increment(amount) });
}

// MATCHDAY TIPS ⚽ – Fixtures anzeigen + Wetten (Auszahlung Donnerstag)
const MATCHDAY_FIXTURES = {
  EPL: [
    { id: 'epl-1', home: 'Arsenal', away: 'Chelsea', kickoff: Date.now() + 86400000 },
    { id: 'epl-2', home: 'Liverpool', away: 'Manchester City', kickoff: Date.now() + 90000000 }
  ],
  LL: [
    { id: 'll-1', home: 'FC Barcelona', away: 'Real Madrid', kickoff: Date.now() + 88000000 }
  ],
  BL: [
    { id: 'bl-1', home: 'Bayern München', away: 'Borussia Dortmund', kickoff: Date.now() + 91000000 }
  ],
  SA: [
    { id: 'sa-1', home: 'AC Mailand', away: 'Inter Mailand', kickoff: Date.now() + 93000000 }
  ],
  L1: [
    { id: 'l1-1', home: 'Paris Saint-Germain', away: 'Olympique Lyon', kickoff: Date.now() + 95000000 }
  ]
};

async function loadMatchday() {
  const leagueEl = document.getElementById('leagueSelect');
  const league = leagueEl ? leagueEl.value : 'EPL';
  const fixtures = MATCHDAY_FIXTURES[league] || [];
  const uid = getCurrentUid();
  
  // Load existing bets for this user and league
  let userBets = {};
  if (uid) {
    try {
      const betsCol = collection(__getDb(), 'footballBets', uid, 'bets');
      const q = query(betsCol, where('league', '==', league));
      const snap = await getDocs(q);
      snap.forEach(doc => {
        const data = doc.data();
        userBets[data.matchId] = data;
      });
    } catch (e) {
      console.error('Error loading bets:', e);
    }
  }
  const list = document.getElementById('fixturesList');
  const info = document.getElementById('matchdayInfo');

  if (info) info.textContent = `Spiele: ${fixtures.length}. Wetten gesperrt nach Anpfiff. Auszahlung: Donnerstag.`;

  if (!list) return;
  if (fixtures.length === 0) {
    list.innerHTML = '<p style="opacity:0.7;">Keine Spiele</p>';
    return;
  }

  let html = '';
  // Get user's current coins for max stake
  const userCoins = window.getUserCoins ? window.getUserCoins() : 9999;
  fixtures.forEach(m => {
    const d = new Date(m.kickoff);
    const locked = Date.now() >= m.kickoff;
    const existingBet = userBets[m.id];
    const betPlaced = !!existingBet;
    const timeStr = d.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: '2-digit' }) + ' • ' + d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
    
    // Determine status badge
    let statusBadge = '';
    if (locked) {
      statusBadge = '<span style="color:#e74c3c; font-size:11px; font-weight:600; background:#e74c3c20; padding:4px 8px; border-radius:4px;">🔒 GESPERRT</span>';
    } else if (betPlaced) {
      statusBadge = '<span style="color:#ffa500; font-size:11px; font-weight:600; background:#ffa50020; padding:4px 8px; border-radius:4px;">✅ GETIPPT</span>';
    } else {
      statusBadge = '<span style="color:#28a745; font-size:11px; font-weight:600; background:#28a74520; padding:4px 8px; border-radius:4px;">✓ OFFEN</span>';
    }
    
    const inputsDisabled = locked || betPlaced;
    const stakeValue = betPlaced ? existingBet.stake : '';
    const scoreValue = betPlaced ? existingBet.scorePred : '';
    
    // Determine tendency from score
    let tendencyText = '';
    if (betPlaced && existingBet.scorePred) {
      const parts = existingBet.scorePred.split(':');
      if (parts.length === 2) {
        const h = parseInt(parts[0]);
        const a = parseInt(parts[1]);
        if (!isNaN(h) && !isNaN(a)) {
          if (h > a) tendencyText = '🏠 Heimsieg';
          else if (h < a) tendencyText = '✈️ Auswärtssieg';
          else tendencyText = '🤝 Unentschieden';
        }
      }
    }
    
    html += `
      <div id="match-card-${m.id}" style="border:1px solid ${locked ? '#555' : (betPlaced ? '#ffa500' : '#444')}; border-radius:10px; padding:16px; background:${locked ? '#2a2a3e' : (betPlaced ? '#3a3a2e' : '#252538')}; transition:all 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
          <div style="font-weight:600; font-size:15px; color:#fff;">${m.home} <span style="opacity:0.5;">vs</span> ${m.away}</div>
          ${statusBadge}
        </div>
        <div style="font-size:12px; opacity:0.6; margin-bottom:12px;">⏰ ${timeStr}</div>
        <div id="bet-confirm-${m.id}" style="font-size:13px; margin-bottom:8px; font-weight:600; color:#28a745; ${betPlaced ? '' : 'display:none;'}">✅ Wette eingereicht</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <input type="number" min="5" max="${userCoins}" placeholder="🪙" value="${stakeValue}" id="stake-${m.id}" style="width:40px; padding:8px; background:#1a1a2e; border:1px solid #444; border-radius:6px; color:#fff; text-align:center; font-weight:600; font-size:14px;" ${inputsDisabled ? 'disabled' : ''} />
          <input type="text" placeholder="Tipp (z.B. 2:1)" value="${scoreValue}" id="score-${m.id}" style="flex:1; padding:10px; background:#1a1a2e; border:1px solid #444; border-radius:6px; color:#fff; text-align:center; font-size:14px;" ${inputsDisabled ? 'disabled' : ''} />
        </div>
        <button type="button" id="bet-btn-${m.id}" onclick="window.placeBet('${league}','${m.id}')" ${inputsDisabled ? 'disabled' : ''} style="width:100%; margin-top:12px; padding:12px; background:${inputsDisabled ? '#555' : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'}; color:#fff; border:none; border-radius:8px; cursor:${inputsDisabled ? 'not-allowed' : 'pointer'}; font-weight:600; font-size:14px; transition:all 0.2s; box-shadow:${inputsDisabled ? 'none' : '0 4px 12px rgba(102,126,234,0.4)'};">${betPlaced ? '✅ Wette eingereicht' : (locked ? '🔒 Wetten gesperrt' : '💰 Wette platzieren')}</button>
      </div>
    `;
  });
  list.innerHTML = html;

  // Ensure click handlers are bound even if inline onclick is ignored
  try {
    fixtures.forEach(m => {
      const btn = document.getElementById(`bet-btn-${m.id}`);
      if (btn && !btn.hasAttribute('data-bound')) {
        btn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          if (window.placeBet) {
            window.placeBet(league, m.id);
          } else {
            console.warn('placeBet not available on window');
          }
        });
        btn.setAttribute('data-bound','1');
      }
    });
  } catch(e) { console.error('bind bet buttons failed', e); }

  // Fallback: event delegation on the list container (supports both id styles)
  try {
    const container = document.getElementById('fixturesList');
    if (container && !container.getAttribute('data-delegate')) {
      container.addEventListener('click', (e) => {
        // New renderer buttons: bet-btn-<id>
        let btn = e.target && e.target.closest && e.target.closest('button[id^="bet-btn-"]');
        if (!btn) {
          // Legacy/live wrapper buttons: betbtn_<id>
          btn = e.target && e.target.closest && e.target.closest('button[id^="betbtn_"]');
        }
        if (btn && !btn.disabled) {
          const id = btn.id.startsWith('bet-btn-') ? btn.id.replace('bet-btn-','') : btn.id.replace('betbtn_','');
          if (window.placeBet) {
            console.debug('Delegated click → placeBet', league, id);
            window.placeBet(league, id);
          } else {
            console.warn('placeBet not on window at click time');
          }
        }
      });
      container.setAttribute('data-delegate','1');
    }
  } catch(e) { console.error('delegate bind failed', e); }
}

// Persistiere Wetten unter footballBets/{uid}/bets
      <!-- Matchday Live Fixtures Enhancer removed for compatibility; will re-add after testing -->

async function placeBet(league, matchId) {
  console.log('placeBet called:', league, matchId);
  const feedbackEl = document.getElementById('betFeedback');
  const uid = getCurrentUid();
  const safeNotify = (title, msg) => { try { if (window.showNotification) window.showNotification(title, msg); } catch(_) {} };
  
  if (!uid) { 
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#e74c3c;">❌ Bitte einloggen.</span>'; 
    safeNotify('Fehler', 'Bitte melde dich an.');
    return; 
  }
  
  const fixtures = MATCHDAY_FIXTURES[league] || [];
  let match = fixtures.find(f => f.id === matchId);
  if (!match) {
    const liveMap = (window.__liveFixtures && window.__liveFixtures[league]) ? window.__liveFixtures[league] : null;
    if (liveMap) {
      match = liveMap[String(matchId)] || liveMap[matchId];
    }
  }
  
  if (!match) {
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#e74c3c;">❌ Spiel nicht gefunden.</span>';
    return;
  }
  
  if (Date.now() >= match.kickoff) { 
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#e74c3c;">🔒 Wetten gesperrt.</span>'; 
    safeNotify('Fehler', 'Wetten nach Anpfiff gesperrt.');
    return; 
  }

  // Support both renderers: new (stake-<id>, score-<id>) and legacy/live (stake_<id>, home_<id> + away_<id>)
  let stakeEl = document.getElementById(`stake-${matchId}`) || document.getElementById(`stake_${matchId}`);
  let scoreEl = document.getElementById(`score-${matchId}`);
  let legacyHomeEl = null, legacyAwayEl = null;
  if (!scoreEl) {
    legacyHomeEl = document.getElementById(`home_${matchId}`);
    legacyAwayEl = document.getElementById(`away_${matchId}`);
  }
  
  if (!stakeEl || (!scoreEl && !(legacyHomeEl && legacyAwayEl))) {
    console.error('Input elements not found:', matchId, { hasStake: !!stakeEl, hasScore: !!scoreEl, hasLegacy: !!legacyHomeEl && !!legacyAwayEl });
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#e74c3c;">❌ Eingabefelder nicht gefunden.</span>';
    return;
  }
  
  const stake = parseInt(stakeEl.value || '0', 10);
  let scorePred = '';
  if (scoreEl) {
    scorePred = (scoreEl.value || '').trim();
  } else if (legacyHomeEl && legacyAwayEl) {
    const hVal = legacyHomeEl.value != null ? String(legacyHomeEl.value) : '';
    const aVal = legacyAwayEl.value != null ? String(legacyAwayEl.value) : '';
    scorePred = `${hVal}:${aVal}`;
  }

  if (!stake || stake < 5) { 
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#ffa500;">⚠️ Mindest-Einsatz: 5 Münzen.</span>'; 
    safeNotify('Fehler', 'Mindest-Einsatz ist 5 Münzen!');
    return; 
  }
  
  if (!scorePred || !scorePred.includes(':')) { 
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#ffa500;">⚠️ Bitte Ergebnis-Tipp angeben (z.B. 2:1).</span>'; 
    safeNotify('Fehler', 'Bitte gib einen Ergebnis-Tipp ein (z.B. 2:1)!');
    return; 
  }
  
  // Calculate tendency from score prediction
  const scoreParts = scorePred.split(':');
  if (scoreParts.length !== 2) {
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#ffa500;">⚠️ Ungültiges Format! Nutze z.B. 2:1.</span>';
    safeNotify('Fehler', 'Ungültiges Format! Nutze z.B. 2:1');
    return;
  }
  
  const homeGoals = parseInt(scoreParts[0]);
  const awayGoals = parseInt(scoreParts[1]);
  
  if (isNaN(homeGoals) || isNaN(awayGoals) || homeGoals < 0 || awayGoals < 0) {
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#ffa500;">⚠️ Bitte gültige Zahlen eingeben!</span>';
    safeNotify('Fehler', 'Bitte gültige Zahlen eingeben!');
    return;
  }
  
  let tendency = 'X';
  if (homeGoals > awayGoals) tendency = '1';
  else if (homeGoals < awayGoals) tendency = '2';

  // Check if user has enough coins
  const userCoins = window.getUserCoins ? window.getUserCoins() : 0;
  if (stake > userCoins) { 
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#e74c3c;">❌ Nicht genug Münzen!</span>'; 
    safeNotify('Fehler', `Du hast nur ${userCoins} Münzen!`);
    return; 
  }

  try {
    console.log('Placing bet...');
    const betsCol = collection(__getDb(), 'footballBets', uid, 'bets');
    const betRef = doc(betsCol);
    
    await setDoc(betRef, {
      betId: betRef.id,
      uid,
      league,
      matchId,
      homeTeam: match.home || match.homeTeam || '',
      awayTeam: match.away || match.awayTeam || '',
      stake,
      tendency,
      scorePred,
      createdAt: serverTimestamp(),
      kickoff: match.kickoff,
      status: 'pending'
    });

    console.log('Bet placed successfully, deducting coins...');
    
    // Deduct coins after successful bet placement
    if (window.addCoins) {
      await window.addCoins(-stake);
    } else {
      console.error('addCoins function not found');
    }

    // Optimistic UI lock on this specific card (new renderer)
    try {
      const stakeEl = document.getElementById(`stake-${matchId}`);
      const scoreEl = document.getElementById(`score-${matchId}`);
      const btnEl = document.getElementById(`bet-btn-${matchId}`);
      const confirmEl = document.getElementById(`bet-confirm-${matchId}`);
      const cardEl = document.getElementById(`match-card-${matchId}`);
      if (stakeEl) { stakeEl.setAttribute('disabled', 'disabled'); }
      if (scoreEl) { scoreEl.setAttribute('disabled', 'disabled'); }
      if (btnEl) { btnEl.setAttribute('disabled','disabled'); btnEl.textContent = '✅ Wette eingereicht'; }
      if (confirmEl) { confirmEl.style.display = ''; }
      if (cardEl) { cardEl.style.border = '1px solid #ffa500'; cardEl.style.background = '#3a3a2e'; }
      if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#28a745; font-weight:600;">✅ Wette eingereicht</span>';
    } catch(_) {}
    // Legacy/live row lock (stake_/home_/away_/betbtn_)
    try {
      const lStake = document.getElementById(`stake_${matchId}`);
      const lHome = document.getElementById(`home_${matchId}`);
      const lAway = document.getElementById(`away_${matchId}`);
      const lBtn = document.getElementById(`betbtn_${matchId}`);
      if (lStake) lStake.setAttribute('disabled','disabled');
      if (lHome) lHome.setAttribute('disabled','disabled');
      if (lAway) lAway.setAttribute('disabled','disabled');
      if (lBtn) { lBtn.setAttribute('disabled','disabled'); lBtn.textContent = '✅ Wette eingereicht'; }
    } catch(_) {}
    safeNotify('Erfolg', `✅ Wette platziert! ${stake} 🪙 abgezogen.`);
    
    // Reload display to show bet as placed
    setTimeout(() => {
      loadMatchday();
    }, 1000);
  } catch (e) {
    console.error('Bet error:', e);
    if (feedbackEl) feedbackEl.innerHTML = '<span style="color:#e74c3c;">❌ Wette konnte nicht platziert werden.</span>';
    safeNotify('Fehler', 'Wette konnte nicht platziert werden: ' + e.message);
  }
}

// Live Lock: minütlich aktualisieren
function refreshMatchLocks() { loadMatchday(); }
setInterval(refreshMatchLocks, 60000);

// Admin: Ergebnisse setzen und auszahlen (Donnerstag ausführen)
async function adminSetResult(league, matchId, finalHomeGoals, finalAwayGoals) {
  const uid = getCurrentUid();
  if (!uid) return;
  const tendencyFinal = finalHomeGoals === finalAwayGoals ? 'X' : (finalHomeGoals > finalAwayGoals ? '1' : '2');
  const finalScoreStr = `${finalHomeGoals}:${finalAwayGoals}`;

  const betsSnap = await getDocs(query(collection(__getDb(), 'footballBets', uid, 'bets')));
  const updates = [];
  betsSnap.forEach(docSnap => {
    const b = docSnap.data();
    if (b.league === league && b.matchId === matchId && b.status === 'pending') {
      let payout = 0;
      if (b.scorePred && b.scorePred.trim() === finalScoreStr) {
        payout = b.stake * 3;
      } else if (b.tendency && b.tendency === tendencyFinal) {
        payout = b.stake * 2;
      }
      updates.push({ id: docSnap.id, payout });
    }
  });

  for (const u of updates) {
    await updateDoc(doc(__getDb(), 'footballBets', uid, 'bets', u.id), {
      status: 'settled',
      settledAt: serverTimestamp(),
      finalScore: finalScoreStr,
      payout: u.payout
    });
    if (u.payout > 0) await addCoinsSimple(u.payout);
  }
}

// Expose functions globally for inline handlers
window.adminSetResult = adminSetResult;
window.loadMatchday = loadMatchday;
window.placeBet = placeBet;
window.refreshMatchLocks = refreshMatchLocks;

// Initialisieren
document.addEventListener('DOMContentLoaded', () => {
  const leagueSelect = document.getElementById('leagueSelect');
  if (leagueSelect) {
    // Ensure default league selected and change binds
    leagueSelect.value = leagueSelect.value || 'EPL';
    leagueSelect.addEventListener('change', loadMatchday);
  }
  // Wire refresh button to re-render locks and fixtures
  const refreshBtn = document.getElementById('refreshLocksBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', () => {
      // Trigger a fresh render
      loadMatchday();
    });
  }
  // Hard init render once DOM is ready
  loadMatchday();
});
</script>

<!-- Global click rescue for Wetten buttons (works across all renderers) -->
<script>
// Last-resort click handler in capture phase to ensure responsiveness
(function(){
  function extractMatchContext(btn){
    // Try id patterns first
    if (btn.id && btn.id.indexOf('betbtn_')===0) return { id: btn.id.slice('betbtn_'.length) };
    if (btn.id && btn.id.indexOf('bet-btn-')===0) return { id: btn.id.slice('bet-btn-'.length) };
    // Fallback: search nearby stake/home inputs to infer id
    const host = btn.closest && btn.closest('#fixturesList, .fixture-row, [id^="match-card-"]') || document;
    let stake = host.querySelector('input[id^="stake_"]') || host.querySelector('input[id^="stake-"]');
    if (stake && stake.id){
      const sid = stake.id.replace(/^stake[-_]/,'');
      return { id: sid };
    }
    return { id: null };
  }
  function currentLeague(){
    const sel = document.getElementById('leagueSelect');
    return (sel && sel.value) ? sel.value : 'EPL';
  }
  document.addEventListener('click', function(e){
    const btn = e.target && e.target.closest && e.target.closest('button');
    if (!btn) return;
    const label = (btn.textContent || '').trim().toLowerCase();
    const isBet = btn.id.startsWith('betbtn_') || btn.id.startsWith('bet-btn-') || label === 'wetten' || label.includes('wette');
    if (!isBet) return;
    if (btn.disabled) return;
    const ctx = extractMatchContext(btn);
    if (!ctx.id) return;
    const lg = currentLeague();
    try {
      if (window.placeBet) {
        console.debug('[global-capture] click → placeBet', lg, ctx.id);
        window.placeBet(lg, ctx.id);
        e.preventDefault();
        e.stopPropagation();
      }
    } catch(err){ console.error('global-capture placeBet error', err); }
  }, true);
})();
</script>

<!-- Datum ist nun in der Navigationsleiste platziert -->

<!-- Navigation -->
<nav>
  <a href="#pdfs" data-i18n="nav_pdfs">PDFs</a>
  <a href="#games" data-i18n="nav_games">Spiele</a>
  <a href="#news" data-i18n="nav_news">News</a>
  <a href="#chat" data-i18n="nav_chat">Live-Chat</a>
  <a href="#shop" data-i18n="nav_shop">🛍️ Shop</a>
  <a href="#inventar" data-i18n="nav_inventory">🎒 Inventar</a>
  <a href="#battlepass" data-i18n="nav_battlepass">🏆 Battle Pass</a>

  <div class="nav-spacer"></div>

  <span id="navUserInfo" data-i18n="nav_not_logged_in">Nicht eingeloggt</span>
  <span id="coinDisplay" style="font-size:16px; font-weight:bold; margin-right:15px; display:none;">
    🪙 <span id="coinCount">0</span>
  </span>
  <button class="nav-auth-btn" id="loginBtn" onclick="openAuthModal('login')" data-i18n="nav_login">Login</button>
  <button class="nav-auth-btn" id="registerBtn" onclick="openAuthModal('register')" data-i18n="nav_register">Registrieren</button>
  <button class="nav-auth-btn" id="accountBtn" onclick="openAccountSettings()" style="display:none;" data-i18n="nav_account">Mein Konto</button>
  <button class="nav-auth-btn" id="friendsBtn" onclick="openFriends()" style="display:none; position:relative;" data-i18n="nav_friends">
    Freunde
    <span id="friendsNotificationBadge" style="display:none; position:absolute; top:-5px; right:-5px; width:12px; height:12px; background:red; border-radius:50%; border:2px solid white;"></span>
  </button>
  <button class="nav-auth-btn" id="settingsBtn" onclick="openSettings()" style="display:none;" data-i18n="nav_settings">Einstellungen</button>
  <button class="nav-auth-btn" id="adventBtn" onclick="openAdvent()" style="margin-left:8px; background:#ffca28; color:#111;">Adventskalender 🎁</button>

  <span class="date-box" id="dateBox"></span>
</nav>

<!-- Notification Modal (statt alert) -->
<div id="notificationModal" class="auth-modal">
  <div class="auth-modal-content" style="max-width:400px;">
    <span class="auth-close" onclick="closeNotification()">&times;</span>
    <h2 id="notifTitle">Benachrichtigung</h2>
    <p id="notifMessage"></p>
    <button onclick="closeNotification()" style="width:100%;">OK</button>
  </div>
</div>

<!-- Advent Calendar Modal -->
<div id="adventModal" class="auth-modal" style="display:none;">
  <div class="auth-modal-content" style="max-width:640px;">
    <span class="auth-close" onclick="closeAdvent()">&times;</span>
    <h2>🎁 Adventskalender</h2>
    <p id="adventStreakInfo" style="margin-top:4px; opacity:0.8;">Streak: 0 Tage</p>
    <div id="adventGrid" style="display:grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-top:10px;"></div>
    <div style="margin-top:12px; display:flex; gap:8px;">
      <button onclick="claimTodayAdvent()" id="adventClaimBtn">Heutige Belohnung claimen</button>
      <button onclick="closeAdvent()">Schließen</button>
    </div>
  </div>
  
  <!-- Removed duplicate Top Spiele section previously injected into Advent modal -->

</div>

<!-- Smart Notifications Feed (panel) -->
<div id="notificationsFeed" style="position: fixed; right: 10px; top: 90px; width: 280px; max-height: 60vh; overflow-y: auto; background: rgba(0,0,0,0.6); color: #fff; border-radius: 8px; padding: 10px; z-index: 9999; display:none;">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <strong>🔔 Benachrichtigungen</strong>
    <button onclick="toggleNotificationsFeed()" style="padding:4px 8px; font-size:11px;">Schließen</button>
  </div>
  <div id="notificationsList" style="margin-top:8px;"></div>
</div>

<!-- Quest Completion Popup Container -->
<div id="questPopupContainer"></div>

<!-- USER SYSTEM als POPUP -->
<div id="authModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeAuthModal()">&times;</span>
    <h1>Benutzerkonto</h1>

    <div class="card">
      <h2>Registrieren</h2>
      <input id="regEmail" type="email" placeholder="E-Mail" autocomplete="off">
      <input id="regPass" type="password" placeholder="Passwort" autocomplete="new-password">
      <input id="regNick" type="text" placeholder="Nickname (einzigartig)" autocomplete="off">
      <button onclick="register()">Konto erstellen</button>
    </div>

    <div class="card">
      <h2>Login</h2>
      <input id="logEmail" type="email" placeholder="E-Mail" autocomplete="username">
      <input id="logPass" type="password" placeholder="Passwort" autocomplete="current-password">
      <button onclick="login()">Login</button>
      <button onclick="logout()">Logout</button>
      <p id="userState"></p>
      <div id="loginError" style="color: #ff3333; margin-top: 10px; font-weight: 600; display: none;"></div>
      <a href="#" onclick="resetPassword(); return false;" style="display: block; margin-top: 15px; text-align: center; color: #007bff; font-size: 14px; text-decoration: none;">Passwort vergessen?</a>
    </div>
  </div>
</div>

<!-- Email Verification Modal entfernt -->

<!-- Account Settings Modal -->
<div id="accountSettingsModal" class="auth-modal">
  <div class="auth-modal-content" style="max-width:500px;">
    <span class="auth-close" onclick="closeAccountSettings()">&times;</span>
    <h2>⚙️ Mein Konto</h2>
    
    <!-- Profilbild -->
    <div style="text-align:center; margin-bottom:20px;">
      <img id="accountProfilePic" src="" style="width:100px; height:100px; border-radius:50%; object-fit:cover; border:3px solid #007bff;">
      <div style="margin-top:10px;">
        <input type="file" id="profilePicInput" accept="image/*" style="display:none;" onchange="previewProfilePic()">
        <button onclick="document.getElementById('profilePicInput').click()" style="width:100%;">Profilbild ändern</button>
      </div>
      
      <!-- Vorschau für neues Profilbild mit Editor -->
      <div id="profilePicPreview" style="display:none; margin-top:15px; padding:15px; background:#f0f0f0; border-radius:8px;">
        <p style="margin:0 0 10px 0; font-weight:bold;">Bild zuschneiden:</p>
        
        <!-- Canvas Editor -->
        <div style="position:relative; width:300px; height:300px; margin:0 auto; background:#000; border-radius:8px; overflow:hidden; cursor:move;" id="imageEditorContainer">
          <canvas id="profileCanvas" width="300" height="300" style="display:block;"></canvas>
        </div>
        
        <!-- Zoom & Pan Controls -->
        <div style="margin:15px 0; display:flex; align-items:center; gap:10px; justify-content:center;">
          <button onclick="zoomProfileImage(-0.1)" style="width:40px; padding:8px; background:#007bff; color:white; font-size:18px;">−</button>
          <input type="range" id="zoomSlider" min="100" max="300" value="100" step="5" style="flex:1; max-width:200px;" oninput="setProfileZoom(this.value)">
          <button onclick="zoomProfileImage(0.1)" style="width:40px; padding:8px; background:#007bff; color:white; font-size:18px;">+</button>
        </div>
        
        <p style="font-size:12px; color:#666; margin:10px 0; text-align:center;">💡 Ziehe das Bild, um es zu verschieben</p>
        
        <!-- Preview Circle -->
        <div style="text-align:center; margin:15px 0;">
          <p style="margin:0 0 8px 0; font-weight:bold; font-size:14px;">Vorschau:</p>
          <img id="previewImage" src="" style="width:100px; height:100px; border-radius:50%; object-fit:cover; border:3px solid #28a745;">
        </div>
        
        <div style="margin-top:15px; display:flex; gap:10px;">
          <button onclick="confirmProfilePic()" style="flex:1; background:#28a745; color:white;">✓ Bestätigen</button>
          <button onclick="cancelProfilePic()" style="flex:1; background:#dc3545; color:white;">✗ Verwerfen</button>
        </div>
      </div>
    </div>
    
    <div class="card">
      <h3>Nickname ändern</h3>
      <input id="newNickname" type="text" placeholder="Neuer Nickname">
      <p id="nicknameCostInfo" style="font-size:12px; color:#666; margin:5px 0;">✨ Erste Änderung kostenlos!</p>
      <button onclick="updateNickname()">Speichern</button>
    </div>
    
    <div class="card">
      <h3>Email ändern</h3>
      <input id="newEmail" type="email" placeholder="Neue Email">
      <button onclick="updateEmail()">Speichern</button>
    </div>
    
    <div class="card">
      <h3>Passwort ändern</h3>
      <input id="currentPassword" type="password" placeholder="Aktuelles Passwort">
      <input id="newPassword" type="password" placeholder="Neues Passwort">
      <input id="confirmPassword" type="password" placeholder="Passwort bestätigen">
      <button onclick="updatePassword()">Speichern</button>
    </div>
    
    <div class="card">
      <h3>Statistiken</h3>
      <p style="margin:5px 0;"><strong>Beigetreten am:</strong> <span id="accountJoinDate">-</span></p>
      <p style="margin:5px 0;"><strong>Chatnachrichten gesendet:</strong> <span id="accountChatMessages">-</span></p>
      <p style="margin:5px 0;"><strong>Lieblingsspiel:</strong> <span id="accountFavoriteGame">-</span></p>
      <p style="margin:5px 0;"><strong>Höchster Slot-Gewinn:</strong> <span id="accountSlotHighWin">-</span> 🪙</p>
    </div>
    
    <div class="card" style="border:2px solid #dc3545; background:#fff5f5;">
      <h3 style="color:#dc3545;">⚠️ Konto löschen</h3>
      <p style="font-size:14px; color:#666; margin-bottom:10px;">Diese Aktion kann nicht rückgängig gemacht werden. Dein Username und Email werden wieder zur Verfügung stehen.</p>
      <input id="deleteAccountPassword" type="password" placeholder="Passwort zur Bestätigung">
      <button onclick="deleteAccount()" style="width:100%; background:#dc3545; color:white; margin-top:10px;">Konto unwiderruflich löschen</button>
    </div>
    
    <button onclick="logout()" style="width:100%; background:#dc3545; margin-top:20px;">Ausloggen</button>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="auth-modal">
  <div class="auth-modal-content" style="max-width:500px;">
    <span class="auth-close" onclick="closeSettings()">&times;</span>
    <h2 data-i18n="settings_title">⚙️ Einstellungen</h2>
    
    <div class="card">
      <h3 data-i18n="settings_language_title">🌐 Sprache / Language</h3>
      <p style="font-size:13px; color:#666; margin-bottom:10px;">⚠️ Hinweis: Die Übersetzung ist noch nicht vollständig. Einige Texte erscheinen weiterhin auf Deutsch.<br>
      ⚠️ Note: Translation is not yet complete. Some texts will still appear in German.</p>
      <select id="languageSelect" onchange="previewLanguage(this.value)" style="width:100%; padding:10px; font-size:16px; border-radius:5px; border:1px solid #ddd;">
        <option value="de">🇩🇪 Deutsch</option>
        <option value="en">🇬🇧 English</option>
        <option value="es">🇪🇸 Español</option>
        <option value="ru">🇷🇺 Русский</option>
        <option value="fr">🇫🇷 Français</option>
        <option value="it">🇮🇹 Italiano</option>
      </select>
      <div style="display:flex; gap:10px; margin-top:10px;">
        <button id="langAllowBtn" type="button" onclick="confirmLanguageAllow()" style="flex:1; background:#10b981;">Zulassen</button>
        <button id="langDenyBtn" type="button" onclick="denyLanguage()" style="flex:1; background:#ef4444;">Ablehnen</button>
      </div>
    </div>
    
    <div class="card" style="margin-top:15px;">
      <h3>🎵 Hintergrundmusik</h3>
      <p style="font-size:13px; color:#666; margin-bottom:10px;">Hintergrundmusik auf der gesamten Seite</p>
      <div style="display:flex; flex-direction:column; gap:10px;">
        <label style="display:flex; align-items:center; gap:10px;">
          <span style="min-width:80px;">Lautstärke:</span>
          <input type="range" id="musicVolumeSlider" min="0" max="100" value="50" oninput="updateMusicVolume(this.value)" style="flex:1; cursor:pointer;">
          <span id="musicVolumeLabel" style="min-width:35px; text-align:right;">50%</span>
        </label>
      </div>
    </div>
    
    <button onclick="closeSettings()" style="width:100%; margin-top:20px;" data-i18n="close">Schließen</button>
  </div>
</div>

<!-- Friends Modal -->
<div id="friendsModal" class="auth-modal">
  <div class="auth-modal-content" style="max-width:600px;">
    <span class="auth-close" onclick="closeFriends()">&times;</span>
    <h2>👥 Freunde</h2>
    
    <!-- Suche -->
    <div class="card">
      <h3>🔍 Freund suchen</h3>
      <input id="friendSearchInput" type="text" placeholder="Nickname eingeben...">
      <button onclick="searchFriend()" style="width:100%; margin-top:10px;">Suchen</button>
      <div id="friendSearchResults" style="margin-top:15px;"></div>
    </div>
    
    <!-- Eingehende Freundesanfragen -->
    <div class="card">
      <h3>📥 Eingehende Freundesanfragen</h3>
      <div id="friendRequestsList"></div>
    </div>
    
    <!-- Freundesliste -->
    <div class="card">
      <h3>✅ Meine Freunde</h3>
      <div id="friendsList"></div>
    </div>
    
    <button onclick="closeFriends()" style="width:100%; margin-top:20px;">Schließen</button>
  </div>
</div>

<!-- Private Chat Modal -->
<div id="privateChatModal" class="auth-modal">
  <div class="auth-modal-content" style="max-width:500px; max-height:80vh;">
    <span class="auth-close" onclick="closePrivateChat()">&times;</span>
    <h2 id="privateChatTitle">💬 Privat Chat</h2>
    
    <div class="chat-box" id="privateChatBox" style="height:400px; overflow-y:auto; background:#fff; padding:15px; border:1px solid #ddd; border-radius:8px; margin-bottom:15px;">
    </div>
    
    <div style="display:flex; gap:10px;">
      <input id="privateChatInput" type="text" placeholder="Nachricht schreiben..." style="flex:1;" onkeypress="if(event.key==='Enter') sendPrivateMessage()">
      <button onclick="sendPrivateMessage()" style="padding:10px 20px;">Senden</button>
    </div>
    <div style="display:flex; gap:10px; margin-top:10px;">
      <input id="privateGifInput" type="text" placeholder="GIF URL (optional)" style="flex:1;" onkeypress="if(event.key==='Enter') sendPrivateMessage()">
      <button onclick="sendPrivateMessage()" style="padding:10px 20px; background:#28a745; color:#fff;">GIF senden</button>
    </div>
    
    <button onclick="closePrivateChat()" style="width:100%; margin-top:15px; background:#6c757d;">Schließen</button>
  </div>
</div>

<!-- User Profile Modal -->
<div id="userProfileModal" class="modal">
  <div class="modal-content" style="max-width:400px;">
    <span class="close" onclick="closeUserProfile()">&times;</span>
    <h2>Spielerprofil</h2>
    
    <div style="text-align:center; margin:20px 0;">
      <img id="profileModalPic" src="" style="width:100px; height:100px; border-radius:50%; object-fit:cover; border:3px solid #007bff;">
      <div style="display:flex; align-items:center; justify-content:center; gap:8px; margin:10px 0;">
        <h3 id="profileModalNickname" style="margin:0;">-</h3>
        <span id="profileModalBadge" style="font-size:20px;"></span>
      </div>
      <div id="profileModalStatus" style="font-size:12px; color:#6c757d; display:flex; align-items:center; gap:6px; justify-content:center;">-</div>
    </div>
    
    <div class="card">
      <h3>Statistiken</h3>
      <p style="margin:5px 0;"><strong>Beigetreten am:</strong> <span id="profileModalJoinDate">-</span></p>
      <p style="margin:5px 0;"><strong>Chatnachrichten:</strong> <span id="profileModalChatMessages">-</span></p>
      <p style="margin:5px 0;"><strong>Snake Highscore:</strong> <span id="profileModalSnakeScore">-</span></p>
      <p style="margin:5px 0;"><strong>Tower Stack Highscore:</strong> <span id="profileModalTowerScore">-</span></p>
      <p style="margin:5px 0;"><strong>TicTacToe Siege:</strong> <span id="profileModalTTTWins">-</span></p>
      <p style="margin:5px 0;"><strong>Sudoku Siege:</strong> <span id="profileModalSudokuWins">-</span></p>
      <p style="margin:5px 0;"><strong>Penalty Tore:</strong> <span id="profileModalPenaltyGoals">-</span></p>
      <p style="margin:5px 0;"><strong>Schach Siege:</strong> <span id="profileModalChessWins">-</span></p>
      <p style="margin:5px 0;"><strong>Lieblingsspiel:</strong> <span id="profileModalFavoriteGame">-</span></p>
      <p style="margin:5px 0;"><strong>Höchster Slot-Gewinn:</strong> <span id="profileModalSlotHighWin">-</span> 🪙</p>
    </div>
    
    <div id="profileModalActions" style="display:flex; gap:10px; margin-top:15px;">
      <button id="addFriendBtn" onclick="sendFriendRequestFromProfile()" style="flex:1; background:#28a745;">👤 Freund hinzufügen</button>
      <button id="privateChatBtn" onclick="openPrivateChatFromProfile()" style="flex:1; background:#007bff;">💬 Privat chatten</button>
    </div>
    
    <button onclick="closeUserProfile()" style="width:100%; margin-top:10px;">Schließen</button>
  </div>
</div>

<!-- PDFs -->
<div id="pdfs" class="section">
  <h1 data-i18n="section_pdfs">Formulare / PDFs</h1>

  <div class="card">
    <h3>Hochgeladene Dateien</h3>
    <div id="pdfList">Wird geladen...</div>
  </div>


<!-- Spiele -->
<div id="games" class="section">
  <h1 data-i18n="section_games">🎮 Spiele</h1>
  
  <!-- Suchleiste -->
  <div style="margin-bottom: 15px;">
    <input type="text" id="gameSearchInput" placeholder="🔍 Spiele suchen..." 
           oninput="filterGames()" 
           style="width:100%; padding:10px; border-radius:8px; border:1px solid #ccc; font-size:16px;">
  </div>
  
  <!-- Scroll-Buttons -->
  <div style="margin-bottom: 15px;">
    <button class="scroll-button" onclick="scrollGames('left')" data-i18n="games_scroll_back">◀ Zurück</button>
    <button class="scroll-button" onclick="scrollGames('right')" data-i18n="games_scroll_next">Weiter ▶</button>
  </div>

  <!-- Horizontal Scroller Container -->
  <div class="game-container" id="gamesContainer">


    <!-- TicTacToe KI -->
    <div class="card game-item">
      <h3>⭕❌Tic Tac Toe vs KI</h3>
      
      <!-- Schwierigkeitsauswahl -->
      <div style="margin-bottom:10px;">
        <label>Schwierigkeit:</label>
        <select id="tttDifficulty" style="width:100%; padding:5px; margin-top:5px;">
          <option value="noob">Noob (🪙 3 Münzen)</option>
          <option value="profi" selected>Profi (🪙 5 Münzen)</option>
          <option value="champion">Champion (🪙 10 Münzen)</option>
        </select>
      </div>
      
      <p>Gegner: <strong id="tttOpponent">KI</strong></p>
      <p id="tttCurrentPlayer" style="padding:10px; border-radius:5px; font-weight:bold; text-align:center;">
        Du bist X
      </p>
      <div id="tttBoard" style="display:grid;grid-template-columns:repeat(3,1fr);gap:5px;"></div>
      <p id="tttStatus" style="text-align:center; font-weight:bold;">Klick "Neues Spiel"</p>
      <button onclick="startTTTvsAI()" style="width:100%; margin:5px 0;">Neues Spiel</button>
      <button onclick="resetTTTAI()" style="width:100%; margin:5px 0;">Zurücksetzen</button>
      <button onclick="openTTTRanking()" style="width:100%;">🏆 Rangliste</button>
    </div>

    <!-- Snake -->
    <div class="card game-item">
      <h3>🐍Snake</h3>
      <canvas id="snakeCanvas" width="320" height="320"></canvas><br>
      <button onclick="startSnake()" style="width:100%; margin:5px 0;">Start</button>
      <button onclick="pauseSnake()" style="width:100%; margin:5px 0;">Pause</button>
      <button onclick="resetSnake()" style="width:100%; margin:5px 0;">Neu</button>
      <button onclick="openSnakeRanking()" style="width:100%;">Rangliste</button>

      <!-- Score-Anzeige -->
      <div style="margin-top:8px; font-size:12px;">
        <span>Score: <strong id="snakeScore">0</strong></span> | 
        <span>High: <strong id="snakeHighLocal">0</strong></span>
      </div>

      <p style="font-size:12px;">Steuerung: W A S D</p>
    </div>

    <!-- Flappy Bird -->
    <div class="card game-item">
      <h3>🐦Flappy Bird</h3>
      <canvas id="flappyCanvas" width="320" height="400"></canvas><br>
      <button onclick="startFlappy()" style="width:100%; margin:5px 0;">Start</button>
      <button onclick="resetFlappy()" style="width:100%; margin:5px 0;">Neu</button>
      <button onclick="openFlappyRanking()" style="width:100%;">🏆 Rangliste</button>
      
      <!-- Score-Anzeige -->
      <div style="margin-top:8px; font-size:12px;">
        <span>Score: <strong id="flappyScore">0</strong></span> | 
        <span>High: <strong id="flappyHigh">0</strong></span>
      </div>

      <p style="font-size:12px;">Steuerung: Space oder Klick</p>
    </div>

    <!-- Dino Game -->
    <div class="card game-item">
      <h3>🦖 Dino Run</h3>
      <div style="width:100%; overflow:hidden; border-radius:8px; border:2px solid #ccc; background:#f7f7f7;">
        <canvas id="dinoCanvas" width="600" height="300" style="display:block; width:100%; height:auto;"></canvas>
      </div>
      <button onclick="startDino()" style="width:100%; margin:5px 0;">Start</button>
      <button onclick="resetDino()" style="width:100%; margin:5px 0;">Neu</button>
      <button onclick="openDinoRanking()" style="width:100%;">🏆 Rangliste</button>
      
      <!-- Score-Anzeige -->
      <div style="margin-top:8px; font-size:12px;">
        <span>Score: <strong id="dinoScore">0</strong></span> | 
        <span>High: <strong id="dinoHigh">0</strong></span>
      </div>

      <p style="font-size:12px;">Steuerung: Space oder Klick zum Springen</p>
    </div>

    <!-- Slot Machine -->
    <div class="card game-item">
      <h3>🎰 Slot Machine</h3>
      
      <!-- Einsatz -->
      <div style="margin-bottom:10px;">
        <label>Einsatz (Münzen):</label>
        <input id="slotBet" type="number" min="1" value="10" style="width:100px;">
        <span style="margin-left:10px;">💰 Deine Münzen: <strong id="slotBalance">0</strong></span>
      </div>

      <!-- Slot Display (3x3 Grid) -->
      <div id="slotGrid" style="display:grid; grid-template-columns:repeat(3,80px); gap:10px; margin:15px 0; justify-content:center;">
        <div class="slot-box" id="slot0">🍒</div>
        <div class="slot-box" id="slot1">🍋</div>
        <div class="slot-box" id="slot2">🍉</div>
        <div class="slot-box" id="slot3">7️⃣</div>
        <div class="slot-box" id="slot4">🍒</div>
        <div class="slot-box" id="slot5">🍋</div>
        <div class="slot-box" id="slot6">🍉</div>
        <div class="slot-box" id="slot7">7️⃣</div>
        <div class="slot-box" id="slot8">🍒</div>
      </div>

      <!-- Gewinn-Info -->
      <p id="slotResult" style="text-align:center; font-weight:bold; min-height:20px;"></p>

      <!-- Buttons -->
      <button onclick="spinSlots()" id="slotSpinBtn" style="width:100%; margin:5px 0; padding:12px; font-size:16px;">SPIN! 🎯</button>
      <button onclick="resetSlots()" style="width:100%;">Neu</button>
    </div>

    <!-- Tower Stack -->
    <div class="card game-item">
      <h3>🏗️ Tower Stack</h3>
      <p style="font-size:12px;">Staple die Blöcke perfekt aufeinander!</p>
      
      <canvas id="towerCanvas" width="320" height="400"></canvas><br>
      <button onclick="startTowerStack()" style="width:100%; margin:5px 0;">Start</button>
      <button onclick="openTowerRanking()" style="width:100%; margin:5px 0;">🏆 Rangliste</button>
      
      <!-- Score-Anzeige -->
      <div style="margin-top:8px; font-size:12px;">
        <span>Score: <strong id="towerScore">0</strong></span> | 
        <span>Best: <strong id="towerBest">0</strong></span>
      </div>

      <p style="font-size:12px;">Steuerung: Space oder Klick zum Platzieren</p>
    </div>

    <!-- Wordle -->
    <div class="card game-item">
      <h3>📝 Wordle (Deutsch)</h3>
      
      <!-- Wortlänge auswählen -->
      <div style="margin-bottom:10px;">
        <label>Wortlänge:</label>
        <select id="wordleLength" onchange="startNewWordle()" style="width:100%; padding:5px; margin-top:5px;">
          <option value="4">4 Buchstaben (🪙 10 Münzen)</option>
          <option value="5" selected>5 Buchstaben (🪙 15 Münzen)</option>
          <option value="6">6 Buchstaben (🪙 20 Münzen)</option>
        </select>
      </div>

      <!-- Wordle Grid -->
      <div id="wordleGrid" style="margin:15px 0;">
        <!-- 5 Zeilen mit je 4-6 Feldern -->
      </div>

      <!-- Eingabefeld -->
      <input id="wordleInput" type="text" placeholder="Wort eingeben" maxlength="6" 
        style="width:100%; padding:10px; margin:10px 0; text-transform:uppercase; font-size:16px; text-align:center;"
        onkeydown="if(event.key==='Enter') submitWordleGuess()">
      
      <button onclick="submitWordleGuess()" style="width:100%; padding:12px; font-size:16px;">Raten 🎯</button>
      <button onclick="startNewWordle()" style="width:100%; margin-top:5px;">Neues Wort</button>
      
      <p id="wordleStatus" style="text-align:center; font-weight:bold; margin-top:10px; min-height:25px;"></p>
      
      <div style="margin-top:10px; font-size:12px; opacity:0.8;">
        <strong>Legende:</strong><br>
        🟩 = Richtiger Buchstabe an richtiger Stelle<br>
        🟨 = Buchstabe im Wort, aber falsche Stelle<br>
        ⬜ = Buchstabe nicht im Wort
      </div>
    </div>

    <!-- Wer wird Millionär -->
    <div class="card game-item">
      <h3>🏆 Wer wird Millionär?</h3>
      
      <!-- Aktueller Gewinn -->
      <div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:15px; text-align:center;">
        <div style="font-size:14px; opacity:0.8;">Aktueller Gewinn:</div>
        <div id="millionaireWinnings" style="font-size:28px; font-weight:bold; color:#FFD700;">0 🪙</div>
        <div style="font-size:12px; opacity:0.6; margin-top:5px;">Frage <span id="millionaireQuestionNum">0</span>/15</div>
      </div>

      <!-- Frage -->
      <div id="millionaireQuestion" style="background:#2a2a3e; padding:20px; border-radius:8px; margin-bottom:15px; min-height:100px;">
        <p style="font-size:18px; font-weight:bold; text-align:center; margin:0;">Klicke auf "Neues Spiel" um zu starten!</p>
      </div>

      <!-- Antworten (4 Buttons) -->
      <div id="millionaireAnswers" style="display:grid; grid-template-columns:1fr; gap:10px; margin-bottom:15px;">
        <!-- Buttons werden per JavaScript erstellt -->
      </div>

      <!-- Joker -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button id="joker5050" onclick="use5050Joker()" style="padding:10px; font-size:14px; background:#444;">50:50 ❌</button>
        <button id="jokerAudience" onclick="useAudienceJoker()" style="padding:10px; font-size:14px; background:#444;">Publikum 👥</button>
      </div>

      <!-- Buttons -->
      <button onclick="startMillionaire()" style="width:100%; padding:12px; font-size:16px; margin-bottom:5px;">Neues Spiel 🎮</button>
      <button onclick="cashOutMillionaire()" id="cashOutBtn" style="width:100%; padding:10px; display:none;">Gewinn mitnehmen 💰</button>
      
      <!-- Gewinnstufen -->
      <div style="margin-top:15px; font-size:11px; opacity:0.7; text-align:center;">
        <strong>🏆 15 Fragen Challenge! 🏆</strong><br>
        1️⃣1 2️⃣2 3️⃣5 4️⃣10 5️⃣15 6️⃣25 7️⃣40 8️⃣60<br>
        9️⃣90 🔟130 1️⃣1️⃣180 1️⃣2️⃣250 1️⃣3️⃣330 1️⃣4️⃣420 1️⃣5️⃣500
      </div>
    </div>

    <!-- Sudoku -->
    <div class="card game-item">
      <h3>🧩 Sudoku</h3>
      
      <!-- Schwierigkeitsauswahl -->
      <div style="margin-bottom:10px;">
        <label>Schwierigkeit:</label>
        <select id="sudokuDifficulty" style="width:100%; padding:5px; margin-top:5px;">
          <option value="noob">Noob - 40 Felder (🪙 20 Münzen)</option>
          <option value="profi" selected>Profi - 30 Felder (🪙 50 Münzen)</option>
          <option value="champion">Champion - 25 Felder (🪙 100 Münzen)</option>
        </select>
      </div>

      <!-- Sudoku Grid -->
      <div id="sudokuGrid" style="display:grid; grid-template-columns:repeat(9,1fr); gap:2px; margin:10px 0; background:#333; padding:2px; border-radius:5px;">
        <!-- 81 Felder werden per JavaScript generiert -->
      </div>

      <p id="sudokuStatus" style="text-align:center; font-weight:bold; min-height:25px;">Klick "Neues Spiel"</p>
      
      <!-- Zahlen-Buttons -->
      <div style="display:grid; grid-template-columns:repeat(5,1fr); gap:5px; margin:10px 0;">
        <button onclick="setSudokuNumber(1)" style="padding:10px; font-size:16px;">1</button>
        <button onclick="setSudokuNumber(2)" style="padding:10px; font-size:16px;">2</button>
        <button onclick="setSudokuNumber(3)" style="padding:10px; font-size:16px;">3</button>
        <button onclick="setSudokuNumber(4)" style="padding:10px; font-size:16px;">4</button>
        <button onclick="setSudokuNumber(5)" style="padding:10px; font-size:16px;">5</button>
        <button onclick="setSudokuNumber(6)" style="padding:10px; font-size:16px;">6</button>
        <button onclick="setSudokuNumber(7)" style="padding:10px; font-size:16px;">7</button>
        <button onclick="setSudokuNumber(8)" style="padding:10px; font-size:16px;">8</button>
        <button onclick="setSudokuNumber(9)" style="padding:10px; font-size:16px;">9</button>
        <button onclick="setSudokuNumber(0)" style="padding:10px; font-size:14px;">❌</button>
      </div>

      <button onclick="startSudoku()" style="width:100%; margin:5px 0;">Neues Spiel</button>
      <button onclick="checkSudoku()" style="width:100%; margin:5px 0;">Prüfen</button>
      <button onclick="openSudokuRanking()" style="width:100%;">🏆 Rangliste</button>
      
      <!-- Timer -->
      <div style="margin-top:8px; font-size:14px; text-align:center;">
        ⏱️ Zeit: <strong id="sudokuTimer">00:00</strong>
      </div>
    </div>

    <!-- Elfmeterschießen -->
    <div class="card game-item">
      <h3>⚽ Elfmeterschießen</h3>
      
      <!-- Schwierigkeitsauswahl -->
      <div style="margin-bottom:10px;">
        <label>Schwierigkeit:</label>
        <select id="penaltyDifficulty" onchange="updatePenaltyDifficulty()" style="width:100%; padding:5px; margin-top:5px;">
          <option value="noob">Noob - Kleiner Torwart (🪙 1 Münze/Tor)</option>
          <option value="profi" selected>Profi - Normaler Torwart (🪙 2 Münzen/Tor)</option>
          <option value="champion">Champion - Großer Torwart (🪙 3 Münzen/Tor)</option>
        </select>
      </div>
      
      <!-- Spielfeld -->
      <div style="position:relative; width:320px; height:280px; margin:10px auto; background:linear-gradient(to bottom, #2ecc71 0%, #27ae60 100%); border-radius:10px; overflow:hidden;">
        <!-- Tor -->
        <div style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); width:200px; height:120px; border:4px solid #fff; border-bottom:none; background:rgba(0,0,0,0.1);">
          <!-- Torwart -->
          <div id="penaltyKeeper" style="position:absolute; bottom:0; left:50%; transform:translateX(-50%); width:40px; height:60px; background:#e74c3c; border-radius:50% 50% 0 0; transition:all 0.3s;"></div>
          
          <!-- Schuss-Zonen (unsichtbar, für Klicks) -->
          <div onclick="shootPenalty('topLeft')" style="position:absolute; top:0; left:0; width:33.33%; height:50%; cursor:crosshair; z-index:10;"></div>
          <div onclick="shootPenalty('topCenter')" style="position:absolute; top:0; left:33.33%; width:33.33%; height:50%; cursor:crosshair; z-index:10;"></div>
          <div onclick="shootPenalty('topRight')" style="position:absolute; top:0; right:0; width:33.33%; height:50%; cursor:crosshair; z-index:10;"></div>
          <div onclick="shootPenalty('bottomLeft')" style="position:absolute; bottom:0; left:0; width:33.33%; height:50%; cursor:crosshair; z-index:10;"></div>
          <div onclick="shootPenalty('bottomCenter')" style="position:absolute; bottom:0; left:33.33%; width:33.33%; height:50%; cursor:crosshair; z-index:10;"></div>
          <div onclick="shootPenalty('bottomRight')" style="position:absolute; bottom:0; right:0; width:33.33%; height:50%; cursor:crosshair; z-index:10;"></div>
        </div>
        
        <!-- Ball -->
        <div id="penaltyBall" style="position:absolute; bottom:10px; left:50%; transform:translateX(-50%); width:20px; height:20px; background:#fff; border-radius:50%; box-shadow:0 2px 5px rgba(0,0,0,0.3);"></div>
        
        <!-- Elfmeterpunkt -->
        <div style="position:absolute; bottom:10px; left:50%; transform:translateX(-50%); width:8px; height:8px; background:#fff; border-radius:50%;"></div>
      </div>

      <p id="penaltyStatus" style="text-align:center; font-weight:bold; min-height:25px; color:#27ae60;">Wähle Schwierigkeit und klick "Start"!</p>
      
      <!-- Score Anzeige -->
      <div style="display:flex; justify-content:space-around; margin:10px 0; font-size:14px;">
        <div>⚽ Tore: <strong id="penaltyGoals">0</strong></div>
        <div>🎯 Serie: <strong id="penaltyStreak">0</strong></div>
        <div>🪙 Münzen: <strong id="penaltyCoins">0</strong></div>
      </div>

      <button onclick="startPenalty()" style="width:100%; margin:5px 0;">Start</button>
      <button onclick="stopPenalty()" style="width:100%; margin:5px 0; background:#e74c3c;">Stoppen</button>
      <button onclick="openPenaltyRanking()" style="width:100%;">🏆 Rangliste</button>
      
      <p style="font-size:11px; margin-top:10px; opacity:0.8;">💰 Noob: 1 M. | Profi: 2 M. | Champion: 3 M.</p>
    </div>

    <!-- Schach -->
    <div class="card game-item">
      <h3>♟️ Schach gegen KI</h3>
      
      <!-- Schwierigkeit -->
      <div style="margin-bottom:10px;">
        <label>Schwierigkeit:</label>
        <select id="chessDifficulty" style="padding:5px; margin-left:10px;">
          <option value="noob">🟢 Noob (20 Münzen)</option>
          <option value="profi">🟡 Profi (50 Münzen)</option>
          <option value="champion">🔴 Champion (100 Münzen)</option>
        </select>
      </div>
      
      <!-- Schachbrett -->
      <div id="chessBoard" style="display:grid; grid-template-columns:repeat(8,45px); grid-template-rows:repeat(8,45px); margin:15px auto; width:fit-content; border:3px solid #333; border-radius:4px; overflow:hidden;"></div>
      
      <p id="chessStatus" style="text-align:center; font-weight:bold; min-height:25px; color:#27ae60;">Wähle Schwierigkeit und klick "Start"!</p>
      
      <button onclick="startChess()" style="width:100%; margin:5px 0;">Start</button>
      <button onclick="resetChess()" style="width:100%; margin:5px 0; background:#e74c3c;">Neu starten</button>
      <button onclick="openChessRanking()" style="width:100%;">🏆 Rangliste</button>
      
      <p style="font-size:11px; margin-top:10px; opacity:0.8;">💰 Sieg: Noob 20 M. | Profi 50 M. | Champion 100 M. | Niederlage: 10 M. Trostpreis</p>
    </div>

    <!-- Memory Game -->
    <div class="card game-item" id="memoryGameCard">
      <h3 data-i18n="memory_title">🧠 Memory</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="memory_desc">Finde alle Paare mit möglichst wenigen Zügen.</p>
      <label style="display:block; font-size:12px; margin-bottom:6px;" data-i18n="memory_difficulty_label">Schwierigkeit:
        <select id="memoryDifficultySelect" onchange="setMemoryDifficulty(this.value)" style="margin-left:6px; padding:4px 6px; border-radius:6px; border:1px solid #ccc;">
          <option value="noob" data-i18n="memory_diff_noob">Noob</option>
          <option value="profi" data-i18n="memory_diff_profi">Profi</option>
          <option value="champion" data-i18n="memory_diff_champion">Champion</option>
        </select>
      </label>
      <div id="memoryStats" style="font-size:12px; margin-bottom:8px;">
        <span data-i18n="memory_moves_label">Züge:</span> <strong id="memoryMoves">0</strong> | 
        <span data-i18n="memory_best_label">Best:</span> <strong id="memoryBest">-</strong>
      </div>
      <div id="memoryGrid" style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:10px;"></div>
      <button onclick="startMemory()" style="width:100%; margin:5px 0;" data-i18n="memory_start">Start</button>
      <button onclick="resetMemory()" style="width:100%; margin:5px 0; background:#e74c3c;" data-i18n="memory_reset">Neu</button>
      <button onclick="openMemoryRanking()" style="width:100%;" data-i18n="memory_ranking">🏆 Rangliste</button>
      <p style="font-size:11px; opacity:0.7; margin-top:6px;" data-i18n="memory_help">Zwei Karten anklicken um sie aufzudecken. Finde alle Paare. Weniger Züge = besser.</p>
    </div>

    <!-- Flags Quiz -->
    <div class="card game-item" id="flagsQuizCard">
      <h3 data-i18n="flags_title">🌍 Flaggen Quiz</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="flags_desc">Erkenne die Flaggen! 3-5 Münzen pro richtiger Antwort.</p>
      <div id="flagsStats" style="font-size:12px; margin-bottom:8px;">
        <span data-i18n="flags_score_label">Score:</span> <strong id="flagsScore">0</strong> / <strong id="flagsTotal">0</strong> | 
        <span data-i18n="flags_coins_label">Münzen:</span> <strong id="flagsCoins">0</strong>
      </div>
      <div id="flagsGameArea" style="min-height:250px; margin-bottom:10px; text-align:center;">
        <div id="flagDisplay" style="font-size:120px; margin:20px 0; min-height:120px; line-height:1;"></div>
        <input type="text" id="flagsInput" placeholder="Land eingeben..." style="width:90%; padding:10px; border-radius:6px; border:1px solid #ccc; font-size:14px; margin-bottom:10px;" disabled />
        <div style="display:flex; gap:8px; justify-content:center;">
          <button id="flagsSubmitBtn" onclick="submitFlagsAnswer()" style="flex:1; padding:8px; background:#28a745; color:#fff; border:none; border-radius:6px; cursor:pointer;" disabled data-i18n="flags_submit">Prüfen</button>
          <button id="flagsSkipBtn" onclick="skipFlag()" style="flex:1; padding:8px; background:#ffc107; color:#333; border:none; border-radius:6px; cursor:pointer;" disabled data-i18n="flags_skip">Überspringen</button>
        </div>
        <div id="flagsFeedback" style="margin-top:10px; font-weight:bold; font-size:14px;"></div>
      </div>
      <button onclick="startFlagsQuiz()" style="width:100%; margin:5px 0;" data-i18n="flags_start">Start Quiz</button>
      <button onclick="openFlagsRanking()" style="width:100%;" data-i18n="flags_ranking">🏆 Rangliste</button>
      <p style="font-size:11px; opacity:0.7; margin-top:6px;" data-i18n="flags_help">Erkenne die Flagge und tippe das Land ein. Groß-/Kleinschreibung egal.</p>
    </div>

    <!-- Matchday Tipps moved to Top Spiele section -->

    <!-- Top Spiele section moved below the Spiele section -->
  </div>

  <!-- Top Spiele (separate section under Spiele) -->
  <div id="topGames" class="section" style="max-width:1400px; width:100%; margin:auto;">
    <h1>🔥 Top Spiele</h1>

    <!-- ⚽ Spieltag Tipps (Top 5 Ligen) -->
    <div class="card" id="matchdayTipsCard" style="max-width:1400px; width:100%; margin:0 auto;">
      <button id="setApiTokenBtn" style="float:right; margin-top:-8px; margin-right:-8px; background:#007bff; color:#fff; border-radius:6px; border:none; padding:6px 12px; font-size:13px; cursor:pointer; display:none;">API Token</button>
      <script>
      document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('setApiTokenBtn');
        const adminUids = ['adminuid1','adminuid2'];
        function showIfAdmin(){
          let uid=null;
          try{uid=(window.firebase&&firebase.auth&&firebase.auth().currentUser)?firebase.auth().currentUser.uid:(window.getAuth&&getAuth().currentUser?getAuth().currentUser.uid:null);}catch(e){}
          btn && (btn.style.display = (uid && adminUids.includes(uid)) ? '' : 'none');
        }
        showIfAdmin();
        if (window.firebase && firebase.auth) firebase.auth().onAuthStateChanged(showIfAdmin);
      });
      </script>
      <h3>⚽ Spieltag Tipps (Top 5 Ligen)</h3>
      <div id="apiTokenModal" class="modal" style="display:none;">
        <div class="modal-content">
          <span class="close" id="apiTokenModalClose">×</span>
          <h2>API Token setzen</h2>
          <p>Hier kannst du deinen <b>football-data.org</b> API Token eintragen oder ändern.</p>
          <input id="apiTokenInput" type="text" style="width:100%;padding:8px;font-size:15px;" placeholder="API Token..." />
          <button id="apiTokenSaveBtn" style="margin-top:12px;">Speichern</button>
          <div id="apiTokenSavedMsg" style="margin-top:10px;color:#28a745;display:none;">Token gespeichert!</div>
        </div>
      </div>
      <script>
      document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('setApiTokenBtn');
        const modal = document.getElementById('apiTokenModal');
        const close = document.getElementById('apiTokenModalClose');
        const input = document.getElementById('apiTokenInput');
        const save = document.getElementById('apiTokenSaveBtn');
        const savedMsg = document.getElementById('apiTokenSavedMsg');
        if (btn && modal && close && input && save) {
          btn.onclick = () => { input.value = localStorage.getItem('footballDataToken') || ''; savedMsg.style.display='none'; modal.style.display='flex'; input.focus(); };
          close.onclick = () => { modal.style.display='none'; };
          save.onclick = () => { localStorage.setItem('footballDataToken', input.value.trim()); savedMsg.style.display=''; setTimeout(()=>{ savedMsg.style.display='none'; modal.style.display='none'; window.loadMatchday && window.loadMatchday(); }, 900); };
        }
        window.onclick = function(event){ if(event.target===modal) modal.style.display='none'; };
      });
      </script>
      <p style="font-size:12px; opacity:0.8;">Tippe den nächsten Spieltag. Einsatz in Münzen. Richtiger Ergebnistipp: 3x Auszahlung. Richtige Tendenz (1X2): 2x. Falsch: Einsatz weg. Nach Spielstart gesperrt.</p>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
        <label for="leagueSelect" style="font-weight:600;">Liga:</label>
        <select id="leagueSelect" onchange="window.loadMatchday && window.loadMatchday()" style="padding:6px; border-radius:6px;">
          <option value="EPL">Premier League</option>
          <option value="LL">La Liga</option>
          <option value="BL">Bundesliga</option>
          <option value="SA">Serie A</option>
          <option value="L1">Ligue 1</option>
        </select>
        <button id="refreshLocksBtn" onclick="window.loadMatchday && window.loadMatchday()" style="padding:6px 10px;">🔄 Aktualisieren</button>
      </div>
      <div id="matchdayInfo" style="font-size:12px; opacity:0.7; margin-bottom:8px;"></div>
      <div id="fixturesList" style="display:grid; grid-template-columns:repeat(2, minmax(300px, 1fr)); gap:20px;"></div>
      <div id="betFeedback" style="margin-top:10px; font-weight:bold; font-size:14px;"></div>
    </div>

    <!-- 🎰 Slot Maschine XXL (3 x 5) -->
    <div class="card" id="slotXXLCard" style="max-width:1400px; width:100%; margin:20px auto;">
      <h3>🎰 Slot Maschine XXL</h3>
      <div style="margin-bottom:10px; display:flex; gap:10px; align-items:center;">
        <label>Einsatz:</label>
        <input id="slotXXLStake" type="number" min="100" value="100" style="width:100px;">
        <span>💰 Deine Münzen: <b id="slotXXLBalance">0</b></span>
        <button id="slotXXLSpin" onclick="spinSlotXXL()" style="margin-left:auto; padding:8px 16px;">SPIN! 🎯</button>
      </div>
      <div id="slotXXLGrid" style="display:grid; grid-template-columns:repeat(5, 110px); grid-auto-rows:110px; gap:10px; justify-content:center;">
        <div class="slot-xxl-cell" id="slotXXL-0"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-1"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-2"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-3"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-4"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-5"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-6"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-7"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-8"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-9"  style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-10" style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-11" style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-12" style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-13" style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
        <div class="slot-xxl-cell" id="slotXXL-14" style="display:flex; align-items:center; justify-content:center; font-size:42px; background:#1a1a2e; border:1px solid #444; border-radius:8px;">🍒</div>
      </div>
      <p id="slotXXLResult" style="text-align:center; font-weight:bold; margin-top:12px; min-height:24px;"></p>
    </div>
  </div>

  <script>
  // XXL SLOT MACHINE - Warte auf vollständiges Laden aller Abhängigkeiten
  (function() {
  const SYMBOLS_XXL = ["🍒", "🍋", "🍉", "🍇", "🥝", "🍓", "🍊", "🍑", "🍌", "🍍", "🥭", "🍎", "7️⃣"];
  let slotXXLReels = ["🍒", "🍋", "🍉", "🍇", "🥝", "🍓", "🍊", "🍑", "🍌", "🍍", "🥭", "🍎", "7️⃣", "🍒", "🍋"];
  let isXXLSpinning = false;

  // Update Balance Anzeige
  function updateSlotXXLBalance() {
    const coins = window.getUserCoins ? window.getUserCoins() : 0;
    const el = document.getElementById("slotXXLBalance");
    if (el) el.textContent = coins;
  }

  // Gewinn-Prüfung für 3x5 Grid - Horizontale, Vertikale, Diagonalen
  function checkXXLWin(reels) {
    let totalMultiplier = 0;
    let allWins = [];

    // Prüfe alle Gewinnlinien
    const winLines = [
      // Horizontale Linien
      { name: 'Zeile 1', cells: [0,1,2,3,4], positions: [[0,0],[0,1],[0,2],[0,3],[0,4]] },
      { name: 'Zeile 2', cells: [5,6,7,8,9], positions: [[1,0],[1,1],[1,2],[1,3],[1,4]] },
      { name: 'Zeile 3', cells: [10,11,12,13,14], positions: [[2,0],[2,1],[2,2],[2,3],[2,4]] },
      // Vertikale Linien (oben nach unten)
      { name: 'Spalte 1', cells: [0,5,10], positions: [[0,0],[1,0],[2,0]] },
      { name: 'Spalte 2', cells: [1,6,11], positions: [[0,1],[1,1],[2,1]] },
      { name: 'Spalte 3', cells: [2,7,12], positions: [[0,2],[1,2],[2,2]] },
      { name: 'Spalte 4', cells: [3,8,13], positions: [[0,3],[1,3],[2,3]] },
      { name: 'Spalte 5', cells: [4,9,14], positions: [[0,4],[1,4],[2,4]] },
      // Diagonalen links nach rechts (oben-links → unten-rechts)
      { name: 'Diagonale ↘', cells: [0,6,12], positions: [[0,0],[1,1],[2,2]] },
      { name: 'Diagonale ↘', cells: [1,7,13], positions: [[0,1],[1,2],[2,3]] },
      { name: 'Diagonale ↘', cells: [2,8,14], positions: [[0,2],[1,3],[2,4]] },
      // Diagonalen rechts nach links (oben-rechts → unten-links)
      { name: 'Diagonale ↙', cells: [4,8,12], positions: [[0,4],[1,3],[2,2]] },
      { name: 'Diagonale ↙', cells: [3,7,11], positions: [[0,3],[1,2],[2,1]] },
      { name: 'Diagonale ↙', cells: [2,6,10], positions: [[0,2],[1,1],[2,0]] },
    ];

    winLines.forEach(line => {
      const symbols = line.cells.map(idx => reels[idx]);
      
      // Prüfe ALLE möglichen Startpositionen für aufeinanderfolgende Symbole
      for (let start = 0; start < symbols.length; start++) {
        let consecutiveCount = 1;
        let symbol = symbols[start];
        
        // Zähle aufeinanderfolgende gleiche Symbole ab dieser Startposition
        for (let i = start + 1; i < symbols.length; i++) {
          if (symbols[i] === symbol) {
            consecutiveCount++;
          } else {
            break;
          }
        }
        
        // Gewinn berechnen
        if (consecutiveCount >= 3) {
          let multiplier = 0;
          let type = 'lose';

          if (consecutiveCount === 5) {
            if (symbol === "7️⃣") {
              multiplier = 20;
              type = "seven-jackpot";
            } else {
              multiplier = 10;
              type = "jackpot";
            }
          } else if (consecutiveCount === 4) {
            multiplier = symbol === "7️⃣" ? 8 : 4;
            type = "quad";
          } else if (consecutiveCount === 3) {
            multiplier = symbol === "7️⃣" ? 4 : 2;
            type = "triple";
          }

          totalMultiplier += multiplier;
          // Speichere nur die Positionen der gewinnenden Symbole
          const winningCells = line.cells.slice(start, start + consecutiveCount);
          const winningPositions = line.positions.slice(start, start + consecutiveCount);
          allWins.push({ 
            type, 
            multiplier, 
            count: consecutiveCount, 
            symbol, 
            line: line.name,
            cells: winningCells,
            positions: winningPositions
          });
          
          // Breche nach dem ersten Gewinn in dieser Linie ab (keine Dopplungen)
          break;
        }
      }
    });

    if (totalMultiplier > 0) {
      return { 
        type: 'win', 
        multiplier: totalMultiplier, 
        wins: allWins 
      };
    }

    return { type: 'lose', multiplier: 0, wins: [] };
  }

  // Zeige Gewinnlinien visuell
  function showWinLines(wins) {
    // Entferne alte Linien
    clearWinLines();
    
    if (!wins || wins.length === 0) return;

    // Markiere gewinnende Zellen
    wins.forEach((win, winIndex) => {
      win.cells.forEach(cellIdx => {
        const cell = document.getElementById(`slotXXL-${cellIdx}`);
        if (cell) {
          cell.style.boxShadow = '0 0 20px 5px #ff0000, inset 0 0 20px 5px rgba(255,0,0,0.3)';
          cell.style.border = '3px solid #ff0000';
        }
      });
    });
  }

  function clearWinLines() {
    for (let i = 0; i < 15; i++) {
      const cell = document.getElementById(`slotXXL-${i}`);
      if (cell) {
        cell.style.boxShadow = '';
        cell.style.border = '1px solid #444';
      }
    }
  }

  // Spin animieren
  async function animateXXLSlotSpin() {
    return new Promise(resolve => {
      let spinCount = 0;
      const maxSpins = 20;
      
      const spinInterval = setInterval(() => {
        // Zufällige Symbole
        for (let i = 0; i < 15; i++) {
          slotXXLReels[i] = SYMBOLS_XXL[Math.floor(Math.random() * SYMBOLS_XXL.length)];
          const cell = document.getElementById(`slotXXL-${i}`);
          if (cell) {
            cell.textContent = slotXXLReels[i];
            cell.classList.add("spinning");
          }
        }
        
        spinCount++;
        if (spinCount >= maxSpins) {
          clearInterval(spinInterval);
          
          // Spinning-Klasse entfernen
          for (let i = 0; i < 15; i++) {
            const cell = document.getElementById(`slotXXL-${i}`);
            if (cell) cell.classList.remove("spinning"); 
          }
          
          resolve();
        }
      }, 100);
    });
  }

  // Haupt-Spin Funktion
  window.spinSlotXXL = async function() {
    if (isXXLSpinning) return;
    
    // Prüfe ob User eingeloggt ist - nutze alle verfügbaren Auth-Methoden
    const user = window.currentUser || (typeof auth !== 'undefined' && auth.currentUser) || (window.auth && window.auth.currentUser);
    if (!user) {
      showNotification("Fehler", "Bitte einloggen zum Spielen!");
      return;
    }
    
    const bet = parseInt(document.getElementById("slotXXLStake").value) || 0;
    
    if (bet < 100) {
      showNotification("Fehler", "Mindesteinsatz für XXL Slot ist 100 Münzen!");
      return;
    }
    
    // Hole aktuelle Münzen direkt von der getUserCoins Funktion
    const coins = window.getUserCoins ? window.getUserCoins() : (window.userCoins || 0);
    if (bet > coins) {
      showNotification("Fehler", `Du hast nicht genug Münzen! Du hast ${coins}, brauchst aber ${bet}.`);
      return;
    }
    
    isXXLSpinning = true;
    document.getElementById("slotXXLSpin").disabled = true;
    document.getElementById("slotXXLResult").textContent = "";
    
    // Einsatz abziehen - verwende window.addCoins falls verfügbar
    if (window.addCoins) {
      await window.addCoins(-bet);
    } else {
      console.error("addCoins function not available");
    }
    updateSlotXXLBalance();
    
    // Spin Sound
    if (window.playSpinSound) window.playSpinSound();
    
    // Lösche alte Gewinnlinien
    clearWinLines();
    
    // Animiere
    await animateXXLSlotSpin();
    
    // Prüfe Gewinn
    const result = checkXXLWin(slotXXLReels);
    let winAmount = bet * result.multiplier;
    let resultText = "";

    if (result.wins && result.wins.length > 0) {
      // Zeige Gewinnlinien visuell
      showWinLines(result.wins);
      
      // Gewinne anzeigen
      const winLines = result.wins.map(w => {
        let desc = '';
        if (w.count === 5) desc = w.symbol === "7️⃣" ? "SIEBEN-JACKPOT!" : "JACKPOT!";
        else if (w.count === 4) desc = "4x";
        else if (w.count === 3) desc = "3x";
        return `${desc} ${w.symbol} (${w.line})`;
      }).join(' + ');
      
      resultText = `🎉 GEWINN! ${winLines} = +${winAmount} Münzen!`;
      if (window.playWinSound) window.playWinSound();
    } else {
      resultText = "❌ Verloren! Versuch es nochmal!";
      if (window.playLoseSound) window.playLoseSound();
    }

    if (winAmount > 0) {
      if (window.addCoins) {
        await window.addCoins(winAmount);
      }
      
      // Speichere höchsten Slot-Gewinn
      const user = window.currentUser || (window.auth && window.auth.currentUser);
      if (user && window.getDoc && window.updateDoc && window.doc && window.db) {
        const userDoc = await window.getDoc(window.doc(window.db, 'users', user.uid));
        const currentHighWin = userDoc.exists() ? (userDoc.data().slotHighWin || 0) : 0;
        
        if (winAmount > currentHighWin) {
          await window.updateDoc(window.doc(window.db, 'users', user.uid), { 
            slotHighWin: winAmount 
          });
        }
      }
      
      // Track Slot Winnings für Battle Pass
      if (window.updateBPQuestProgress) {
        await window.updateBPQuestProgress('slotWins', winAmount);
      }
      
      // Track Jackpot für Battle Pass
      if ((result.type === 'jackpot' || result.type === 'seven-jackpot') && window.updateBPQuestProgress) {
        await window.updateBPQuestProgress('jackpot', 1);
      }
    }

    updateSlotXXLBalance();
    document.getElementById("slotXXLResult").textContent = resultText;

    isXXLSpinning = false;
    document.getElementById("slotXXLSpin").disabled = false;
  };

  window.resetSlotXXL = function() {
    document.getElementById("slotXXLResult").textContent = "";
    document.getElementById("slotXXLStake").value = "100";
    updateSlotXXLBalance();
  };

  // Init beim Start
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateSlotXXLBalance);
  } else {
    updateSlotXXLBalance();
  }
  })(); // Ende IIFE
  </script>

  <!-- Snake Ranking Modal -->
  <div id="snakeRankingModal" class="auth-modal">
    <div class="auth-modal-content">
      <span class="auth-close" onclick="closeSnakeRanking()">&times;</span>
      <h2>🏆 Snake Rangliste (Top 10)</h2>
      
      <!-- Tab Buttons -->
      <div style="margin-bottom:15px; text-align:center;">
        <button id="snakeRankingTabAll" onclick="switchSnakeRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
        <button id="snakeRankingTabFriends" onclick="switchSnakeRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
      </div>
      
      <div id="snakeRankingList" style="max-height:400px; overflow-y:auto;"></div>
    </div>
  </div>

<!-- Flappy Bird Ranking Modal -->
<div id="flappyRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeFlappyRanking()">&times;</span>
    <h2>🏆 Flappy Bird Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="flappyRankingTabAll" onclick="switchFlappyRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="flappyRankingTabFriends" onclick="switchFlappyRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <div id="flappyRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Basketball Ranking Modal -->
<!-- Memory Ranking Modal -->
<div id="memoryRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeMemoryRanking()">&times;</span>
    <h2 data-i18n="memory_ranking_title">🏆 Memory Rangliste (Top 10)</h2>
    <div style="margin-bottom:15px; text-align:center;">
      <button id="memoryRankingTabAll" onclick="switchMemoryRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="memoryRankingTabFriends" onclick="switchMemoryRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    <div id="memoryRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Flags Quiz Ranking Modal -->
<div id="flagsRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeFlagsRanking()">&times;</span>
    <h2 data-i18n="flags_ranking_title">🏆 Flaggen Quiz Rangliste (Top 10)</h2>
    <div style="margin-bottom:15px; text-align:center;">
      <button id="flagsRankingTabAll" onclick="switchFlagsRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="flagsRankingTabFriends" onclick="switchFlagsRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    <div id="flagsRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Matchday Tips Ranking Modal -->
<div id="matchdayRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeMatchdayRanking()">&times;</span>
    <h2>🏆 Spieltag Tipps Rangliste (Top 10)</h2>
    <div id="matchdayRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
  </div>

<!-- Tic Tac Toe Ranking Modal -->
<div id="tttRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeTTTRanking()">&times;</span>
    <h2>🏆 Tic Tac Toe Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="tttRankingTabAll" onclick="switchTTTRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="tttRankingTabFriends" onclick="switchTTTRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <!-- Schwierigkeitsfilter -->
    <div style="margin-bottom:15px; text-align:center;">
      <label>Filter:</label>
      <select id="tttRankingFilter" onchange="loadTTTRankings()" style="padding:5px; margin-left:10px;">
        <option value="all">Alle Schwierigkeiten</option>
        <option value="noob">Noob</option>
        <option value="profi">Profi</option>
        <option value="champion">Champion</option>
      </select>
    </div>
    
    <div id="tttRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Tower Stack Ranking Modal -->
<div id="towerRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeTowerRanking()">&times;</span>
    <h2>🏆 Tower Stack Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="towerRankingTabAll" onclick="switchTowerRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="towerRankingTabFriends" onclick="switchTowerRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <div id="towerRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Sudoku Ranking Modal -->
<div id="sudokuRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeSudokuRanking()">&times;</span>
    <h2>🏆 Sudoku Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="sudokuRankingTabAll" onclick="switchSudokuRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="sudokuRankingTabFriends" onclick="switchSudokuRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <!-- Filter Dropdown -->
    <div style="margin-bottom:15px; text-align:center;">
      <label>Filter:</label>
      <select id="sudokuRankingFilter" onchange="loadSudokuRankings()" style="padding:5px; margin-left:10px;">
        <option value="all">Alle Schwierigkeiten</option>
        <option value="noob">Noob</option>
        <option value="profi">Profi</option>
        <option value="champion">Champion</option>
      </select>
    </div>
    
    <div id="sudokuRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Elfmeterschießen Ranking Modal -->
<div id="penaltyRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closePenaltyRanking()">&times;</span>
    <h2>🏆 Elfmeterschießen Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="penaltyRankingTabAll" onclick="switchPenaltyRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="penaltyRankingTabFriends" onclick="switchPenaltyRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <div id="penaltyRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Dino Game Ranking Modal -->
<div id="dinoRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeDinoRanking()">&times;</span>
    <h2>🏆 Dino Run Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="dinoRankingTabAll" onclick="switchDinoRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="dinoRankingTabFriends" onclick="switchDinoRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <div id="dinoRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- Schach Ranking Modal -->
<div id="chessRankingModal" class="auth-modal">
  <div class="auth-modal-content">
    <span class="auth-close" onclick="closeChessRanking()">&times;</span>
    <h2>🏆 Schach Rangliste (Top 10)</h2>
    
    <!-- Tab Buttons -->
    <div style="margin-bottom:15px; text-align:center;">
      <button id="chessRankingTabAll" onclick="switchChessRankingTab('all')" style="padding:8px 16px; margin:0 5px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; font-weight:bold;">Alle</button>
      <button id="chessRankingTabFriends" onclick="switchChessRankingTab('friends')" style="padding:8px 16px; margin:0 5px; background:#6c757d; color:#fff; border:none; border-radius:5px; cursor:pointer;">Freunde</button>
    </div>
    
    <!-- Filter Dropdown -->
    <div style="margin-bottom:15px; text-align:center;">
      <label>Filter:</label>
      <select id="chessRankingFilter" onchange="loadChessRankings()" style="padding:5px; margin-left:10px;">
        <option value="all">Alle Schwierigkeiten</option>
        <option value="noob">Noob</option>
        <option value="profi">Profi</option>
        <option value="champion">Champion</option>
      </select>
    </div>
    
    <div id="chessRankingList" style="max-height:400px; overflow-y:auto;"></div>
  </div>
</div>

<!-- News -->
<div id="news" class="section">
  <h1 data-i18n="section_news">News</h1>
  <div id="newsList"></div>

  <!-- News posten – nur Admin sieht diese Karte -->
  <div class="card" id="newsAdminCard" style="display:none;">
    <h2>News schreiben (nur Admin)</h2>
    <p>Absender: <strong>imthefx</strong></p>
    <input type="text" id="newsTitle" placeholder="Titel">
    <textarea id="newsContent" placeholder="Inhalt"></textarea>
    <button onclick="postNews()">Posten</button>
  </div>
</div>

<!-- Live Chat -->
<div id="chat" class="section">
  <h1 data-i18n="chat_title">Live Chat</h1>

  <p id="chatInfo">Bitte einloggen, um zu schreiben.</p>

  <div style="display:flex; gap:20px; align-items:stretch;">
    <!-- Linke Seite: Eingabebereich -->
    <div style="flex:0 0 300px; display:flex; flex-direction:column; gap:10px;">
      <textarea id="chatText" placeholder="Nachricht (Enter = Senden, Shift+Enter = Absatz)" style="flex:1; min-height:200px; resize:vertical;" data-i18n-placeholder="chat_type_message"></textarea>
      <button id="gifButton" onclick="toggleGifInput()" style="display:none; background:#9333ea; width:100%;" data-i18n="chat_gif_send">GIF senden 🎬</button>
      <input type="text" id="gifUrl" placeholder="GIF URL einfügen" style="display:none;" data-i18n-placeholder="chat_gif_url">
      <button onclick="sendMessage()" style="background:#28a745; font-weight:bold; width:100%;" data-i18n="chat_send">Absenden</button>
    </div>
    
    <!-- Rechte Seite: Chat-Box -->
    <div class="chat-box" id="chatMessages" style="flex:1; max-height:500px;"></div>
  </div>
</div>

<!-- Shop -->
<div id="shop" class="section">
  <h1 data-i18n="shop_title">Shop</h1>
  
  <!-- Daily Shop Header -->
  <div id="shopHeader"></div>
  
  <!-- Shop Items Grid -->
  <div class="shop-grid">
    
    <!-- Chat Name Farben -->
    <div class="card">
      <h3 data-i18n="shop_chat_colors_title">🎨 Namen Farben</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="shop_chat_colors_desc">Ändere die Farbe deines Namens!</p>
      <div id="chatColorList"></div>
    </div>

    <!-- Website Themes -->
    <div class="card">
      <h3 data-i18n="shop_themes_title">🌈 Website Themes</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="shop_themes_desc">Ändere das Design deiner Website!</p>
      <div id="themesList"></div>
    </div>
    
    <!-- Badges -->
    <div class="card">
      <h3 data-i18n="shop_badges_title">🎖️ Badges</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="shop_badges_desc">Zeige deine Auszeichnungen im Chat!</p>
      <div id="badgesList"></div>
    </div>
    
    <!-- GIF Feature - IMMER VERFÜGBAR -->
    <div class="card" style="border: 2px solid #28a745;">
      <h3>🎬 GIF-Feature <span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">IMMER VERFÜGBAR</span></h3>
      <p style="font-size:12px; opacity:0.8;">Sende GIFs im Chat!</p>
      <div id="gifFeatureShop">
        <div class="shop-item">
          <div class="shop-item-info">
            <strong>🎬 GIF-Feature</strong>
            <p style="font-size:12px; opacity:0.7; margin:5px 0;">Schalte die Möglichkeit frei, GIFs im Chat zu senden!</p>
          </div>
          <div>
            <span class="shop-item-price">🪙 1000</span>
            <button onclick="buyShopItem('gifUnlock', 'gif')" style="padding:5px 10px; font-size:12px;" data-i18n="buy">Kaufen</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Hintergrundmusik -->
    <div class="card">
      <h3>🎵 Hintergrundmusik</h3>
      <p style="font-size:12px; opacity:0.8;">Ändere die Hintergrundmusik deiner Website!</p>
      <div id="musicList"></div>
    </div>
    
    <!-- Schriftarten -->
    <div class="card">
      <h3>🖋️ Schriftarten</h3>
      <p style="font-size:12px; opacity:0.8;">Ändere den Schriftstil deines Chats!</p>
      <div id="fontsList"></div>
    </div>

  </div>
</div>

<!-- Inventar -->
<div id="inventar" class="section">
  <h1 data-i18n="inventory_title">🎒 Inventar</h1>
  <div class="inventory-controls" style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:12px;">
    <div class="inventory-tabs" style="display:flex; gap:6px;">
      <button class="inv-tab" data-cat="all" onclick="setInventoryCategory('all')" style="padding:6px 10px;">Alle</button>
      <button class="inv-tab" data-cat="chatColors" onclick="setInventoryCategory('chatColors')" style="padding:6px 10px;">Farben</button>
      <button class="inv-tab" data-cat="themes" onclick="setInventoryCategory('themes')" style="padding:6px 10px;">Themes</button>
      <button class="inv-tab" data-cat="badges" onclick="setInventoryCategory('badges')" style="padding:6px 10px;">Badges</button>
      <button class="inv-tab" data-cat="music" onclick="setInventoryCategory('music')" style="padding:6px 10px;">🎵 Musik</button>
      <button class="inv-tab" data-cat="fonts" onclick="setInventoryCategory('fonts')" style="padding:6px 10px;">🖋️ Schriften</button>
    </div>
    <input id="inventorySearch" type="text" placeholder="Suche..." style="flex:1; min-width:160px; padding:6px 8px; border:1px solid #ccc; border-radius:6px;" />
    <label style="font-size:12px; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="inventoryCompactToggle" onchange="toggleInventoryCompact()" /> Kompakt
    </label>
    <label style="font-size:12px; display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="inventoryFavsOnly" onchange="displayInventory()" /> Favoriten
    </label>
  </div>
  <div class="shop-grid" id="inventoryGrid">
    <!-- Chat Name Farben -->
    <div class="card inv-cat" data-cat="chatColors">
      <h3 data-i18n="inv_chat_colors_title">🎨 Namen Farben</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="inv_chat_colors_desc">Deine Namensfarben</p>
      <div id="inventoryChatColors"></div>
    </div>

    <!-- Website Themes -->
    <div class="card inv-cat" data-cat="themes">
      <h3 data-i18n="inv_themes_title">🌈 Website Themes</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="inv_themes_desc">Deine gekauften Themes</p>
      <div id="inventoryThemes"></div>
    </div>

    <!-- Badges/Nametags -->
    <div class="card inv-cat" data-cat="badges">
      <h3 data-i18n="inv_badges_title">🏅 Badges & Nametags</h3>
      <p style="font-size:12px; opacity:0.8;" data-i18n="inv_badges_desc">Badges aus dem Battle Pass</p>
      <div id="inventoryBadges"></div>
    </div>
    
    <!-- Hintergrundmusik -->
    <div class="card inv-cat" data-cat="music">
      <h3>🎵 Hintergrundmusik</h3>
      <p style="font-size:12px; opacity:0.8;">Deine gekauften Musik-Tracks</p>
      <div id="inventoryMusic"></div>
    </div>
    
    <!-- Schriftarten -->
    <div class="card inv-cat" data-cat="fonts">
      <h3>🖋️ Schriftarten</h3>
      <p style="font-size:12px; opacity:0.8;">Deine gekauften Schriftstile</p>
      <div id="inventoryFonts"></div>
    </div>


  </div>
</div>

<!-- Battle Pass -->
<div id="battlepass" class="section">
  <h1 data-i18n="bp_title">🏆 Battle Pass</h1>
  
  <div class="card">
    <h2>Dezember Battle Pass 🎄</h2>
    <p>Verdiene Punkte durch tägliche Challenges und erhalte exklusive Rewards!</p>
    
    <!-- Battle Pass Status -->
    <div style="background:#f0f0f0; padding:15px; border-radius:8px; margin-bottom:15px;">
      <p><span data-i18n="bp_status">Status:</span> <strong id="bpStatus">Nicht aktiviert</strong></p>
      <p><span data-i18n="bp_month">Monat:</span> <strong id="bpMonth">-</strong></p>
      <p><span data-i18n="bp_points">Punkte:</span> <strong id="bpProgress">0</strong> / <span id="bpMaxPoints">100</span></p>
      <div style="background:#ddd; height:20px; border-radius:10px; overflow:hidden; margin:10px 0;">
        <div id="bpBar" style="background:#28a745; height:100%; width:0%; transition:width 0.3s;"></div>
      </div>
      <button onclick="activateBattlePassPremium()" id="bpActivateBtn" style="width:100%; padding:10px; margin-top:10px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border:none; border-radius:5px; cursor:pointer; font-weight:bold;" data-i18n="bp_activate_premium">Premium aktivieren (500 Münzen)</button>
    </div>

    <!-- Nächste Belohnungen -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
      <div style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding:15px; border-radius:10px; color:white;">
        <h4 style="margin:0 0 10px 0;">🎁 Nächste Free Belohnung</h4>
        <div id="nextFreeReward" style="font-size:14px;">-</div>
      </div>
      <div style="background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding:15px; border-radius:10px; color:white;">
        <h4 style="margin:0 0 10px 0;">💎 Nächste Premium Belohnung</h4>
        <div id="nextPaidReward" style="font-size:14px;">-</div>
      </div>
    </div>

    <!-- Tägliche Quests (Reset 15:00 deutsche Zeit) -->
    <h3 data-i18n="bp_daily_quests">📋 Tägliche Quests <span style="font-size:12px; opacity:0.7;">(Reset: 15:00 Uhr)</span></h3>
    <div id="dailyQuestsList" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(350px, 1fr)); gap:10px; margin-bottom:20px;"></div>

    <!-- Wöchentliche Quests (Reset jeden Montag) -->
    <h3 data-i18n="bp_weekly_quests">🌟 Wöchentliche Quests <span style="font-size:12px; opacity:0.7;">(Reset: Jeden Montag)</span></h3>
    <div id="weeklyQuestsList" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(350px, 1fr)); gap:10px; margin-bottom:20px;"></div>

    <!-- Battle Pass Tiers -->
    <h3>🏆 Battle Pass Stufen</h3>
    <div id="bpTiersList" style="display:grid; gap:15px;"></div>
  </div>
</div>

<!-- Firebase & Main Script -->
<script type="module">
/////////////////////////////////////////////////////////////////////////////
// Firebase Setup
/////////////////////////////////////////////////////////////////////////////

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getAuth,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  deleteUser,
  updatePassword,
  EmailAuthProvider,
  reauthenticateWithCredential,
  sendPasswordResetEmail,
  sendEmailVerification
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import {
  getFirestore,
  collection,
  addDoc,
  serverTimestamp,
  query,
  orderBy,
  limit,
  onSnapshot,
  doc,
  setDoc,
  getDoc,
  where,
  getDocs,
  deleteDoc,
  updateDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import {
  getStorage,
  ref,
  uploadBytesResumable,
  getDownloadURL,
  listAll
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

// Firebase-Konfiguration
const firebaseConfig = {
  apiKey: "AIzaSyAeC7Nt3ElB4KdCei-g19syTsF8hSoccSI",
  authDomain: "fehlstundenzettel.firebaseapp.com",
  projectId: "fehlstundenzettel",
  storageBucket: "fehlstundenzettel.firebasestorage.app",
  messagingSenderId: "95765743506",
  appId: "1:95765743506:web:05f5305b6d7c56ba0a234b",
  measurementId: "G-QWEBRN16HW"
};

// Admin E-Mail (für News & PDF-Upload)
const ADMIN_EMAIL = "felixhorschke19@gmail.com";

// Firebase initialisieren
const app = initializeApp(firebaseConfig);
const auth = getAuth();
window.auth = auth; // Expose globally for XXL Slot access
const db = getFirestore();
window.db = db; // Expose globally for XXL Slot access
const storage = getStorage();

// Expose Firestore functions globally for XXL Slot
window.getDoc = getDoc;
window.updateDoc = updateDoc;
window.doc = doc;

// globaler User/Nickname
let currentUser = null;
let currentNickname = null;
let currentProfilePic = null;

/////////////////////////////////////////////////////////////////////////////
// Language System
/////////////////////////////////////////////////////////////////////////////

let currentLanguage = 'de';

const translations = {
  de: {
      section_news: 'News',
      chat_title: '💬 Live-Chat',
      chat_type_message: 'Nachricht schreiben...',
      chat_gif_send: 'GIF senden 🎬',
      chat_gif_url: 'GIF URL einfügen',
      chat_send: 'Absenden',
      shop_title: '🛍️ Shop',
      shop_chat_colors_title: '🎨 Namen Farben',
      shop_chat_colors_desc: 'Ändere die Farbe deines Namens!',
      shop_themes_title: '🌈 Website Themes',
      shop_themes_desc: 'Ändere das Design deiner Website!',
      shop_badges_title: '🎖️ Badges',
      shop_badges_desc: 'Zeige deine Auszeichnungen im Chat!',
      basketball_title: '🏀 Basketball',
      basketball_desc: 'Ziele mit Winkel & Power und triff den Korb!',
      basketball_start: 'Start',
      basketball_shoot: 'Werfen',
      basketball_reset: 'Neu',
      basketball_ranking: '🏆 Rangliste',
      basketball_score_label: 'Score:',
      basketball_high_label: 'High:',
      basketball_help: 'Triff den Korb für Punkte. Neuer Highscore speichert global.',
      daily_shop_title: '🌟 Daily Shop',
      daily_shop_subtitle: 'Täglich um 9:00 Uhr neue Angebote!',
      daily_shop_next_rotation: '⏰ Nächste Rotation in:',
      activate_default: 'Standard aktivieren',
      activate_dark: 'Darkmode aktivieren',
      purchased: '✓ Gekauft',
      buy: 'Kaufen',
      inventory_title: '🎒 Inventar',
      inv_chat_colors_title: '🎨 Namen Farben',
      inv_chat_colors_desc: 'Deine Namensfarben',
      inv_themes_title: '🌈 Website Themes',
      inv_themes_desc: 'Deine gekauften Themes',
      inv_badges_title: '🏅 Badges & Nametags',
      inv_badges_desc: 'Badges aus dem Battle Pass',
      bp_title: '🏆 Battle Pass',
      bp_status: 'Status:',
      bp_month: 'Monat:',
      bp_points: 'Punkte:',
      bp_activate_premium: 'Premium aktivieren (500 Münzen)',
      bp_daily_quests: '📋 Tägliche Quests',
      bp_weekly_quests: '🌟 Wöchentliche Quests',
    // Navigation
    nav_pdfs: 'PDFs',
    nav_games: 'Spiele',
    nav_news: 'News',
    nav_chat: 'Live-Chat',
    nav_shop: '🛍️ Shop',
    nav_inventory: '🎒 Inventar',
    nav_battlepass: '🏆 Battle Pass',
    nav_not_logged_in: 'Nicht eingeloggt',
    nav_login: 'Login',
    nav_register: 'Registrieren',
    nav_account: 'Mein Konto',
    nav_friends: 'Freunde',
    nav_settings: 'Einstellungen',
    
    // Settings
    settings_title: '⚙️ Einstellungen',
    settings_language_title: '🌐 Sprache / Language',
    
    // Common
    close: 'Schließen',
    save: 'Speichern',
    cancel: 'Abbrechen',
    confirm: 'Bestätigen',
    delete: 'Löschen',
    send: 'Senden',
    search: 'Suchen',
    loading: 'Laden...',
    error: 'Fehler',
    success: 'Erfolg',
    
    // Auth
    login_title: '🔐 Login',
    register_title: '📝 Registrieren',
    email: 'E-Mail',
    password: 'Passwort',
    nickname: 'Nickname',
    logout: 'Ausloggen',
    
    // Account
    account_title: '👤 Mein Konto',
    profile_picture: 'Profilbild',
    change_nickname: 'Nickname ändern',
    change_password: 'Passwort ändern',
    delete_account: 'Konto löschen',
    
    // Friends
    friends_title: '👥 Freunde',
    search_friend: '🔍 Freund suchen',
    friend_requests: '📥 Eingehende Freundesanfragen',
    my_friends: '✅ Meine Freunde',
    add_friend: 'Freund hinzufügen',
    remove_friend: 'Freund entfernen',
    accept: 'Annehmen',
    decline: 'Ablehnen',
    online: 'Online',
    offline: 'Offline',
    
    // Chat
    chat_title: '💬 Live-Chat',
    private_chat: '💬 Privat Chat',
    type_message: 'Nachricht schreiben...',
    
    // Sections
    section_pdfs: 'Formulare / PDFs',
    section_games: '🎮 Spiele',

    // Games UI
    games_title: '🎮 Spiele',
    games_scroll_back: '◀ Zurück',
    games_scroll_next: 'Weiter ▶',
    play: 'Spielen',
    ranking: '🏆 Rangliste',
    score: 'Punkte',
    highscore: 'Highscore',
    
    // Battle Pass
    bp_title: '🏆 Battle Pass',
    bp_points: 'Punkte',
    bp_tier: 'Stufe',
    bp_daily_quests: 'Tägliche Quests',
    bp_weekly_quests: 'Wöchentliche Quests',
    bp_claim: 'Einsammeln',
    bp_claimed: 'Eingesammelt',
    
    // Shop
    shop_title: '🛍️ Shop',
    buy: 'Kaufen',
    coins: 'Münzen',
    
    // Inventory
    inventory_title: '🎒 Inventar',
    no_items: 'Keine Gegenstände'
  },
  
  en: {
      section_news: 'News',
      chat_title: '💬 Live Chat',
      chat_type_message: 'Type a message...',
      chat_gif_send: 'Send GIF 🎬',
      chat_gif_url: 'Insert GIF URL',
      chat_send: 'Send',
      shop_title: '🛍️ Shop',
      shop_chat_colors_title: '🎨 Chat Name Colors',
      shop_chat_colors_desc: 'Change your chat name color!',
      shop_themes_title: '🌈 Website Themes',
      shop_themes_desc: 'Change your website design!',
      shop_badges_title: '🎖️ Badges',
      shop_badges_desc: 'Show your achievements in chat!',
      basketball_title: '🏀 Basketball',
      basketball_desc: 'Aim with angle & power and score!',
      basketball_start: 'Start',
      basketball_shoot: 'Shoot',
      basketball_reset: 'Reset',
      basketball_ranking: '🏆 Ranking',
      basketball_score_label: 'Score:',
      basketball_high_label: 'High:',
      basketball_help: 'Score points by making shots. New highs save globally.',
      daily_shop_title: '🌟 Daily Shop',
      daily_shop_subtitle: 'New offers daily at 09:00!',
      daily_shop_next_rotation: '⏰ Next rotation in:',
      activate_default: 'Activate Default',
      activate_dark: 'Activate Dark Mode',
      purchased: '✓ Purchased',
      buy: 'Buy',
      inventory_title: '🎒 Inventory',
      inv_chat_colors_title: '🎨 Chat Name Colors',
      inv_chat_colors_desc: 'Your purchased name colors',
      inv_themes_title: '🌈 Website Themes',
      inv_themes_desc: 'Your purchased themes',
      inv_badges_title: '🏅 Badges & Nametags',
      inv_badges_desc: 'Badges from the Battle Pass',
      bp_title: '🏆 Battle Pass',
      bp_status: 'Status:',
      bp_month: 'Month:',
      bp_points: 'Points:',
      bp_activate_premium: 'Activate Premium (500 coins)',
      bp_daily_quests: '📋 Daily Quests',
      bp_weekly_quests: '🌟 Weekly Quests',
    // Navigation
    nav_pdfs: 'PDFs',
    nav_games: 'Games',
    nav_news: 'News',
    nav_chat: 'Live Chat',
    nav_shop: '🛍️ Shop',
    nav_inventory: '🎒 Inventory',
    nav_battlepass: '🏆 Battle Pass',
    nav_not_logged_in: 'Not logged in',
    nav_login: 'Login',
    nav_register: 'Register',
    nav_account: 'My Account',
    nav_friends: 'Friends',
    nav_settings: 'Settings',
    
    // Settings
    settings_title: '⚙️ Settings',
    settings_language_title: '🌐 Language / Sprache',
    
    // Common
    close: 'Close',
    save: 'Save',
    cancel: 'Cancel',
    confirm: 'Confirm',
    delete: 'Delete',
    send: 'Send',
    search: 'Search',
    loading: 'Loading...',
    error: 'Error',
    success: 'Success',
    
    // Auth
    login_title: '🔐 Login',
    register_title: '📝 Register',
    email: 'Email',
    password: 'Password',
    nickname: 'Nickname',
    logout: 'Logout',
    
    // Account
    account_title: '👤 My Account',
    profile_picture: 'Profile Picture',
    change_nickname: 'Change Nickname',
    change_password: 'Change Password',
    delete_account: 'Delete Account',
    
    // Friends
    friends_title: '👥 Friends',
    search_friend: '🔍 Search Friend',
    friend_requests: '📥 Friend Requests',
    my_friends: '✅ My Friends',
    add_friend: 'Add Friend',
    remove_friend: 'Remove Friend',
    accept: 'Accept',
    decline: 'Decline',
    online: 'Online',
    offline: 'Offline',
    
    // Chat
    chat_title: '💬 Live Chat',
    private_chat: '💬 Private Chat',
    type_message: 'Type a message...',
    
    // Sections
    section_pdfs: 'Forms / PDFs',
    section_games: '🎮 Games',

    // Games UI
    games_title: '🎮 Games',
    games_scroll_back: '◀ Back',
    games_scroll_next: 'Next ▶',
    play: 'Play',
    ranking: '🏆 Ranking',
    score: 'Score',
    highscore: 'Highscore',
    
    // Battle Pass
    bp_title: '🏆 Battle Pass',
    bp_points: 'Points',
    bp_tier: 'Tier',
    bp_daily_quests: 'Daily Quests',
    bp_weekly_quests: 'Weekly Quests',
    bp_claim: 'Claim',
    bp_claimed: 'Claimed',
    
    // Shop
    shop_title: '🛍️ Shop',
    buy: 'Buy',
    coins: 'Coins',
    
    // Inventory
    inventory_title: '🎒 Inventory',
    no_items: 'No items'
  },
  
  es: {
      section_news: 'Noticias',
      chat_title: '💬 Chat en Vivo',
      chat_type_message: 'Escribe un mensaje...',
      chat_gif_send: 'Enviar GIF 🎬',
      chat_gif_url: 'Insertar URL de GIF',
      chat_send: 'Enviar',
      shop_title: '🛍️ Tienda',
      shop_chat_colors_title: '🎨 Colores de Nombre del Chat',
      shop_chat_colors_desc: '¡Cambia el color de tu nombre en el chat!',
      shop_themes_title: '🌈 Temas del Sitio',
      shop_themes_desc: '¡Cambia el diseño de tu sitio!',
      shop_badges_title: '🎖️ Insignias',
      shop_badges_desc: '¡Muestra tus logros en el chat!',
      basketball_title: '🏀 Baloncesto',
      basketball_desc: 'Apunta con ángulo y potencia y encesta!',
      basketball_start: 'Iniciar',
      basketball_shoot: 'Lanzar',
      basketball_reset: 'Reiniciar',
      basketball_ranking: '🏆 Clasificación',
      basketball_score_label: 'Puntos:',
      basketball_high_label: 'Récord:',
      basketball_help: 'Consigue puntos encestando. Nuevo récord se guarda global.',
      daily_shop_title: '🌟 Tienda Diaria',
      daily_shop_subtitle: '¡Nuevas ofertas cada día a las 09:00!',
      daily_shop_next_rotation: '⏰ Próxima rotación en:',
      activate_default: 'Activar Predeterminado',
      activate_dark: 'Activar Modo Oscuro',
      purchased: '✓ Comprado',
      buy: 'Comprar',
      inventory_title: '🎒 Inventario',
      inv_chat_colors_title: '🎨 Colores de Nombre del Chat',
      inv_chat_colors_desc: 'Tus colores comprados',
      inv_themes_title: '🌈 Temas del Sitio',
      inv_themes_desc: 'Tus temas comprados',
      inv_badges_title: '🏅 Insignias y Etiquetas',
      inv_badges_desc: 'Insignias del Pase de Batalla',
      bp_title: '🏆 Pase de Batalla',
      bp_status: 'Estado:',
      bp_month: 'Mes:',
      bp_points: 'Puntos:',
      bp_activate_premium: 'Activar Premium (500 monedas)',
      bp_daily_quests: '📋 Misiones Diarias',
      bp_weekly_quests: '🌟 Misiones Semanales',
    // Navigation
    nav_pdfs: 'PDFs',
    nav_games: 'Juegos',
    nav_news: 'Noticias',
    nav_chat: 'Chat en Vivo',
    nav_shop: '🛍️ Tienda',
    nav_inventory: '🎒 Inventario',
    nav_battlepass: '🏆 Pase de Batalla',
    nav_not_logged_in: 'No conectado',
    nav_login: 'Iniciar sesión',
    nav_register: 'Registrarse',
    nav_account: 'Mi Cuenta',
    nav_friends: 'Amigos',
    nav_settings: 'Configuración',
    
    // Settings
    settings_title: '⚙️ Configuración',
    settings_language_title: '🌐 Idioma / Language',
    
    // Common
    close: 'Cerrar',
    save: 'Guardar',
    cancel: 'Cancelar',
    confirm: 'Confirmar',
    delete: 'Eliminar',
    send: 'Enviar',
    search: 'Buscar',
    loading: 'Cargando...',
    error: 'Error',
    success: 'Éxito',
    
    // Auth
    login_title: '🔐 Iniciar sesión',
    register_title: '📝 Registrarse',
    email: 'Correo electrónico',
    password: 'Contraseña',
    nickname: 'Apodo',
    logout: 'Cerrar sesión',
    
    // Account
    account_title: '👤 Mi Cuenta',
    profile_picture: 'Foto de Perfil',
    change_nickname: 'Cambiar Apodo',
    change_password: 'Cambiar Contraseña',
    delete_account: 'Eliminar Cuenta',
    
    // Friends
    friends_title: '👥 Amigos',
    search_friend: '🔍 Buscar Amigo',
    friend_requests: '📥 Solicitudes de Amistad',
    my_friends: '✅ Mis Amigos',
    add_friend: 'Agregar Amigo',
    remove_friend: 'Eliminar Amigo',
    accept: 'Aceptar',
    decline: 'Rechazar',
    online: 'En línea',
    offline: 'Desconectado',
    
    // Chat
    chat_title: '💬 Chat en Vivo',
    private_chat: '💬 Chat Privado',
    type_message: 'Escribe un mensaje...',
    
    // Sections
    section_pdfs: 'Formularios / PDFs',
    section_games: '🎮 Juegos',

    // Games UI
    games_title: '🎮 Juegos',
    games_scroll_back: '◀ Atrás',
    games_scroll_next: 'Siguiente ▶',
    play: 'Jugar',
    ranking: '🏆 Clasificación',
    score: 'Puntuación',
    highscore: 'Puntuación Más Alta',
    
    // Battle Pass
    bp_title: '🏆 Pase de Batalla',
    bp_points: 'Puntos',
    bp_tier: 'Nivel',
    bp_daily_quests: 'Misiones Diarias',
    bp_weekly_quests: 'Misiones Semanales',
    bp_claim: 'Reclamar',
    bp_claimed: 'Reclamado',
    
    // Shop
    shop_title: '🛍️ Tienda',
    buy: 'Comprar',
    coins: 'Monedas',
    
    // Inventory
    inventory_title: '🎒 Inventario',
    no_items: 'Sin artículos'
  },
  
  ru: {
      section_news: 'Новости',
      chat_title: '💬 Живой Чат',
      chat_type_message: 'Напишите сообщение...',
      chat_gif_send: 'Отправить GIF 🎬',
      chat_gif_url: 'Вставить URL GIF',
      chat_send: 'Отправить',
      shop_title: '🛍️ Магазин',
      shop_chat_colors_title: '🎨 Цвета имени в чате',
      shop_chat_colors_desc: 'Измени цвет имени в чате!',
      shop_themes_title: '🌈 Темы сайта',
      shop_themes_desc: 'Измени дизайн сайта!',
      shop_badges_title: '🎖️ Значки',
      shop_badges_desc: 'Покажи свои достижения в чате!',
      basketball_title: '🏀 Баскетбол',
      basketball_desc: 'Целься по углу и силе и попади в корзину!',
      basketball_start: 'Старт',
      basketball_shoot: 'Бросок',
      basketball_reset: 'Сброс',
      basketball_ranking: '🏆 Рейтинг',
      basketball_score_label: 'Очки:',
      basketball_high_label: 'Рекорд:',
      basketball_help: 'Набирайте очки, попадая в корзину. Новый рекорд сохраняется.',
      daily_shop_title: '🌟 Ежедневный Магазин',
      daily_shop_subtitle: 'Новые предложения каждый день в 09:00!',
      daily_shop_next_rotation: '⏰ Следующая ротация через:',
      activate_default: 'Активировать Стандарт',
      activate_dark: 'Активировать Тёмный режим',
      purchased: '✓ Куплено',
      buy: 'Купить',
      inventory_title: '🎒 Инвентарь',
      inv_chat_colors_title: '🎨 Цвета имени в чате',
      inv_chat_colors_desc: 'Твои купленные цвета',
      inv_themes_title: '🌈 Темы сайта',
      inv_themes_desc: 'Твои купленные темы',
      inv_badges_title: '🏅 Значки и Теги',
      inv_badges_desc: 'Значки из Боевого Пропуска',
      bp_title: '🏆 Боевой Пропуск',
      bp_status: 'Статус:',
      bp_month: 'Месяц:',
      bp_points: 'Очки:',
      bp_activate_premium: 'Активировать Премиум (500 монет)',
      bp_daily_quests: '📋 Ежедневные Задания',
      bp_weekly_quests: '🌟 Еженедельные Задания',
    // Navigation
    nav_pdfs: 'PDFs',
    nav_games: 'Игры',
    nav_news: 'Новости',
    nav_chat: 'Живой Чат',
    nav_shop: '🛍️ Магазин',
    nav_inventory: '🎒 Инвентарь',
    nav_battlepass: '🏆 Боевой Пропуск',
    nav_not_logged_in: 'Не авторизован',
    nav_login: 'Войти',
    nav_register: 'Регистрация',
    nav_account: 'Мой Аккаунт',
    nav_friends: 'Друзья',
    nav_settings: 'Настройки',
    
    // Settings
    settings_title: '⚙️ Настройки',
    settings_language_title: '🌐 Язык / Language',
    
    // Common
    close: 'Закрыть',
    save: 'Сохранить',
    cancel: 'Отмена',
    confirm: 'Подтвердить',
    delete: 'Удалить',
    send: 'Отправить',
    search: 'Поиск',
    loading: 'Загрузка...',
    error: 'Ошибка',
    success: 'Успех',
    
    // Auth
    login_title: '🔐 Вход',
    register_title: '📝 Регистрация',
    email: 'Электронная почта',
    password: 'Пароль',
    nickname: 'Никнейм',
    logout: 'Выйти',
    
    // Account
    account_title: '👤 Мой Аккаунт',
    profile_picture: 'Фото Профиля',
    change_nickname: 'Изменить Никнейм',
    change_password: 'Изменить Пароль',
    delete_account: 'Удалить Аккаунт',
    
    // Friends
    friends_title: '👥 Друзья',
    search_friend: '🔍 Поиск Друга',
    friend_requests: '📥 Запросы в Друзья',
    my_friends: '✅ Мои Друзья',
    add_friend: 'Добавить в Друзья',
    remove_friend: 'Удалить из Друзей',
    accept: 'Принять',
    decline: 'Отклонить',
    online: 'Онлайн',
    offline: 'Оффлайн',
    
    // Chat
    chat_title: '💬 Живой Чат',
    private_chat: '💬 Личный Чат',
    type_message: 'Напишите сообщение...',
    
    // Sections
    section_pdfs: 'Формы / PDFs',
    section_games: '🎮 Игры',

    // Games UI
    games_title: '🎮 Игры',
    games_scroll_back: '◀ Назад',
    games_scroll_next: 'Далее ▶',
    play: 'Играть',
    ranking: '🏆 Рейтинг',
    score: 'Очки',
    highscore: 'Рекорд',
    
    // Battle Pass
    bp_title: '🏆 Боевой Пропуск',
    bp_points: 'Очки',
    bp_tier: 'Уровень',
    bp_daily_quests: 'Ежедневные Задания',
    bp_weekly_quests: 'Еженедельные Задания',
    bp_claim: 'Получить',
    bp_claimed: 'Получено',
    
    // Shop
    shop_title: '🛍️ Магазин',
    buy: 'Купить',
    coins: 'Монеты',
    
    // Inventory
    inventory_title: '🎒 Инвентарь',
    no_items: 'Нет предметов'
  },
  
  fr: {
      section_news: 'Actualités',
      chat_title: '💬 Chat en Direct',
      chat_type_message: 'Écrire un message...',
      chat_gif_send: 'Envoyer GIF 🎬',
      chat_gif_url: 'Insérer l’URL du GIF',
      chat_send: 'Envoyer',
      shop_title: '🛍️ Boutique',
      shop_chat_colors_title: '🎨 Couleurs du Nom du Chat',
      shop_chat_colors_desc: 'Changez la couleur de votre nom dans le chat !',
      shop_themes_title: '🌈 Thèmes du Site',
      shop_themes_desc: 'Changez le design de votre site !',
      shop_badges_title: '🎖️ Badges',
      shop_badges_desc: 'Montrez vos distinctions dans le chat !',
      basketball_title: '🏀 Basket',
      basketball_desc: 'Visez avec angle et puissance et marquez !',
      basketball_start: 'Démarrer',
      basketball_shoot: 'Tirer',
      basketball_reset: 'Réinitialiser',
      basketball_ranking: '🏆 Classement',
      basketball_score_label: 'Score :',
      basketball_high_label: 'Record :',
      basketball_help: 'Marquez des points en réussissant des tirs. Nouveau record global.',
      daily_shop_title: '🌟 Boutique Quotidienne',
      daily_shop_subtitle: 'Nouvelles offres chaque jour à 09:00 !',
      daily_shop_next_rotation: '⏰ Prochaine rotation dans :',
      activate_default: 'Activer le Mode Par Défaut',
      activate_dark: 'Activer le Mode Sombre',
      purchased: '✓ Acheté',
      buy: 'Acheter',
      inventory_title: '🎒 Inventaire',
      inv_chat_colors_title: '🎨 Couleurs du Nom du Chat',
      inv_chat_colors_desc: 'Vos couleurs achetées',
      inv_themes_title: '🌈 Thèmes du Site',
      inv_themes_desc: 'Vos thèmes achetés',
      inv_badges_title: '🏅 Badges & Étiquettes',
      inv_badges_desc: 'Badges du Pass de Combat',
      bp_title: '🏆 Pass de Combat',
      bp_status: 'Statut :',
      bp_month: 'Mois :',
      bp_points: 'Points :',
      bp_activate_premium: 'Activer Premium (500 pièces)',
      bp_daily_quests: '📋 Quêtes Quotidiennes',
      bp_weekly_quests: '🌟 Quêtes Hebdomadaires',
    // Navigation
    nav_pdfs: 'PDFs',
    nav_games: 'Jeux',
    nav_news: 'Actualités',
    nav_chat: 'Chat en Direct',
    nav_shop: '🛍️ Boutique',
    nav_inventory: '🎒 Inventaire',
    nav_battlepass: '🏆 Pass de Combat',
    nav_not_logged_in: 'Non connecté',
    nav_login: 'Connexion',
    nav_register: 'S\'inscrire',
    nav_account: 'Mon Compte',
    nav_friends: 'Amis',
    nav_settings: 'Paramètres',
    
    // Settings
    settings_title: '⚙️ Paramètres',
    settings_language_title: '🌐 Langue / Language',
    
    // Common
    close: 'Fermer',
    save: 'Enregistrer',
    cancel: 'Annuler',
    confirm: 'Confirmer',
    delete: 'Supprimer',
    send: 'Envoyer',
    search: 'Rechercher',
    loading: 'Chargement...',
    error: 'Erreur',
    success: 'Succès',
    
    // Auth
    login_title: '🔐 Connexion',
    register_title: '📝 S\'inscrire',
    email: 'E-mail',
    password: 'Mot de passe',
    nickname: 'Pseudo',
    logout: 'Déconnexion',
    
    // Account
    account_title: '👤 Mon Compte',
    profile_picture: 'Photo de Profil',
    change_nickname: 'Changer le Pseudo',
    change_password: 'Changer le Mot de Passe',
    delete_account: 'Supprimer le Compte',
    
    // Friends
    friends_title: '👥 Amis',
    search_friend: '🔍 Rechercher un Ami',
    friend_requests: '📥 Demandes d\'Ami',
    my_friends: '✅ Mes Amis',
    add_friend: 'Ajouter un Ami',
    remove_friend: 'Retirer un Ami',
    accept: 'Accepter',
    decline: 'Refuser',
    online: 'En ligne',
    offline: 'Hors ligne',
    
    // Chat
    chat_title: '💬 Chat en Direct',
    private_chat: '💬 Chat Privé',
    type_message: 'Écrire un message...',
    
    // Sections
    section_pdfs: 'Formulaires / PDFs',
    section_games: '🎮 Jeux',

    // Games UI
    games_title: '🎮 Jeux',
    games_scroll_back: '◀ Précédent',
    games_scroll_next: 'Suivant ▶',
    play: 'Jouer',
    ranking: '🏆 Classement',
    score: 'Score',
    highscore: 'Meilleur Score',
    
    // Battle Pass
    bp_title: '🏆 Pass de Combat',
    bp_points: 'Points',
    bp_tier: 'Niveau',
    bp_daily_quests: 'Quêtes Quotidiennes',
    bp_weekly_quests: 'Quêtes Hebdomadaires',
    bp_claim: 'Réclamer',
    bp_claimed: 'Réclamé',
    
    // Shop
    shop_title: '🛍️ Boutique',
    buy: 'Acheter',
    coins: 'Pièces',
    
    // Inventory
    inventory_title: '🎒 Inventaire',
    no_items: 'Aucun objet'
  },
  
  it: {
      section_news: 'Notizie',
      chat_title: '💬 Chat dal Vivo',
      chat_type_message: 'Scrivi un messaggio...',
      chat_gif_send: 'Invia GIF 🎬',
      chat_gif_url: 'Inserisci URL GIF',
      chat_send: 'Invia',
      shop_title: '🛍️ Negozio',
      shop_chat_colors_title: '🎨 Colori del Nome in Chat',
      shop_chat_colors_desc: 'Cambia il colore del tuo nome in chat!',
      shop_themes_title: '🌈 Temi del Sito',
      shop_themes_desc: 'Cambia il design del sito!',
      shop_badges_title: '🎖️ Badge',
      shop_badges_desc: 'Mostra i tuoi riconoscimenti in chat!',
      basketball_title: '🏀 Basket',
      basketball_desc: 'Mira con angolo e potenza e segna!',
      basketball_start: 'Avvia',
      basketball_shoot: 'Tira',
      basketball_reset: 'Reset',
      basketball_ranking: '🏆 Classifica',
      basketball_score_label: 'Punti:',
      basketball_high_label: 'Record:',
      basketball_help: 'Segna punti con i tiri. Nuovo record salvato globale.',
      daily_shop_title: '🌟 Negozio Giornaliero',
      daily_shop_subtitle: 'Nuove offerte ogni giorno alle 09:00!',
      daily_shop_next_rotation: '⏰ Prossima rotazione in:',
      activate_default: 'Attiva Standard',
      activate_dark: 'Attiva Modalità Scura',
      purchased: '✓ Acquistato',
      buy: 'Compra',
      inventory_title: '🎒 Inventario',
      inv_chat_colors_title: '🎨 Colori del Nome in Chat',
      inv_chat_colors_desc: 'I tuoi colori acquistati',
      inv_themes_title: '🌈 Temi del Sito',
      inv_themes_desc: 'I tuoi temi acquistati',
      inv_badges_title: '🏅 Badge & Nametag',
      inv_badges_desc: 'Badge del Battle Pass',
      bp_title: '🏆 Pass Battaglia',
      bp_status: 'Stato:',
      bp_month: 'Mese:',
      bp_points: 'Punti:',
      bp_activate_premium: 'Attiva Premium (500 monete)',
      bp_daily_quests: '📋 Missioni Giornaliere',
      bp_weekly_quests: '🌟 Missioni Settimanali',
    // Navigation
    nav_pdfs: 'PDFs',
    nav_games: 'Giochi',
    nav_news: 'Notizie',
    nav_chat: 'Chat dal Vivo',
    nav_shop: '🛍️ Negozio',
    nav_inventory: '🎒 Inventario',
    nav_battlepass: '🏆 Pass Battaglia',
    nav_not_logged_in: 'Non connesso',
    nav_login: 'Accedi',
    nav_register: 'Registrati',
    nav_account: 'Il Mio Account',
    nav_friends: 'Amici',
    nav_settings: 'Impostazioni',
    
    // Settings
    settings_title: '⚙️ Impostazioni',
    settings_language_title: '🌐 Lingua / Language',
    
    // Common
    close: 'Chiudi',
    save: 'Salva',
    cancel: 'Annulla',
    confirm: 'Conferma',
    delete: 'Elimina',
    send: 'Invia',
    search: 'Cerca',
    loading: 'Caricamento...',
    error: 'Errore',
    success: 'Successo',
    
    // Auth
    login_title: '🔐 Accedi',
    register_title: '📝 Registrati',
    email: 'E-mail',
    password: 'Password',
    nickname: 'Soprannome',
    logout: 'Disconnetti',
    
    // Account
    account_title: '👤 Il Mio Account',
    profile_picture: 'Foto Profilo',
    change_nickname: 'Cambia Soprannome',
    change_password: 'Cambia Password',
    delete_account: 'Elimina Account',
    
    // Friends
    friends_title: '👥 Amici',
    search_friend: '🔍 Cerca Amico',
    friend_requests: '📥 Richieste di Amicizia',
    my_friends: '✅ I Miei Amici',
    add_friend: 'Aggiungi Amico',
    remove_friend: 'Rimuovi Amico',
    accept: 'Accetta',
    decline: 'Rifiuta',
    online: 'Online',
    offline: 'Offline',
    
    // Chat
    chat_title: '💬 Chat dal Vivo',
    private_chat: '💬 Chat Privata',
    type_message: 'Scrivi un messaggio...',
    
    // Sections
    section_pdfs: 'Moduli / PDFs',
    section_games: '🎮 Giochi',

    // Games UI
    games_title: '🎮 Giochi',
    games_scroll_back: '◀ Indietro',
    games_scroll_next: 'Avanti ▶',
    play: 'Gioca',
    ranking: '🏆 Classifica',
    score: 'Punteggio',
    highscore: 'Punteggio Massimo',
    
    // Battle Pass
    bp_title: '🏆 Pass Battaglia',
    bp_points: 'Punti',
    bp_tier: 'Livello',
    bp_daily_quests: 'Missioni Giornaliere',
    bp_weekly_quests: 'Missioni Settimanali',
    bp_claim: 'Riscuoti',
    bp_claimed: 'Riscosso',
    
    // Shop
    shop_title: '🛍️ Negozio',
    buy: 'Compra',
    coins: 'Monete',
    
    // Inventory
    inventory_title: '🎒 Inventario',
    no_items: 'Nessun oggetto'
  }
};
// Gemeinsame Keys für allgemeine Aktionen und Spiele-UI ergänzen
translations.de = { ...(translations.de || {}),
  allow: 'Zulassen', deny: 'Ablehnen', save: 'Speichern', activate: 'Aktivieren',
  ranking: '🏆 Rangliste', difficulty: 'Schwierigkeit',
  game_start: 'Start', game_pause: 'Pause', game_reset: 'Neu',
  tab_all: 'Alle', tab_friends: 'Freunde',
  diff_easy: 'Leicht', diff_medium: 'Mittel', diff_hard: 'Schwer', diff_pro: 'Profi'
};
translations.en = { ...(translations.en || {}),
  allow: 'Allow', deny: 'Deny', save: 'Save', activate: 'Activate',
  ranking: '🏆 Ranking', difficulty: 'Difficulty',
  game_start: 'Start', game_pause: 'Pause', game_reset: 'Reset',
  tab_all: 'All', tab_friends: 'Friends',
  diff_easy: 'Easy', diff_medium: 'Medium', diff_hard: 'Hard', diff_pro: 'Pro',
  memory_title: '🧠 Memory',
  memory_desc: 'Find all pairs in as few moves as possible.',
  memory_moves_label: 'Moves:',
  memory_best_label: 'Best:',
  memory_start: 'Start',
  memory_reset: 'Reset',
  memory_ranking: '🏆 Ranking',
  memory_ranking_title: '🏆 Memory Ranking (Top 10)',
  memory_help: 'Click two cards to reveal. Fewer moves = better.',
  memory_difficulty_label: 'Difficulty:',
  memory_diff_noob: 'Noob',
  memory_diff_profi: 'Profi',
  memory_diff_champion: 'Champion'
};
translations.es = { ...(translations.es || {}),
  allow: 'Permitir', deny: 'Denegar', save: 'Guardar', activate: 'Activar',
  ranking: '🏆 Clasificación', difficulty: 'Dificultad',
  game_start: 'Iniciar', game_pause: 'Pausa', game_reset: 'Reiniciar',
  tab_all: 'Todos', tab_friends: 'Amigos',
  diff_easy: 'Fácil', diff_medium: 'Media', diff_hard: 'Difícil', diff_pro: 'Pro',
  memory_title: '🧠 Memory',
  memory_desc: 'Encuentra todas las parejas con pocos movimientos.',
  memory_moves_label: 'Movs:',
  memory_best_label: 'Mejor:',
  memory_start: 'Inicio',
  memory_reset: 'Nuevo',
  memory_ranking: '🏆 Clasificación',
  memory_ranking_title: '🏆 Ranking Memory (Top 10)',
  memory_help: 'Haz clic en dos cartas para revelar. Menos movimientos = mejor.',
  memory_difficulty_label: 'Dificultad:',
  memory_diff_noob: 'Principiante',
  memory_diff_profi: 'Experto',
  memory_diff_champion: 'Campeón'
};
translations.ru = { ...(translations.ru || {}),
  allow: 'Разрешить', deny: 'Отклонить', save: 'Сохранить', activate: 'Активировать',
  ranking: '🏆 Рейтинг', difficulty: 'Сложность',
  game_start: 'Старт', game_pause: 'Пауза', game_reset: 'Сброс',
  tab_all: 'Все', tab_friends: 'Друзья',
  diff_easy: 'Легко', diff_medium: 'Средне', diff_hard: 'Сложно', diff_pro: 'Профи',
  memory_title: '🧠 Мемори',
  memory_desc: 'Найди все пары за минимальное число ходов.',
  memory_moves_label: 'Ходы:',
  memory_best_label: 'Лучший:',
  memory_start: 'Старт',
  memory_reset: 'Сброс',
  memory_ranking: '🏆 Рейтинг',
  memory_ranking_title: '🏆 Рейтинг Memory (Топ 10)',
  memory_help: 'Открывай пары карт. Меньше ходов = лучше.',
  memory_difficulty_label: 'Сложность:',
  memory_diff_noob: 'Новичок',
  memory_diff_profi: 'Профи',
  memory_diff_champion: 'Чемпион'
};
translations.fr = { ...(translations.fr || {}),
  allow: 'Autoriser', deny: 'Refuser', save: 'Enregistrer', activate: 'Activer',
  ranking: '🏆 Classement', difficulty: 'Difficulté',
  game_start: 'Démarrer', game_pause: 'Pause', game_reset: 'Réinitialiser',
  tab_all: 'Tous', tab_friends: 'Amis',
  diff_easy: 'Facile', diff_medium: 'Moyen', diff_hard: 'Difficile', diff_pro: 'Pro',
  memory_title: '🧠 Memory',
  memory_desc: 'Trouve toutes les paires avec peu de coups.',
  memory_moves_label: 'Coups :',
  memory_best_label: 'Meilleur :',
  memory_start: 'Démarrer',
  memory_reset: 'Nouveau',
  memory_ranking: '🏆 Classement',
  memory_ranking_title: '🏆 Classement Memory (Top 10)',
  memory_help: 'Clique sur deux cartes pour révéler. Moins de coups = mieux.',
  memory_difficulty_label: 'Difficulté :',
  memory_diff_noob: 'Débutant',
  memory_diff_profi: 'Pro',
  memory_diff_champion: 'Champion'
};
translations.it = { ...(translations.it || {}),
  allow: 'Consenti', deny: 'Nega', save: 'Salva', activate: 'Attiva',
  ranking: '🏆 Classifica', difficulty: 'Difficoltà',
  game_start: 'Avvia', game_pause: 'Pausa', game_reset: 'Reset',
  tab_all: 'Tutti', tab_friends: 'Amici',
  diff_easy: 'Facile', diff_medium: 'Medio', diff_hard: 'Difficile', diff_pro: 'Pro',
  memory_title: '🧠 Memory',
  memory_desc: 'Trova tutte le coppie con pochi movimenti.',
  memory_moves_label: 'Mosse:',
  memory_best_label: 'Migliore:',
  memory_start: 'Start',
  memory_reset: 'Nuovo',
  memory_ranking: '🏆 Classifica',
  memory_ranking_title: '🏆 Classifica Memory (Top 10)',
  memory_help: 'Clicca due carte per rivelarle. Meno mosse = meglio.',
  memory_difficulty_label: 'Difficoltà:',
  memory_diff_noob: 'Noob',
  memory_diff_profi: 'Profi',
  memory_diff_champion: 'Campione'
};

// Sprache Vorschau (ohne Speichern)
function previewLanguage(lang) {
  currentLanguage = lang;
  applyTranslations();
}

function getSavedLanguage() {
  try { return localStorage.getItem('language') || 'de'; } catch { return 'de'; }
}

// Allow: Auswahl speichern und Seite kurz neu laden
function confirmLanguageAllow() {
  const selectEl = document.getElementById('languageSelect');
  const chosen = (selectEl && selectEl.value) ? selectEl.value : currentLanguage || 'de';
  try { localStorage.setItem('language', chosen); } catch {}
  // Reload für konsistenten Zustand
  setTimeout(() => { location.reload(); }, 150);
}

// Deny: Vorschau verwerfen, zur gespeicherten Sprache zurück
function denyLanguage() {
  const saved = getSavedLanguage();
  currentLanguage = saved;
  const selectEl = document.getElementById('languageSelect');
  if (selectEl) selectEl.value = saved;
  applyTranslations();
}

// Make functions available for inline HTML handlers
window.previewLanguage = previewLanguage;
window.confirmLanguageAllow = confirmLanguageAllow;
window.denyLanguage = denyLanguage;

// Übersetzungen anwenden
function applyTranslations() {
  const dict = translations[currentLanguage] || translations['de'] || {};

  // data-i18n: Textinhalte
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    const val = dict[key];
    if (typeof val === 'string') {
      el.textContent = val;
    }
  });

  // data-i18n-placeholder: Platzhalter
  document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
    const key = el.getAttribute('data-i18n-placeholder');
    const val = dict[key];
    if (typeof val === 'string') {
      el.setAttribute('placeholder', val);
    }
  });

  // data-i18n-aria-label: ARIA Labels
  document.querySelectorAll('[data-i18n-aria-label]').forEach(el => {
    const key = el.getAttribute('data-i18n-aria-label');
    const val = dict[key];
    if (typeof val === 'string') {
      el.setAttribute('aria-label', val);
    }
  });

  // Dynamische Elemente
  const navUserInfo = document.getElementById('navUserInfo');
  if (navUserInfo && !currentUser && dict.nav_not_logged_in) {
    navUserInfo.textContent = dict.nav_not_logged_in;
  }
}

// Sprache beim Laden wiederherstellen
function loadLanguage() {
  const savedLang = getSavedLanguage();
  currentLanguage = savedLang;
  const selectEl = document.getElementById('languageSelect');
  if (selectEl) {
    selectEl.value = savedLang;
  }
  applyTranslations();
}

// Initialize language on first load
loadLanguage();

// Auto-Markierung häufiger Texte für Übersetzung
function initAutoI18n() {
  // Direktes Mapping bekannter Elemente
  const map = [
    { sel: '#settingsModal h2', key: 'settings_title' },
    { sel: '#settingsModal h3', key: 'settings_language_title' },
    { sel: '#settingsModal button[onclick="closeSettings()"]', key: 'close' },
    { sel: '#loginBtn', key: 'nav_login' },
    { sel: '#registerBtn', key: 'nav_register' },
    { sel: '#accountBtn', key: 'nav_account' },
    { sel: '#friendsBtn', key: 'nav_friends' },
    { sel: '#settingsBtn', key: 'nav_settings' },
    { sel: '#langAllowBtn', key: 'confirm' },
    { sel: '#langDenyBtn', key: 'cancel' }
  ];
  map.forEach(({ sel, key }) => {
    const el = document.querySelector(sel);
    if (el) el.setAttribute('data-i18n', key);
  });

  // Platzhalter-Mapping
  const placeholders = [
    { id: 'regEmail', key: 'email' },
    { id: 'regPass', key: 'password' },
    { id: 'regNick', key: 'nickname' },
    { id: 'logEmail', key: 'email' },
    { id: 'logPass', key: 'password' },
    { id: 'chatText', key: 'type_message' },
    { id: 'privateChatInput', key: 'type_message' },
    { id: 'privateGifInput', key: 'search' }
  ];
  placeholders.forEach(({ id, key }) => {
    const el = document.getElementById(id);
    if (el) el.setAttribute('data-i18n-placeholder', key);
  });

  // Auto-Tagging häufiger deutscher Texte (Buttons/Labels)
  const mapTextToKey = new Map([
    ['Zulassen', 'allow'],
    ['Ablehnen', 'deny'],
    ['Speichern', 'save'],
    ['Kaufen', 'buy'],
    ['Aktivieren', 'activate'],
    ['Start', 'game_start'],
    ['Pause', 'game_pause'],
    ['Neu', 'game_reset'],
    ['Zurücksetzen', 'game_reset'],
    ['Rangliste', 'ranking'],
    ['Schwierigkeit', 'difficulty'],
    ['Alle', 'tab_all'],
    ['Freunde', 'tab_friends'],
    ['leicht', 'diff_easy'],
    ['mittel', 'diff_medium'],
    ['schwer', 'diff_hard'],
    ['profi', 'diff_pro'],
    // Häufige Spiel-/Status-Texte
    ['Punkte', 'score'],
    ['Highscore', 'highscore'],
    ['Beste Serie', 'best_streak'],
    ['Zeit', 'time'],
    ['Gegner', 'opponent'],
    ['Steuerung', 'controls'],
    ['Modus', 'mode'],
  ]);
  document.querySelectorAll('button, .scroll-button, label, h3, h4').forEach(el => {
    if (el.hasAttribute('data-i18n')) return;
    const text = (el.textContent || '').trim().toLowerCase();
    for (const [src, key] of mapTextToKey.entries()) {
      if (text === src.toLowerCase()) {
        el.setAttribute('data-i18n', key);
        break;
      }
    }
  });
}

document.addEventListener('DOMContentLoaded', () => {
  initAutoI18n();
  applyTranslations();
  // Initialize Advent Calendar and Notifications
  initAdventCalendar();
  initNotificationsFeed();
  renderAdventInline();
});

// Öffne Settings und setze aktuelle Sprache
window.openSettings = function() {
  document.getElementById('settingsModal').style.display = 'flex';
  const selectEl = document.getElementById('languageSelect');
  if (selectEl) {
    selectEl.value = currentLanguage;
  }
  
  // Load Christmas music setting
  const musicToggle = document.getElementById('christmasMusicToggle');
  if (musicToggle) {
    const musicEnabled = localStorage.getItem('christmasMusicEnabled') === 'true';
    musicToggle.checked = musicEnabled;
  }
};

/////////////////////////////////////////////////////////////////////////////
// Christmas Background Music System 🎵🎄
/////////////////////////////////////////////////////////////////////////////

let christmasAudio = null;
let christmasMusicEnabled = false;

// Initialize Christmas music on page load
function initChristmasMusic() {
  const savedVolume = localStorage.getItem('musicVolume') || '50';
  const slider = document.getElementById('musicVolumeSlider');
  if (slider) {
    slider.value = savedVolume;
    document.getElementById('musicVolumeLabel').textContent = savedVolume + '%';
  }
  
  musicVolume = parseFloat(savedVolume) / 100;
  christmasMusicEnabled = false;
  // Hintergrundmusik deaktiviert
}

function playChristmasMusic() {
  // Weihnachtsmusik deaktiviert
  return;
}

function stopChristmasMusic() {
  // Weihnachtsmusik deaktiviert
  return;
}

let musicVolume = parseFloat(localStorage.getItem('musicVolume') || '50') / 100;
let globalMasterGain = null;

window.updateMusicVolume = function(value) {
  musicVolume = value / 100;
  localStorage.setItem('musicVolume', value);
  document.getElementById('musicVolumeLabel').textContent = value + '%';
  
  // Lautstärke der laufenden Musik aktualisieren
  if (globalMasterGain) {
    globalMasterGain.gain.value = musicVolume;
  }
};

// Generate looping Christmas melody using Web Audio API
function generateChristmasMelody() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const masterGain = ctx.createGain();
  masterGain.gain.value = musicVolume * 0.5;
  window.currentMusicGain = masterGain;
  masterGain.connect(ctx.destination);
  
  // "Jingle Bells" melody notes (simplified)
  const melody = [
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.5 },
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.5 },
    { note: 'E4', duration: 0.25 },
    { note: 'G4', duration: 0.25 },
    { note: 'C4', duration: 0.25 },
    { note: 'D4', duration: 0.25 },
    { note: 'E4', duration: 1 },
    { note: 'F4', duration: 0.25 },
    { note: 'F4', duration: 0.25 },
    { note: 'F4', duration: 0.25 },
    { note: 'F4', duration: 0.25 },
    { note: 'F4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'D4', duration: 0.25 },
    { note: 'D4', duration: 0.25 },
    { note: 'E4', duration: 0.25 },
    { note: 'D4', duration: 0.5 },
    { note: 'G4', duration: 0.5 }
  ];
  
  const noteFrequencies = {
    'C4': 261.63, 'D4': 293.66, 'E4': 329.63,
    'F4': 349.23, 'G4': 392.00, 'A4': 440.00,
    'B4': 493.88, 'C5': 523.25
  };
  
  let currentTime = ctx.currentTime;
  const loopDuration = melody.reduce((sum, n) => sum + n.duration, 0);
  
  function scheduleLoop(startTime) {
    let time = startTime;
    
    melody.forEach(({ note, duration }) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.type = 'sine';
      osc.frequency.value = noteFrequencies[note];
      
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(0.3, time + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
      
      osc.connect(gain);
      gain.connect(masterGain);
      
      osc.start(time);
      osc.stop(time + duration);
      
      time += duration;
    });
    
    return time;
  }
  
  // Schedule multiple loops in advance
  function keepScheduling() {
    if (!christmasMusicEnabled) return;
    
    const nextLoopTime = scheduleLoop(currentTime);
    currentTime = nextLoopTime;
    
    setTimeout(keepScheduling, loopDuration * 800); // Schedule next loop
  }
  
  keepScheduling();
  
  return {
    stop: () => {
      christmasMusicEnabled = false;
      ctx.close();
    }
  };
}

// Initialize on page load (default OFF, user must enable manually)
document.addEventListener('DOMContentLoaded', () => {
  const saved = localStorage.getItem('christmasMusicEnabled');
  christmasMusicEnabled = false;
  // Musik startet NICHT automatisch
});

/////////////////////////////////////////////////////////////////////////////
// (Verifizierung entfernt)

// Presence heartbeat (Online/Offline via lastActive)
let __presenceInterval = null;
let __presenceHandlersInstalled = false;

/////////////////////////////////////////////////////////////////////////////
// Advent Calendar Logic
/////////////////////////////////////////////////////////////////////////////

function openAdvent() {
  const modal = document.getElementById('adventModal');
  if (modal) modal.style.display = 'flex';
}

function closeAdvent() {
  const modal = document.getElementById('adventModal');
  if (modal) modal.style.display = 'none';
}

function initAdventCalendar() {
  const grid = document.getElementById('adventGrid');
  if (!grid) return;
  grid.innerHTML = '';
  const today = new Date();
  const year = today.getFullYear();
  // Fetch claims to mark claimed doors
  let claimedSet = new Set();
  (async () => {
    try {
      if (currentUser) {
        const claimsSnap = await getDocs(collection(db, 'adventClaims', currentUser.uid, 'claims'));
        claimedSet = new Set(claimsSnap.docs.map(d => d.id));
      }
    } catch(e) {}
    for (let day = 1; day <= 24; day++) {
      const door = document.createElement('button');
      door.className = 'advent-door';
      door.innerHTML = `<span class="label">${day}</span><span class="corner">🎁</span>`;
      const mm = '12';
      const dd = String(day).padStart(2,'0');
      const id = `${year}-${mm}-${dd}`;
      const dateObj = new Date(year, 11, day); // December
      const isPastOrToday = today >= dateObj;
      const isToday = today.getDate() === day && today.getMonth() === 11;
      const isClaimed = claimedSet.has(id);
      if (!isPastOrToday) {
        door.disabled = true;
        door.classList.add('locked');
        door.querySelector('.corner').textContent = '🔒';
      } else if (isClaimed) {
        door.classList.add('claimed');
        door.querySelector('.corner').textContent = '✅';
        door.onclick = () => showNotification('Schon eingesammelt', `Tür ${day} wurde bereits geöffnet`);
      } else if (isToday) {
        door.onclick = async () => { door.classList.add('opening'); await claimTodayAdvent(); initAdventCalendar(); };
        door.querySelector('.corner').textContent = '✨';
      } else {
        door.onclick = () => showNotification('Nicht heute', `Tür ${day} kann nicht mehr geöffnet werden`);
        door.querySelector('.corner').textContent = '📅';
      }
      grid.appendChild(door);
    }
  })();
  updateAdventStreakUI();
}

// Inline Advent Preview in Battle Pass section
function renderAdventInline() {
  const bp = document.getElementById('battlepass');
  if (!bp) return;
  let el = document.getElementById('adventInline');
  if (!el) {
    el = document.createElement('div');
    el.id = 'adventInline';
    el.className = 'card';
    el.style.marginTop = '10px';
    el.innerHTML = `
      <h3>🎁 Adventskalender</h3>
      <p id="adventInlineStreak" style="opacity:0.8;">Streak: 0 Tage</p>
      <div id="adventInlineGrid" style="display:grid; grid-template-columns: repeat(8, 1fr); gap:6px;"></div>
      <div style="margin-top:8px; display:flex; gap:6px;">
        <button onclick="openAdvent()">Öffnen</button>
        <button onclick="claimTodayAdvent()">Heute claimen</button>
      </div>
    `;
    bp.appendChild(el);
  }
  const grid = document.getElementById('adventInlineGrid');
  if (!grid) return;
  grid.innerHTML = '';
  const today = new Date();
  const year = today.getFullYear();
  (async () => {
    let claimedSet = new Set();
    try {
      if (currentUser) {
        const claimsSnap = await getDocs(collection(db, 'adventClaims', currentUser.uid, 'claims'));
        claimedSet = new Set(claimsSnap.docs.map(d => d.id));
      }
    } catch(e) {}
    for (let day = 1; day <= 24; day++) {
      const btn = document.createElement('button');
      btn.className = 'advent-door';
      btn.innerHTML = `<span class="label">${day}</span><span class="corner">🎁</span>`;
      const mm = '12';
      const dd = String(day).padStart(2,'0');
      const id = `${year}-${mm}-${dd}`;
      const dateObj = new Date(year, 11, day);
      const isPastOrToday = today >= dateObj;
      const isToday = today.getDate() === day && today.getMonth() === 11;
      const isClaimed = claimedSet.has(id);
      if (!isPastOrToday) { btn.disabled = true; btn.classList.add('locked'); btn.querySelector('.corner').textContent = '🔒'; }
      else if (isClaimed) { btn.classList.add('claimed'); btn.querySelector('.corner').textContent = '✅'; }
      else if (isToday) { btn.querySelector('.corner').textContent = '✨'; btn.onclick = async () => { btn.classList.add('opening'); await claimTodayAdvent(); renderAdventInline(); }; }
      else { btn.querySelector('.corner').textContent = '📅'; }
      grid.appendChild(btn);
    }
  })();
  // Update streak text
  (async () => {
    const elStreak = document.getElementById('adventInlineStreak');
    if (!elStreak || !currentUser) return;
    try {
      const claimsSnap = await getDocs(collection(db, 'adventClaims', currentUser.uid, 'claims'));
      const claimedDays = claimsSnap.docs.map(d => d.id);
      const streak = computeAdventStreak(claimedDays);
      elStreak.textContent = `Streak: ${streak} Tage`;
    } catch(e) { elStreak.textContent = 'Streak: 0 Tage'; }
  })();
}

async function updateAdventStreakUI() {
  const el = document.getElementById('adventStreakInfo');
  if (!el || !currentUser) return;
  try {
    const claimsSnap = await getDocs(collection(db, 'adventClaims', currentUser.uid, 'claims'));
    const claimedDays = claimsSnap.docs.map(d => d.id);
    const streak = computeAdventStreak(claimedDays);
    el.textContent = `Streak: ${streak} Tage`;
  } catch(e) {
    el.textContent = 'Streak: 0 Tage';
  }
}

function computeAdventStreak(claimedIds) {
  // claimedIds are strings like '2025-12-01'
  if (!claimedIds || claimedIds.length === 0) return 0;
  const sorted = claimedIds.sort();
  let streak = 0;
  let prev = null;
  for (const id of sorted) {
    const d = new Date(id);
    if (!prev) {
      streak = 1; prev = d; continue;
    }
    const diff = (d - prev) / (1000*60*60*24);
    if (diff === 1) { streak++; prev = d; } else { streak = 1; prev = d; }
  }
  return streak;
}

// Advent Rewards per Day (ab Tag 3 exklusive Items)
const ADVENT_REWARDS = {
  1: { coins: 50, bp: 1 },
  2: { coins: 50, bp: 1 },
  3: { coins: 75, bp: 1, chatColor: { id: 'advent_snow_white', name: 'Schneeweiß', color: '#F0F8FF', exclusive: true } },
  4: { coins: 50, bp: 1 },
  5: { coins: 100, bp: 2 },
  6: { coins: 50, bp: 1, theme: { id: 'advent_crystal_palace', name: 'Kristallpalast', preview: 'linear-gradient(135deg, #e8f4f8, #c5e1e6, #a8d8e0)', exclusive: true } },
  7: { coins: 50, bp: 1 },
  8: { coins: 75, bp: 1, music: { id: 'advent_carol_bells', name: 'Carol of the Bells', demo: '🎄' } },
  9: { coins: 50, bp: 1 },
  10: { coins: 100, bp: 2, badge: { id: 'advent_snowflake', name: 'Schneeflocke', icon: '❄️', exclusive: true } },
  11: { coins: 50, bp: 1 },
  12: { coins: 150, bp: 2, chatColor: { id: 'advent_christmas_red', name: 'Weihnachtsrot', color: '#C41E3A', exclusive: true } },
  13: { coins: 50, bp: 1 },
  14: { coins: 75, bp: 1, font: { id: 'advent_festive_script', name: 'Festive Script', css: 'font-family: cursive; letter-spacing: 1px; font-style: italic;' } },
  15: { coins: 50, bp: 1 },
  16: { coins: 100, bp: 2, theme: { id: 'advent_northern_lights', name: 'Nordlichter', preview: 'linear-gradient(135deg, #1a237e, #4a148c, #004d40)', exclusive: true } },
  17: { coins: 50, bp: 1 },
  18: { coins: 200, bp: 3, chatColor: { id: 'advent_golden_star', name: 'Goldener Stern', color: 'linear-gradient(90deg, #FFD700, #FFA500, #FFD700)', exclusive: true } },
  19: { coins: 50, bp: 1 },
  20: { coins: 75, bp: 1, badge: { id: 'advent_gift_box', name: 'Geschenkbox', icon: '🎁', exclusive: true } },
  21: { coins: 50, bp: 1, music: { id: 'advent_sleigh_ride', name: 'Sleigh Ride', demo: '🛷' } },
  22: { coins: 100, bp: 2 },
  23: { coins: 75, bp: 1, font: { id: 'advent_candy_cane', name: 'Candy Cane', css: 'font-family: "Comic Sans MS", cursive; color: #ff0000; text-shadow: 1px 1px 0 #fff;' } },
  24: { coins: 500, bp: 5, chatColor: { id: 'advent_christmas_magic', name: 'Weihnachtszauber', color: 'linear-gradient(90deg, #ff0000, #00ff00, #ffffff, #ff0000)', exclusive: true }, theme: { id: 'advent_holy_night', name: 'Heilige Nacht', preview: 'linear-gradient(135deg, #0a1930, #1e3a5f, #0d2540)', exclusive: true }, badge: { id: 'advent_santa_hat', name: 'Weihnachtsmann-Mütze', icon: '🎅', exclusive: true } }
};

// Prepare merge function; will be called after catalogs are defined
function mergeAdventRewardsIntoCatalogs(){
  try {
    const days = Object.keys(ADVENT_REWARDS || {});
    for (const d of days) {
      const r = ADVENT_REWARDS[d];
      if (r && r.chatColor) {
        if (!CHAT_COLORS.find(c => c.id === r.chatColor.id)) {
          CHAT_COLORS.push(r.chatColor);
        }
      }
      if (r && r.theme) {
        if (!WEBSITE_THEMES.find(t => t.id === r.theme.id)) {
          WEBSITE_THEMES.push({
            id: r.theme.id,
            name: r.theme.name,
            price: 0,
            preview: r.theme.preview || '#000',
            accent: r.theme.accent || '#0099ff',
            bg: r.theme.bg || '#111',
            exclusive: true
          });
        }
      }
    }
  } catch (e) {
    console.warn('mergeAdventRewardsIntoCatalogs failed:', e);
  }
}

async function claimTodayAdvent() {
  if (!currentUser) { showNotification('Fehler','Bitte einloggen!'); return; }
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth()+1).padStart(2,'0');
  const dd = String(today.getDate()).padStart(2,'0');
  const id = `${yyyy}-${mm}-${dd}`;
  const day = today.getDate();

  const claimRef = doc(db, 'adventClaims', currentUser.uid, 'claims', id);
  const claimDoc = await getDoc(claimRef);
  if (claimDoc.exists()) {
    showNotification('Schon eingesammelt','Heute bereits claimt!');
    return;
  }

  // Get reward for today
  const reward = ADVENT_REWARDS[day] || { coins: 50, bp: 1 };
  
  // Save claim
  await setDoc(claimRef, { ts: serverTimestamp(), day, reward });
  
  // Give coins and BP
  await addCoins(reward.coins);
  await updateBPQuestProgress('daily', reward.bp);
  
  let rewardText = `+${reward.coins} Münzen, +${reward.bp} BP`;
  
  // Give exclusive items
  if (reward.chatColor) {
    if (!userInventory.chatColorsOwned) userInventory.chatColorsOwned = [];
    if (!userInventory.chatColorsOwned.includes(reward.chatColor.id)) {
      userInventory.chatColorsOwned.push(reward.chatColor.id);
      // Add to CHAT_COLORS if not exists
      if (!CHAT_COLORS.find(c => c.id === reward.chatColor.id)) {
        CHAT_COLORS.push(reward.chatColor);
      }
      // Persist also in inventory subcollection for durability
      try {
        const colorRef = doc(db, 'inventory', currentUser.uid, 'chatColors', reward.chatColor.id);
        const colorSnap = await getDoc(colorRef);
        if (!colorSnap.exists()) {
          await setDoc(colorRef, { ts: Date.now(), name: reward.chatColor.name, color: reward.chatColor.color });
        }
      } catch (_) {}
      rewardText += `\n🎨 ${reward.chatColor.name}`;
    }
  }
  
  if (reward.theme) {
    if (!userInventory.themesOwned) userInventory.themesOwned = [];
    if (!userInventory.themesOwned.includes(reward.theme.id)) {
      userInventory.themesOwned.push(reward.theme.id);
      // Add to WEBSITE_THEMES if not exists
      if (!WEBSITE_THEMES.find(t => t.id === reward.theme.id)) {
        WEBSITE_THEMES.push(reward.theme);
      }
      // Persist also in inventory subcollection for durability
      try {
        const themeRef = doc(db, 'inventory', currentUser.uid, 'themes', reward.theme.id);
        const themeSnap = await getDoc(themeRef);
        if (!themeSnap.exists()) {
          await setDoc(themeRef, { ts: Date.now(), name: reward.theme.name, preview: reward.theme.preview || '' });
        }
      } catch (_) {}
      rewardText += `\n🌈 ${reward.theme.name}`;
    }
  }
  
  if (reward.badge) {
    if (!userInventory.badges) userInventory.badges = [];
    if (!userInventory.badges.find(b => b.id === reward.badge.id)) {
      userInventory.badges.push(reward.badge);
      // Persist also in inventory subcollection for durability
      try {
        const badgeRef = doc(db, 'inventory', currentUser.uid, 'badges', reward.badge.id);
        const badgeSnap = await getDoc(badgeRef);
        if (!badgeSnap.exists()) {
          await setDoc(badgeRef, { ts: Date.now(), name: reward.badge.name, icon: reward.badge.icon || '' });
        }
      } catch (_) {}
      rewardText += `\n🏅 ${reward.badge.name}`;
    }
  }
  
  if (reward.music) {
    const musicRef = doc(db, 'inventory', currentUser.uid, 'music', reward.music.id);
    const musicSnap = await getDoc(musicRef);
    if (!musicSnap.exists()) {
      await setDoc(musicRef, { ts: Date.now(), name: reward.music.name });
      rewardText += `\n🎵 ${reward.music.name}`;
    }
  }
  
  if (reward.font) {
    const fontRef = doc(db, 'inventory', currentUser.uid, 'fonts', reward.font.id);
    const fontSnap = await getDoc(fontRef);
    if (!fontSnap.exists()) {
      await setDoc(fontRef, { ts: Date.now(), name: reward.font.name });
      rewardText += `\n🖋️ ${reward.font.name}`;
    }
  }
  
  // Save inventory
  await saveInventory();
  
  showNotification('🎁 Advent Türchen geöffnet!', rewardText);
  pushNotification({ type: 'rewards', text: `Tag ${day}: ${rewardText}` });
  updateAdventStreakUI();
  closeAdvent();
  
  // Refresh displays
  displayInventory();
  displayShop();
}

// Backfill/migrate previously claimed Advent rewards into persistent inventory
async function syncAdventClaimsToInventory() {
  try {
    if (!currentUser || !db) return;
    const uid = currentUser.uid;
    const claimsCol = collection(db, 'adventClaims', uid, 'claims');
    const snaps = await getDocs(claimsCol);
    let changed = false;
    for (const docSnap of snaps.docs) {
      const data = docSnap.data() || {};
      const reward = data.reward || {};
      if (reward.chatColor) {
        const c = reward.chatColor;
        if (!CHAT_COLORS.find(x => x.id === c.id)) CHAT_COLORS.push(c);
        if (!userInventory.chatColorsOwned) userInventory.chatColorsOwned = [];
        if (!userInventory.chatColorsOwned.includes(c.id)) {
          userInventory.chatColorsOwned.push(c.id);
          changed = true;
        }
        try {
          const ref = doc(db, 'inventory', uid, 'chatColors', c.id);
          const snap = await getDoc(ref);
          if (!snap.exists()) await setDoc(ref, { ts: Date.now(), name: c.name, color: c.color });
        } catch(_){}
      }
      if (reward.theme) {
        const t = reward.theme;
        if (!WEBSITE_THEMES.find(x => x.id === t.id)) {
          WEBSITE_THEMES.push({ id: t.id, name: t.name, price: 0, preview: t.preview || '#000', accent: t.accent || '#0099ff', bg: t.bg || '#111', exclusive: true });
        }
        if (!userInventory.themesOwned) userInventory.themesOwned = ['default','dark'];
        if (!userInventory.themesOwned.includes(t.id)) {
          userInventory.themesOwned.push(t.id);
          changed = true;
        }
        try {
          const ref = doc(db, 'inventory', uid, 'themes', t.id);
          const snap = await getDoc(ref);
          if (!snap.exists()) await setDoc(ref, { ts: Date.now(), name: t.name, preview: t.preview || '' });
        } catch(_){}
      }
      if (reward.badge) {
        const b = reward.badge;
        if (!userInventory.badges) userInventory.badges = [];
        if (!userInventory.badges.find(x => x.id === b.id)) {
          userInventory.badges.push({ id: b.id, name: b.name, icon: b.icon });
          changed = true;
        }
        try {
          const ref = doc(db, 'inventory', uid, 'badges', b.id);
          const snap = await getDoc(ref);
          if (!snap.exists()) await setDoc(ref, { ts: Date.now(), name: b.name, icon: b.icon || '' });
        } catch(_){}
      }
      if (reward.music) {
        const m = reward.music; try {
          const ref = doc(db, 'inventory', uid, 'music', m.id);
          const snap = await getDoc(ref); if (!snap.exists()) await setDoc(ref, { ts: Date.now(), name: m.name });
        } catch(_){}
      }
      if (reward.font) {
        const f = reward.font; try {
          const ref = doc(db, 'inventory', uid, 'fonts', f.id);
          const snap = await getDoc(ref); if (!snap.exists()) await setDoc(ref, { ts: Date.now(), name: f.name });
        } catch(_){}
      }
    }
    if (changed) {
      await saveInventory();
      displayInventory();
    }
  } catch (e) {
    console.warn('syncAdventClaimsToInventory failed:', e);
  }
}

// Expose for manual triggering via console if needed
try { window.syncAdventClaimsToInventory = syncAdventClaimsToInventory; } catch(_) {}

/////////////////////////////////////////////////////////////////////////////
// Smart Notifications Feed
/////////////////////////////////////////////////////////////////////////////

let __notifications = [];

function initNotificationsFeed() {
  // Optionally show if there are unread notifications
}

function toggleNotificationsFeed() {
  const feed = document.getElementById('notificationsFeed');
  if (!feed) return;
  feed.style.display = (feed.style.display === 'none' || !feed.style.display) ? 'block' : 'none';
  renderNotifications();
}

function pushNotification(type, title, message) {
  const item = { type, title, message, ts: Date.now() };
  __notifications.unshift(item);
  renderNotifications();
}

function renderNotifications() {
  const list = document.getElementById('notificationsList');
  if (!list) return;
  list.innerHTML = __notifications.slice(0,50).map(n => {
    const icon = n.type === 'quest' ? '🎯' : n.type === 'reward' ? '🎁' : n.type === 'friend' ? '👥' : '🔔';
    return `<div style="padding:6px; border-bottom:1px solid rgba(255,255,255,0.15);">
      <div><strong>${icon} ${n.title}</strong></div>
      <div style="opacity:0.85; font-size:12px;">${n.message}</div>
    </div>`;
  }).join('');
}

// Hook into existing showNotification to also populate feed
const __origShowNotification = window.showNotification;
window.showNotification = function(title, message) {
  try { pushNotification('general', title, message); } catch(e){}
  return __origShowNotification ? __origShowNotification(title, message) : null;
};

/////////////////////////////////////////////////////////////////////////////
// Skill Tracks System
/////////////////////////////////////////////////////////////////////////////

const SKILL_TRACKS = {
  snake: { xp: 0, level: 0 },
  flappy: { xp: 0, level: 0 },
  ttt: { xp: 0, level: 0 },
  tower: { xp: 0, level: 0 },
  sudoku: { xp: 0, level: 0 }
};

async function loadSkills() {
  if (!currentUser) return;
  try {
    const snap = await getDoc(doc(db, 'skills', currentUser.uid));
    if (snap.exists()) {
      const data = snap.data();
      Object.assign(SKILL_TRACKS, data || {});
    }
    renderSkillBars();
  } catch(e) { console.warn('Skills laden fehlgeschlagen', e); }
}

async function saveSkills() {
  if (!currentUser) return;
  try { await setDoc(doc(db, 'skills', currentUser.uid), SKILL_TRACKS, { merge: true }); }
  catch(e){ console.warn('Skills speichern fehlgeschlagen', e);} 
}

function addSkillXP(game, amount) {
  const track = SKILL_TRACKS[game];
  if (!track) return;
  track.xp += amount;
  track.level = Math.floor(track.xp / 500);
  saveSkills();
  renderSkillBars();
  pushNotification('reward', 'Skill-Fortschritt', `${game} +${amount} XP (Level ${track.level})`);
}

function renderSkillBars() {
  // Minimal: show under games section header if present
  const gamesSection = document.getElementById('games');
  if (!gamesSection) return;
  let el = document.getElementById('skillTracksBar');
  if (!el) {
    el = document.createElement('div');
    el.id = 'skillTracksBar';
    el.style.cssText = 'margin:10px 0; padding:8px; background:#f1f5f9; border-radius:8px;';
    gamesSection.prepend(el);
  }
  el.innerHTML = Object.keys(SKILL_TRACKS).map(k => {
    const t = SKILL_TRACKS[k];
    const pct = Math.min(100, Math.floor((t.xp % 500)/5));
    return `<div style="margin:6px 0;">
      <div style="font-weight:600;">${k.toUpperCase()} – Level ${t.level}</div>
      <div style="height:8px; background:#e2e8f0; border-radius:6px; overflow:hidden;">
        <div style="width:${pct}%; height:100%; background:#00b8e6;"></div>
      </div>
    </div>`;
  }).join('');
}

document.addEventListener('DOMContentLoaded', loadSkills);

// Award XP hooks: call addSkillXP in existing game handlers
// Example integrations (lightweight):
window._awardSnakeXP = function(points){ addSkillXP('snake', Math.max(5, Math.floor(points/2))); };
window._awardFlappyXP = function(score){ addSkillXP('flappy', Math.max(5, Math.floor(score/3))); };
window._awardTTTXP = function(won){ addSkillXP('ttt', won ? 50 : 15); };
window._awardTowerXP = function(score){ addSkillXP('tower', Math.max(5, Math.floor(score/2))); };
window._awardSudokuXP = function(time){ addSkillXP('sudoku', 100); };

/////////////////////////////////////////////////////////////////////////////
// Limited-Time Event Quests
/////////////////////////////////////////////////////////////////////////////

let EVENT_QUESTS = [
  { id:'snowball_rush', name:'Snowball Rush', description:'Spiele 3 verschiedene Spiele heute', target:3, points:120, type:'gamesPlayed', start: Date.now(), end: Date.now() + 3*24*60*60*1000 },
  { id:'icy_streak', name:'Icy Streak', description:'Erreiche 2 Tage Advent-Streak', target:2, points:150, type:'adventStreak', start: Date.now(), end: Date.now() + 5*24*60*60*1000 }
];

// Zeitlich begrenzte Quests entfernt


async function __updatePresenceNow() {
  try {
    if (!currentUser) return;
    await updateDoc(doc(db, 'users', currentUser.uid), { lastActive: serverTimestamp() });
  } catch (e) {
    console.warn('Presence update failed', e);
  }
}

function __startPresenceHeartbeat() {
  // initial tick
  __updatePresenceNow();
  // interval
  if (__presenceInterval) clearInterval(__presenceInterval);
  __presenceInterval = setInterval(__updatePresenceNow, 60 * 1000);
  // page visibility / unload hooks (install once)
  if (!__presenceHandlersInstalled) {
    __presenceHandlersInstalled = true;
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') __updatePresenceNow();
    });
    window.addEventListener('beforeunload', () => {
      try { if (currentUser) updateDoc(doc(db, 'users', currentUser.uid), { lastActive: serverTimestamp() }); } catch (_) {}
    });
  }
}

function __stopPresenceHeartbeat() {
  if (__presenceInterval) {
    clearInterval(__presenceInterval);
    __presenceInterval = null;
  }
}

 

/////////////////////////////////////////////////////////////////////////////
// Darkmode
/////////////////////////////////////////////////////////////////////////////
const themeToggle = document.getElementById("themeToggle");

// Darkmode Toggle: Theme erneut anwenden
function applyTheme(themeMode) {
  if (themeMode === "dark") {
    document.body.classList.add("dark-mode");
    themeToggle.textContent = "Whitemode";
  } else {
    document.body.classList.remove("dark-mode");
    themeToggle.textContent = "Darkmode";
  }
  // Re-apply selected website theme to update accent/bg variables
  applyUserTheme();
}


/////////////////////////////////////////////////////////////////////////////
// MÜNZ-SYSTEM
/////////////////////////////////////////////////////////////////////////////
let userCoins = 0;

// Münz-Counter laden & anzeigen
async function loadUserCoins() {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, "users", currentUser.uid));
    if (userDoc.exists()) {
      userCoins = userDoc.data().coins || 0;
      document.getElementById("coinCount").textContent = userCoins;
      document.getElementById("coinDisplay").style.display = "inline";
    }
  } catch (err) {
    console.error("Fehler beim Laden der Münzen:", err);
  }
}

// Münzen hinzufügen
async function addCoins(amount) {
  if (!currentUser) return;
  
  userCoins += amount;
  
  try {
    await setDoc(doc(db, "users", currentUser.uid), {
      coins: userCoins
    }, { merge: true });
    
    document.getElementById("coinCount").textContent = userCoins;
    
    // Track coins earned für Battle Pass Quest
    if (amount > 0) {
      await updateBPQuestProgress('coinsEarned', amount);
    }
  } catch (err) {
    console.error("Fehler beim Speichern der Münzen:", err);
  }
}

// Expose addCoins globally for XXL Slot
window.addCoins = addCoins;

// Helper: Get current user coins (for bet max validation)
window.getUserCoins = function() {
  return userCoins || 0;
};

// Battle Pass Quest Progress updaten
async function updateBPQuestProgress(questType, value = 1) {
  if (!currentUser || !battlePassData.dailyQuests || !battlePassData.weeklyQuests) return;
  
  // Finde Quest mit diesem Type (prüfe beide Quest-Listen)
  let quest = battlePassData.dailyQuests.find(q => q.type === questType);
  let questId = quest ? quest.id : null;
  let isWeekly = false;
  
  // Wenn nicht in täglichen Quests, prüfe wöchentliche
  if (!quest) {
    quest = battlePassData.weeklyQuests.find(q => q.type === questType);
    if (quest) {
      questId = 'weekly_' + quest.id;
      isWeekly = true;
    }
  }
  
  if (!quest) return;
  
  // Update Progress
  if (!battlePassData.questProgress[questId]) {
    battlePassData.questProgress[questId] = 0;
  }
  
  battlePassData.questProgress[questId] = Math.min(
    battlePassData.questProgress[questId] + value,
    quest.target
  );
  
  // Prüfe ob Quest completed
  if (battlePassData.questProgress[questId] >= quest.target) {
    // Prüfe ob Quest bereits claimed wurde
    if (!battlePassData.claimedQuests) {
      battlePassData.claimedQuests = [];
    }
    
    const alreadyClaimed = battlePassData.claimedQuests.includes(questId);
    
    if (!alreadyClaimed) {
      // Quest zum ersten Mal abgeschlossen
      battlePassData.points += quest.points;
      battlePassData.claimedQuests.push(questId);
      
      // Berechne aktuelles Tier
      let newTier = 0;
      for (let i = BP_TIERS.length - 1; i >= 0; i--) {
        if (battlePassData.points >= BP_TIERS[i].pointsNeeded) {
          newTier = i + 1;
          break;
        }
      }
      battlePassData.currentTier = newTier;
      
      // Zeige Quest-Popup
      showQuestPopup(quest.name, quest.points, isWeekly);
    }
  }
  
  await saveBattlePassData();
  displayBattlePass();
}

// Expose updateBPQuestProgress globally for XXL Slot
window.updateBPQuestProgress = updateBPQuestProgress;

// Track "verschiedene Spiele gespielt" (einzigartig pro Tag)
async function trackGamePlayed(gameId) {
  try {
    if (!currentUser) return;
    if (!battlePassData.playedGamesToday) battlePassData.playedGamesToday = [];
    // Bei täglichem Reset (15:00), Liste vorsorglich zurücksetzen
    try { if (shouldRefreshQuests()) battlePassData.playedGamesToday = []; } catch (e) {}
    if (!battlePassData.playedGamesToday.includes(gameId)) {
      battlePassData.playedGamesToday.push(gameId);
      await updateBPQuestProgress('gamesPlayed', 1);
      await saveBattlePassData();
      displayBattlePass();
    }
  } catch (e) {
    console.warn('trackGamePlayed Fehler:', e);
  }
}

// Daily Login Bonus
async function checkDailyBonus() {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, "users", currentUser.uid));
    const userData = userDoc.data();
    
    const lastLoginDate = userData?.lastLoginDate?.toDate?.() || null;
    const today = new Date().toDateString();
    
    // Prüfe ob heute schon eingeloggt
    if (lastLoginDate?.toDateString() !== today) {
      // Neuer Tag - gib 10 Münzen
      await addCoins(10);
      showNotification("Daily Bonus!", "🎉 +10 Münzen für dein tägliches Login!");
      
      // Speichere Login-Datum
      await setDoc(doc(db, "users", currentUser.uid), {
        lastLoginDate: serverTimestamp()
      }, { merge: true });
    }
  } catch (err) {
    console.error("Fehler beim Daily Bonus:", err);
  }
}

// Ersetze die onAuthStateChanged Funktion - füge checkDailyBonus hinzu:
window.logout = async function() {
  await signOut(auth);
  location.reload();
};

window.deleteAccount = async function() {
  if (!currentUser) return;
  
  const password = document.getElementById('deleteAccountPassword').value;
  if (!password) {
    alert('Bitte gib dein Passwort ein um dein Konto zu löschen.');
    return;
  }
  
  try {
    // Passwort verifizieren durch Re-Authentifizierung
    const credential = EmailAuthProvider.credential(currentUser.email, password);
    await reauthenticateWithCredential(currentUser, credential);
    
    // Finale Bestätigung
    const finalConfirm = confirm('Willst du das wirklich tun?\n\nDein Konto wird unwiderruflich gelöscht!');
    if (!finalConfirm) {
      return;
    }
    
    const uid = currentUser.uid;
    
    // Benutzerdaten aus Firestore löschen
    await deleteDoc(doc(db, 'users', uid));
    
    // Chat-Nachrichten löschen (optional, oder nur uid entfernen)
    const chatQuery = query(collection(db, 'chat'), where('uid', '==', uid));
    const chatSnap = await getDocs(chatQuery);
    const chatDeletes = chatSnap.docs.map(d => deleteDoc(d.ref));
    await Promise.all(chatDeletes);
    
    // Spielstände löschen
    const deleteScores = async (collectionName) => {
      const q = query(collection(db, collectionName), where('uid', '==', uid));
      const snap = await getDocs(q);
      const deletes = snap.docs.map(d => deleteDoc(d.ref));
      await Promise.all(deletes);
    };
    
    await Promise.all([
      deleteScores('snakeScores'),
      deleteScores('towerScores'),
      deleteScores('penaltyScores'),
      deleteScores('chessScores')
    ]);
    
    // Authentication Account löschen (dies macht Email und Username wieder verfügbar)
    await deleteUser(currentUser);
    
    alert('Dein Konto wurde erfolgreich gelöscht.');
    window.location.reload();
  } catch (error) {
    console.error('Fehler beim Löschen des Kontos:', error);
    if (error.code === 'auth/wrong-password') {
      alert('Falsches Passwort!');
    } else if (error.code === 'auth/requires-recent-login') {
      alert('Bitte melde dich erneut an und versuche es noch einmal.');
    } else {
      alert('Fehler beim Löschen des Kontos: ' + error.message);
    }
  }
};

/////////////////////////////////////////////////////////////////////////////
// Auth-Modal öffnen / schließen
/////////////////////////////////////////////////////////////////////////////
window.openAuthModal = function(mode) {
  const modal = document.getElementById("authModal");
  if (!modal) return;
  modal.style.display = "flex";

  // optional Fokus setzen
  if (mode === "login") {
    const el = document.getElementById("logEmail");
    if (el) el.focus();
  } else {
    const el = document.getElementById("regEmail");
    if (el) el.focus();
  }
};

window.closeAuthModal = function() {
  const modal = document.getElementById("authModal");
  if (!modal) return;
  modal.style.display = "none";
};

// Klick auf dunklen Hintergrund schließt Modal
const authModalEl = document.getElementById("authModal");
if (authModalEl) {
  authModalEl.addEventListener("click", (e) => {
    if (e.target === authModalEl) {
      window.closeAuthModal();
    }
  });
}

// ESC schließt Modal
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    window.closeAuthModal();
  }
});


/////////////////////////////////////////////////////////////////////////////
// Datum
/////////////////////////////////////////////////////////////////////////////
function updateDate() {
  document.getElementById("dateBox").textContent =
    new Date().toLocaleDateString("de-DE");
}
updateDate();

/////////////////////////////////////////////////////////////////////////////
// User-System: Registrierung / Login
/////////////////////////////////////////////////////////////////////////////

// Login Funktion
window.login = async function() {
  const email = document.getElementById("logEmail").value.trim();
  const pass = document.getElementById("logPass").value.trim();
  const errorDiv = document.getElementById("loginError");

  // Fehler zurücksetzen
  if (errorDiv) {
    errorDiv.style.display = 'none';
    errorDiv.textContent = '';
  }

  if (!email || !pass) {
    if (errorDiv) {
      errorDiv.textContent = "Bitte E-Mail und Passwort eingeben.";
      errorDiv.style.display = 'block';
    }
    return;
  }

  try {
    await signInWithEmailAndPassword(auth, email, pass);
    closeAuthModal();
    showNotification("Erfolg", "Erfolgreich eingeloggt!");
  } catch (err) {
    console.error('Login error:', err);
    if (errorDiv) {
      // Fehlercode auswerten
      let message = "Login fehlgeschlagen.";
      if (err.code === 'auth/wrong-password' || err.code === 'auth/user-not-found') {
        message = "Falsche E-Mail oder Passwort.";
      } else if (err.code === 'auth/invalid-email') {
        message = "Ungültige E-Mail-Adresse.";
      } else if (err.code === 'auth/too-many-requests') {
        message = "Zu viele Versuche. Bitte später erneut versuchen.";
      } else if (err.code === 'auth/invalid-credential') {
        message = "Falsche E-Mail oder Passwort.";
      }
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }
  }
};

// Passwort zurücksetzen
window.resetPassword = async function() {
  const email = document.getElementById("logEmail").value.trim();
  
  if (!email) {
    showNotification("Hinweis", "Bitte gib deine E-Mail-Adresse ein, um das Passwort zurückzusetzen.");
    return;
  }

  try {
    await sendPasswordResetEmail(auth, email);
    showNotification("E-Mail gesendet", `Wir haben dir einen Link zum Zurücksetzen des Passworts an ${email} gesendet. Bitte prüfe dein Postfach (auch Spam).`);
  } catch (err) {
    console.error('Password reset error:', err);
    let message = "Fehler beim Senden der E-Mail.";
    if (err.code === 'auth/user-not-found') {
      message = "Diese E-Mail-Adresse ist nicht registriert.";
    } else if (err.code === 'auth/invalid-email') {
      message = "Ungültige E-Mail-Adresse.";
    }
    showNotification("Fehler", message);
  }
};

window.register = async function() {
  const email = document.getElementById("regEmail").value.trim();
  const pass = document.getElementById("regPass").value.trim();
  const nick = document.getElementById("regNick").value.trim();

  if (!email || !pass || !nick) {
    showNotification("Fehler", "Bitte E-Mail, Passwort und Nickname eingeben.");
    return;
  }

  // prüfen, ob Nickname schon existiert
  const usersRef = collection(db, "users");
  const q = query(usersRef, where("nickname", "==", nick));
  const snap = await getDocs(q);

  if (!snap.empty) {
    showNotification("Nickname vergeben", "Nickname ist bereits vergeben. Bitte einen anderen wählen.");
    return;
  }

  try {
    const cred = await createUserWithEmailAndPassword(auth, email, pass);

    await setDoc(doc(db, "users", cred.user.uid), {
      email,
      nickname: nick,
      emailVerified: false,
      verificationCode: null,
      profilePic: getDefaultProfilePic(),
      createdAt: serverTimestamp()
    });

    // Reale Verifizierungs-E-Mail senden
    try {
      await sendEmailVerification(cred.user);
      const info = document.getElementById('emailVerificationInfo');
      if (info) info.textContent = `Wir haben dir einen Bestätigungslink an ${email} gesendet. Bitte prüfe Posteingang und Spam.`;
      closeAuthModal();
      document.getElementById('emailVerificationModal').style.display = 'flex';
      showNotification("Konto erstellt", `Bestätigungs-E‑Mail an ${email} gesendet.`);
    } catch (mailErr) {
      console.error('Fehler beim Senden der Verifizierungs-Mail:', mailErr);
      showNotification("Hinweis", "Konnte Verifizierungs‑E‑Mail nicht senden. Versuch es später erneut.");
    }
  } catch (err) {
    showNotification("Fehler", "Registrierung fehlgeschlagen: " + err.message);
  }
};

window.verifyEmail = async function() {
  if (!auth.currentUser) {
    showNotification('Info', 'Bitte zuerst einloggen.');
    return;
  }
  try {
    await auth.currentUser.reload();
    if (auth.currentUser.emailVerified) {
      await setDoc(doc(db, 'users', auth.currentUser.uid), { emailVerified: true }, { merge: true });
      closeEmailVerification();
      showNotification('Verifiziert', 'Email erfolgreich verifiziert! 🎉');
    } else {
      showNotification('Nicht verifiziert', 'Noch nicht bestätigt. Bitte E‑Mail‑Link klicken.');
    }
  } catch (err) {
    showNotification('Fehler', 'Überprüfung fehlgeschlagen: ' + err.message);
  }
}

window.resendVerificationEmail = async function() {
  if (!auth.currentUser) {
    showNotification('Info', 'Bitte zuerst einloggen.');
    return;
  }
  try {
    await sendEmailVerification(auth.currentUser);
    showNotification('Gesendet', 'Verifizierungs‑E‑Mail erneut gesendet.');
  } catch (err) {
    showNotification('Fehler', 'E‑Mail konnte nicht gesendet werden: ' + err.message);
  }
}


window.closeEmailVerification = function() {
  document.getElementById('emailVerificationModal').style.display = 'none';
};

// Account Settings Funktionen
window.openAccountSettings = async function() {
  if (!currentUser) return;
  
  const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
  if (userDoc.exists()) {
    const data = userDoc.data();
    currentProfilePic = data.profilePic || getDefaultProfilePic();
    document.getElementById('accountProfilePic').src = currentProfilePic;
    document.getElementById('newNickname').value = data.nickname || '';
    document.getElementById('newEmail').value = data.email || '';
    
    // Statistiken laden
    const joinDate = data.createdAt?.toDate?.();
    if (joinDate) {
      document.getElementById('accountJoinDate').textContent = joinDate.toLocaleDateString('de-DE');
    } else {
      document.getElementById('accountJoinDate').textContent = 'Unbekannt';
    }
    
    // Chat-Nachrichten zählen
    const chatQuery = query(collection(db, 'chat'), where('uid', '==', currentUser.uid));
    const chatSnap = await getDocs(chatQuery);
    document.getElementById('accountChatMessages').textContent = chatSnap.size;
    
    // Lieblingsspiel berechnen
    const snakeQ = query(collection(db, 'snakeScores'), where('uid', '==', currentUser.uid));
    const towerQ = query(collection(db, 'towerScores'), where('uid', '==', currentUser.uid));
    const penaltyQ = query(collection(db, 'penaltyScores'), where('uid', '==', currentUser.uid));
    const chessQ = query(collection(db, 'chessScores'), where('uid', '==', currentUser.uid));
    
    const [snakeSnap, towerSnap, penaltySnap, chessSnap] = await Promise.all([
      getDocs(snakeQ),
      getDocs(towerQ),
      getDocs(penaltyQ),
      getDocs(chessQ)
    ]);
    
    const gameCounts = {
      'Snake': snakeSnap.size,
      'Tower Stack': towerSnap.size,
      'TicTacToe': data.tttStats?.total || 0,
      'Sudoku': data.sudokuStats?.total || 0,
      'Elfmeterschießen': penaltySnap.size,
      'Schach': chessSnap.size
    };
    
    let favoriteGame = '-';
    let maxCount = 0;
    for (const [game, count] of Object.entries(gameCounts)) {
      if (count > maxCount) {
        maxCount = count;
        favoriteGame = game;
      }
    }
    document.getElementById('accountFavoriteGame').textContent = maxCount > 0 ? favoriteGame : '-';
    
    // Höchster Slot-Gewinn
    const slotHighWin = data.slotHighWin || 0;
    document.getElementById('accountSlotHighWin').textContent = slotHighWin > 0 ? slotHighWin : '-';
    
    // Nickname-Änderungskosten anzeigen
    const nicknameChanged = data.nicknameChanged || false;
    const costInfoEl = document.getElementById('nicknameCostInfo');
    if (costInfoEl) {
      if (nicknameChanged) {
        costInfoEl.textContent = 'Kosten: 🪙 1000 Münzen';
        costInfoEl.style.color = '#ff6b6b';
      } else {
        costInfoEl.textContent = '✨ Erste Änderung kostenlos!';
        costInfoEl.style.color = '#28a745';
      }
    }
  }
  
  document.getElementById('accountSettingsModal').style.display = 'flex';
};

window.closeAccountSettings = function() {
  document.getElementById('accountSettingsModal').style.display = 'none';
};

window.closeSettings = function() {
  document.getElementById('settingsModal').style.display = 'none';
};

/////////////////////////////////////////////////////////////////////////////
// Friends System
/////////////////////////////////////////////////////////////////////////////

let currentViewedProfileUid = null; // Um zu wissen, welches Profil geöffnet ist
let currentPrivateChatUid = null; // Für Privat-Chat
let privateChatUnsubscribe = null; // Für Echtzeit-Listener
let friendRequestsListener = null; // Für Echtzeit-Listener auf Freundesanfragen
let lastCheckedMessageCounts = {}; // Speichert letzte Nachrichtenanzahl pro Chat

// Prüfe auf neue Freundesanfragen und Nachrichten
async function checkFriendsNotifications() {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const receivedRequests = userData.friendRequestsReceived || [];
    const friends = userData.friends || [];
    
    // Prüfe neue Freundesanfragen
    if (receivedRequests.length > 0) {
      showFriendsNotificationBadge();
      return;
    }
    
    // Prüfe neue Nachrichten von Freunden
    for (const friendUid of friends) {
      const chatId = [currentUser.uid, friendUid].sort().join('_');
      const chatRef = collection(db, 'privateChats', chatId, 'messages');
      const q = query(chatRef, orderBy('createdAt', 'desc'), limit(1));
      const snapshot = await getDocs(q);
      
      if (!snapshot.empty) {
        const lastMsg = snapshot.docs[0].data();
        // Wenn letzte Nachricht nicht von mir ist
        if (lastMsg.uid !== currentUser.uid) {
          // Prüfe ob Chat aktuell offen ist
          if (currentPrivateChatUid !== friendUid) {
            showFriendsNotificationBadge();
            return;
          }
        }
      }
    }
    
    // Keine Benachrichtigungen
    hideFriendsNotificationBadge();
  } catch (err) {
    console.error('Fehler beim Prüfen der Benachrichtigungen:', err);
  }
}

// Echtzeit-Listener für Freundesanfragen einrichten
function setupFriendRequestsListener() {
  if (!currentUser || friendRequestsListener) return;
  
  const userRef = doc(db, 'users', currentUser.uid);
  let previousRequestCount = 0;
  let isFirstLoad = true;
  
  friendRequestsListener = onSnapshot(userRef, async (docSnapshot) => {
    if (!docSnapshot.exists()) return;
    
    const userData = docSnapshot.data();
    const receivedRequests = userData.friendRequestsReceived || [];
    const currentRequestCount = receivedRequests.length;
    
    // Wenn neue Anfrage (nicht beim ersten Laden)
    if (!isFirstLoad && currentRequestCount > previousRequestCount) {
      // Hole Nickname des Senders
      const newRequesterUid = receivedRequests[receivedRequests.length - 1];
      try {
        const requesterDoc = await getDoc(doc(db, 'users', newRequesterUid));
        const requesterNickname = requesterDoc.data()?.nickname || 'Jemand';
        
        // Zeige Popup
        showPrivateChatNotification('Neue Freundesanfrage', `${requesterNickname} möchte dein Freund sein!`);
        playGameSound('message');
      } catch (err) {
        console.error('Fehler beim Laden des Requester-Nicknames:', err);
      }
    }
    
    previousRequestCount = currentRequestCount;
    isFirstLoad = false;
    
    // Update Badge
    checkFriendsNotifications();
  });
}

function showFriendsNotificationBadge() {
  const badge = document.getElementById('friendsNotificationBadge');
  if (badge) badge.style.display = 'block';
}

function hideFriendsNotificationBadge() {
  const badge = document.getElementById('friendsNotificationBadge');
  if (badge) badge.style.display = 'none';
}

// Listener für alle Freunde-Chats einrichten
let friendChatListeners = {};

async function setupFriendChatListeners() {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const friends = userData.friends || [];
    
    // Für jeden Freund einen Listener einrichten
    friends.forEach(friendUid => {
      if (friendChatListeners[friendUid]) return; // Bereits vorhanden
      
      const chatId = [currentUser.uid, friendUid].sort().join('_');
      const chatRef = collection(db, 'privateChats', chatId, 'messages');
      const q = query(chatRef, orderBy('createdAt', 'desc'), limit(1));
      
      let lastMessageId = null;
      
      friendChatListeners[friendUid] = onSnapshot(q, async (snapshot) => {
        if (snapshot.empty) return;
        
        const lastMsg = snapshot.docs[0];
        const msgData = lastMsg.data();
        
        // Neue Nachricht von diesem Freund
        if (lastMessageId !== null && lastMsg.id !== lastMessageId && msgData.uid !== currentUser.uid) {
          // Nur Popup wenn Chat nicht offen ist
          if (currentPrivateChatUid !== friendUid) {
            // Hole Nickname des Freundes
            try {
              const friendDoc = await getDoc(doc(db, 'users', friendUid));
              const friendNickname = friendDoc.data()?.nickname || 'Freund';
              
              showPrivateChatNotification(friendNickname, msgData.text || 'GIF gesendet');
              showFriendsNotificationBadge();
            } catch (err) {
              console.error('Fehler beim Laden des Freund-Nicknames:', err);
            }
          }
        }
        
        lastMessageId = lastMsg.id;
      });
    });
  } catch (err) {
    console.error('Fehler beim Einrichten der Chat-Listener:', err);
  }
}

window.openFriends = async function() {
  if (!currentUser) return;
  
  document.getElementById('friendsModal').style.display = 'flex';
  await loadFriendRequests();
  await loadFriendsList();
  
  // Verstecke Badge wenn Freunde-Modal geöffnet wird
  hideFriendsNotificationBadge();
};

window.closeFriends = function() {
  document.getElementById('friendsModal').style.display = 'none';
};

window.searchFriend = async function() {
  const searchInput = document.getElementById('friendSearchInput').value.trim();
  const resultsDiv = document.getElementById('friendSearchResults');
  
  if (!searchInput) {
    resultsDiv.innerHTML = '<p style="color:#999;">Bitte einen Nickname eingeben</p>';
    return;
  }
  
  try {
    const usersRef = collection(db, 'users');
    const q = query(usersRef, where('nickname', '==', searchInput));
    const snap = await getDocs(q);
    
    if (snap.empty) {
      resultsDiv.innerHTML = '<p style="color:#999;">Keine Benutzer gefunden</p>';
      return;
    }
    
    let html = '';
    snap.forEach(doc => {
      const data = doc.data();
      const uid = doc.id;
      
      if (uid === currentUser.uid) {
        return; // Eigenen Account nicht anzeigen
      }
      
      const profilePic = data.profilePic || getDefaultProfilePic();
      const nickname = data.nickname || 'Unbekannt';
      
      html += `
        <div style="display:flex; align-items:center; gap:10px; padding:10px; background:#f8f9fa; border-radius:8px; margin-bottom:10px;">
          <img src="${profilePic}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
          <strong style="flex:1; color:#000;">${nickname}</strong>
          <button onclick="sendFriendRequest('${uid}')" style="padding:5px 15px; background:#28a745; color:white;">Hinzufügen</button>
        </div>
      `;
    });
    
    resultsDiv.innerHTML = html;
  } catch (err) {
    console.error('Fehler bei Freundsuche:', err);
    resultsDiv.innerHTML = '<p style="color:#dc3545;">Fehler beim Suchen</p>';
  }
};

window.sendFriendRequest = async function(targetUid) {
  if (!currentUser) return;
  
  try {
    // Prüfen ob bereits Freunde oder Anfrage existiert
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const friends = userData.friends || [];
    const sentRequests = userData.friendRequestsSent || [];
    
    if (friends.includes(targetUid)) {
      showNotification('Info', 'Ihr seid bereits Freunde!');
      return;
    }
    
    if (sentRequests.includes(targetUid)) {
      showNotification('Info', 'Freundesanfrage wurde bereits gesendet!');
      return;
    }
    
    // Anfrage senden
    await updateDoc(doc(db, 'users', currentUser.uid), {
      friendRequestsSent: [...sentRequests, targetUid]
    });
    
    // Beim Empfänger hinzufügen
    const targetDoc = await getDoc(doc(db, 'users', targetUid));
    const targetData = targetDoc.data();
    const receivedRequests = targetData.friendRequestsReceived || [];
    
    await updateDoc(doc(db, 'users', targetUid), {
      friendRequestsReceived: [...receivedRequests, currentUser.uid]
    });
    
    showNotification('Erfolg', 'Freundesanfrage gesendet!');
    
  } catch (err) {
    console.error('Fehler beim Senden der Freundesanfrage:', err);
    showNotification('Fehler', 'Freundesanfrage konnte nicht gesendet werden.');
  }
};

window.loadFriendRequests = async function() {
  if (!currentUser) return;
  
  const requestsDiv = document.getElementById('friendRequestsList');
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const receivedRequests = userData.friendRequestsReceived || [];
    
    if (receivedRequests.length === 0) {
      requestsDiv.innerHTML = '<p style="color:#999;">Keine Freundesanfragen</p>';
      return;
    }
    
    let html = '';
    for (const uid of receivedRequests) {
      const reqUserDoc = await getDoc(doc(db, 'users', uid));
      if (!reqUserDoc.exists()) continue;
      
      const reqData = reqUserDoc.data();
      const profilePic = reqData.profilePic || getDefaultProfilePic();
      const nickname = reqData.nickname || 'Unbekannt';
      
      html += `
        <div style="display:flex; align-items:center; gap:10px; padding:10px; background:#fff3cd; border-radius:8px; margin-bottom:10px;">
          <img src="${profilePic}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
          <strong style="flex:1;">${nickname}</strong>
          <button onclick="acceptFriendRequest('${uid}')" style="padding:5px 15px; background:#28a745; color:white;">✓</button>
          <button onclick="declineFriendRequest('${uid}')" style="padding:5px 15px; background:#dc3545; color:white;">✗</button>
        </div>
      `;
    }
    
    requestsDiv.innerHTML = html;
  } catch (err) {
    console.error('Fehler beim Laden der Freundesanfragen:', err);
    requestsDiv.innerHTML = '<p style="color:#dc3545;">Fehler beim Laden</p>';
  }
};

window.acceptFriendRequest = async function(requesterUid) {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const receivedRequests = userData.friendRequestsReceived || [];
    const friends = userData.friends || [];
    
    // Anfrage entfernen, Freund hinzufügen
    await updateDoc(doc(db, 'users', currentUser.uid), {
      friendRequestsReceived: receivedRequests.filter(uid => uid !== requesterUid),
      friends: [...friends, requesterUid]
    });
    
    // Beim Sender auch hinzufügen
    const requesterDoc = await getDoc(doc(db, 'users', requesterUid));
    const requesterData = requesterDoc.data();
    const sentRequests = requesterData.friendRequestsSent || [];
    const requesterFriends = requesterData.friends || [];
    
    await updateDoc(doc(db, 'users', requesterUid), {
      friendRequestsSent: sentRequests.filter(uid => uid !== currentUser.uid),
      friends: [...requesterFriends, currentUser.uid]
    });
    
    showNotification('Erfolg', 'Freund hinzugefügt!');
    await loadFriendRequests();
    await loadFriendsList();
    checkFriendsNotifications();
    
    // Richte Listener für diesen neuen Freund ein
    setupFriendChatListeners();
  } catch (err) {
    console.error('Fehler beim Akzeptieren:', err);
    showNotification('Fehler', 'Konnte nicht akzeptiert werden.');
  }
};

window.declineFriendRequest = async function(requesterUid) {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const receivedRequests = userData.friendRequestsReceived || [];
    
    await updateDoc(doc(db, 'users', currentUser.uid), {
      friendRequestsReceived: receivedRequests.filter(uid => uid !== requesterUid)
    });
    
    // Beim Sender entfernen
    const requesterDoc = await getDoc(doc(db, 'users', requesterUid));
    const requesterData = requesterDoc.data();
    const sentRequests = requesterData.friendRequestsSent || [];
    
    await updateDoc(doc(db, 'users', requesterUid), {
      friendRequestsSent: sentRequests.filter(uid => uid !== currentUser.uid)
    });
    
    showNotification('Info', 'Freundesanfrage abgelehnt.');
    await loadFriendRequests();
    checkFriendsNotifications();
  } catch (err) {
    console.error('Fehler beim Ablehnen:', err);
  }
};

window.loadFriendsList = async function() {
  if (!currentUser) return;
  
  const friendsDiv = document.getElementById('friendsList');
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const friends = userData.friends || [];
    
    if (friends.length === 0) {
      friendsDiv.innerHTML = '<p style="color:#999;">Noch keine Freunde</p>';
      return;
    }
    
    let html = '';
    for (const uid of friends) {
      const friendDoc = await getDoc(doc(db, 'users', uid));
      if (!friendDoc.exists()) continue;
      
      const friendData = friendDoc.data();
      const profilePic = friendData.profilePic || getDefaultProfilePic();
      const nickname = friendData.nickname || 'Unbekannt';
      const lastActiveDate = friendData.lastActive?.toDate?.() ? friendData.lastActive.toDate() : (friendData.lastActive || null);
      const now = new Date();
      const diffMs = lastActiveDate ? (now - lastActiveDate) : Number.POSITIVE_INFINITY;
      const online = diffMs < 2 * 60 * 1000; // 2 Minuten Schwelle
      function rel(ms){
        if (!isFinite(ms)) return 'unbekannt';
        const s = Math.floor(ms/1000);
        if (s < 30) return 'gerade eben';
        const m = Math.floor(s/60);
        if (m < 1) return 'vor 1 Min';
        if (m < 60) return `vor ${m} Min`;
        const h = Math.floor(m/60);
        if (h < 24) return `vor ${h} Std`;
        const d = Math.floor(h/24);
        return `vor ${d} Tg`;
      }
      const statusColor = online ? '#28a745' : '#6c757d';
      const statusText = online ? 'Online' : `Offline • ${rel(diffMs)}`;
      const statusHtml = `<span style="display:inline-flex; align-items:center; gap:6px; font-size:12px; color:${statusColor};"><span style="width:8px; height:8px; border-radius:50%; background:${statusColor};"></span>${statusText}</span>`;
      
      html += `
        <div style="display:flex; align-items:center; gap:10px; padding:10px; background:#d4edda; border-radius:8px; margin-bottom:10px; cursor:pointer;" onclick="openUserProfile('${uid}')" title="Profil öffnen">
          <img src="${profilePic}" title="Profil öffnen" style="width:40px; height:40px; border-radius:50%; object-fit:cover; cursor:pointer;" onclick="openUserProfile('${uid}')">
          <div style="flex:1; display:flex; flex-direction:column; min-width:0;">
            <strong title="Profil öffnen" style="line-height:1.2; cursor:pointer;" onclick="openUserProfile('${uid}')">${nickname}</strong>
            ${statusHtml}
          </div>
          <button onclick="event.stopPropagation(); openPrivateChatWith('${uid}', '${nickname}')" style="padding:5px 15px; background:#007bff; color:white;">💬 Chat</button>
          <button onclick="event.stopPropagation(); removeFriend('${uid}')" style="padding:5px 15px; background:#dc3545; color:white;">Entfernen</button>
        </div>
      `;
    }
    
    friendsDiv.innerHTML = html;
  } catch (err) {
    console.error('Fehler beim Laden der Freundesliste:', err);
    friendsDiv.innerHTML = '<p style="color:#dc3545;">Fehler beim Laden</p>';
  }
};

window.removeFriend = async function(friendUid) {
  if (!currentUser) return;
  
  // Modal-basierte Bestätigung
  showNotification(
    'Freund entfernen?',
    'Möchtest du diesen Freund wirklich entfernen?',
    [
      { text: 'Abbrechen', style: 'background:#6c757d; color:white;', action: () => {} },
      { text: 'Entfernen', style: 'background:#dc3545; color:white;', action: async () => {
        try {
          const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
          const userData = userDoc.data();
          const friends = userData.friends || [];
          
          await updateDoc(doc(db, 'users', currentUser.uid), {
            friends: friends.filter(uid => uid !== friendUid)
          });
          
          // Beim anderen auch entfernen
          const friendDoc = await getDoc(doc(db, 'users', friendUid));
          const friendData = friendDoc.data();
          const friendFriends = friendData.friends || [];
          
          await updateDoc(doc(db, 'users', friendUid), {
            friends: friendFriends.filter(uid => uid !== currentUser.uid)
          });
          
          showNotification('Info', 'Freund entfernt.');
          await loadFriendsList();
        } catch (err) {
          console.error('Fehler beim Entfernen:', err);
          showNotification('Fehler', 'Konnte nicht entfernt werden.');
        }
      }}
    ]
  );
};

// Freundesanfrage vom Profil aus senden
window.sendFriendRequestFromProfile = async function() {
  if (!currentViewedProfileUid || !currentUser) return;
  await sendFriendRequest(currentViewedProfileUid);
};

// Privat-Chat vom Profil öffnen
window.openPrivateChatFromProfile = async function() {
  if (!currentViewedProfileUid || !currentUser) return;
  
  // Nickname holen
  const userDoc = await getDoc(doc(db, 'users', currentViewedProfileUid));
  if (!userDoc.exists()) return;
  const nickname = userDoc.data().nickname || 'Unbekannt';
  
  closeUserProfile();
  openPrivateChatWith(currentViewedProfileUid, nickname);
};

// Privat-Chat öffnen
window.openPrivateChatWith = async function(friendUid, friendNickname) {
  if (!currentUser) return;
  
  currentPrivateChatUid = friendUid;
  document.getElementById('privateChatTitle').textContent = `💬 Chat mit ${friendNickname}`;
  document.getElementById('privateChatModal').style.display = 'flex';
  
  // Echtzeit-Listener für Nachrichten
  if (privateChatUnsubscribe) {
    privateChatUnsubscribe();
  }
  
  // Chat-ID erstellen (sortiert, damit beide User die gleiche ID haben)
  const chatId = [currentUser.uid, friendUid].sort().join('_');
  
  const chatRef = collection(db, 'privateChats', chatId, 'messages');
  const q = query(chatRef, orderBy('createdAt', 'asc'));
  
  let messageCount = 0;
  
  privateChatUnsubscribe = onSnapshot(q, (snapshot) => {
    const chatBox = document.getElementById('privateChatBox');
    let html = '';
    
    const newMessageCount = snapshot.size;
    const hasNewMessage = messageCount > 0 && newMessageCount > messageCount;
    let lastMessage = null;
    
    snapshot.forEach(doc => {
      const msg = doc.data();
      lastMessage = msg;
      const isMe = msg.uid === currentUser.uid;
      const align = isMe ? 'right' : 'left';
      const bg = isMe ? '#007bff' : '#e9ecef';
      const color = isMe ? 'white' : 'black';
      
      html += `
        <div style="text-align:${align}; margin-bottom:10px;">
          <div style="display:inline-block; max-width:70%; padding:10px; background:${bg}; color:${color}; border-radius:12px;">
            <strong style="font-size:12px; opacity:0.8;">${msg.nickname}</strong>
            <div>${msg.text || ''}</div>
            ${msg.gifUrl ? `
              <div style=\"margin-top:6px;\">
                <img src=\"${msg.gifUrl}\" style=\"max-width:250px; max-height:250px; border-radius:8px; display:block;\" onerror=\"this.style.display='none';\">
                <a href=\"${msg.gifUrl}\" target=\"_blank\" rel=\"noopener\" style=\"font-size:11px; color:${isMe ? '#cfe8ff' : '#0056b3'}; text-decoration:underline; display:inline-block; margin-top:4px;\">GIF öffnen</a>
              </div>
            ` : ''}
            <div style="font-size:10px; opacity:0.7; margin-top:5px;">${msg.createdAt?.toDate?.().toLocaleTimeString('de-DE') || ''}</div>
          </div>
        </div>
      `;
    });
    
    chatBox.innerHTML = html || '<p style="color:#999; text-align:center;">Noch keine Nachrichten</p>';
    chatBox.scrollTop = chatBox.scrollHeight;
    
    messageCount = newMessageCount;
  });
};

window.closePrivateChat = function() {
  if (privateChatUnsubscribe) {
    privateChatUnsubscribe();
    privateChatUnsubscribe = null;
  }
  currentPrivateChatUid = null;
  document.getElementById('privateChatModal').style.display = 'none';
};

window.sendPrivateMessage = async function() {
  if (!currentUser || !currentPrivateChatUid) return;
  
  const input = document.getElementById('privateChatInput');
  const gifInput = document.getElementById('privateGifInput');
  const text = input.value.trim();
  const gifUrl = gifInput ? gifInput.value.trim() : '';
  if (!text && !gifUrl) return; // Mindestens Text oder GIF
  
  try {
    const chatId = [currentUser.uid, currentPrivateChatUid].sort().join('_');
    const chatRef = collection(db, 'privateChats', chatId, 'messages');
    
    const messageData = {
      uid: currentUser.uid,
      nickname: currentNickname,
      text: text || '',
      createdAt: serverTimestamp()
    };
    if (gifUrl) {
      messageData.gifUrl = gifUrl;
    }
    await addDoc(chatRef, messageData);
    
    input.value = '';
    if (gifInput) gifInput.value = '';
  } catch (err) {
    console.error('Fehler beim Senden der Nachricht:', err);
    showNotification('Fehler', 'Nachricht konnte nicht gesendet werden.');
  }
};

// Popup für neue Freundesanfrage (ähnlich wie Quest-Benachrichtigungen)
function checkAndShowFriendRequestNotification(targetUid) {
  // Diese Funktion könnte erweitert werden um Echtzeit-Benachrichtigungen zu senden
  // Für jetzt wird nur beim Öffnen des Freunde-Tabs geprüft
}

// User Profile Modal (inkl. Freund / Chat Buttons Logik)
window.openUserProfile = async function(uid) {
  if (!uid) return;
  currentViewedProfileUid = uid;
  
  // Aktionen / Buttons vorbereiten
  const actionsDiv = document.getElementById('profileModalActions');
  if (actionsDiv) {
    if (uid === currentUser?.uid) {
      actionsDiv.style.display = 'none';
    } else {
      actionsDiv.style.display = 'flex';
      try {
        if (currentUser) {
          const selfDoc = await getDoc(doc(db, 'users', currentUser.uid));
          const selfData = selfDoc.exists() ? selfDoc.data() : {};
          const isFriend = (selfData.friends || []).includes(uid);
          const addBtn = document.getElementById('addFriendBtn');
          const chatBtn = document.getElementById('privateChatBtn');
          if (addBtn) addBtn.style.display = isFriend ? 'none' : 'inline-block';
          if (chatBtn) chatBtn.style.display = isFriend ? 'inline-block' : 'none';
        }
      } catch (e) {
        console.error('Fehler beim Prüfen der Freundschaft:', e);
      }
    }
  }
  
  try {
    const userDoc = await getDoc(doc(db, 'users', uid));
    if (!userDoc.exists()) {
      showNotification('Fehler', 'Benutzer nicht gefunden.');
      return;
    }
    
    const data = userDoc.data();
    
    // Profilbild und Nickname
    document.getElementById('profileModalPic').src = data.profilePic || getDefaultProfilePic();
    const nicknameEl = document.getElementById('profileModalNickname');
    nicknameEl.textContent = data.nickname || 'Unbekannt';
    
    // Namen-Farbe anwenden
    const userInv = data.inventory || {};
    const nameColor = userInv.chatNameColor;
    if (nameColor) {
      const colorData = CHAT_COLORS.find(c => c.id === nameColor);
      if (colorData) {
        // Spezialeffekte (Santa, Holly, Icy, Advent colors) via data-color-id
        if (nameColor === 'santa_red') {
          nicknameEl.setAttribute('data-color-id', 'santa');
          nicknameEl.style.color = '';
        } else if (nameColor === 'holly_green') {
          nicknameEl.setAttribute('data-color-id', 'holly');
          nicknameEl.style.color = '';
        } else if (nameColor === 'icy_blue') {
          nicknameEl.setAttribute('data-color-id', 'icy');
          nicknameEl.style.color = '';
        } else if (nameColor === 'advent_snow_white') {
          nicknameEl.setAttribute('data-color-id', 'advent_snow');
          nicknameEl.style.color = '';
        } else if (nameColor === 'advent_christmas_red') {
          nicknameEl.setAttribute('data-color-id', 'advent_xmas');
          nicknameEl.style.color = '';
        } else if (nameColor === 'advent_golden_star') {
          nicknameEl.setAttribute('data-color-id', 'advent_gold_star');
          nicknameEl.style.color = '';
        } else if (nameColor === 'advent_christmas_magic') {
          nicknameEl.setAttribute('data-color-id', 'advent_magic');
          nicknameEl.style.color = '';
        } else if (nameColor === 'gold') {
          nicknameEl.setAttribute('data-color-id', 'gold');
          nicknameEl.style.color = '';
        } else if (nameColor === 'ruby_red') {
          nicknameEl.setAttribute('data-color-id', 'ruby');
          nicknameEl.style.color = '';
        } else if (nameColor === 'emerald') {
          nicknameEl.setAttribute('data-color-id', 'emerald');
          nicknameEl.style.color = '';
        } else if (nameColor === 'diamond') {
          nicknameEl.setAttribute('data-color-id', 'diamond');
          nicknameEl.style.color = '';
        } else if (nameColor === 'rainbow') {
          nicknameEl.setAttribute('data-color-id', 'rainbow');
          nicknameEl.style.color = '';
        } else {
          nicknameEl.removeAttribute('data-color-id');
          nicknameEl.style.color = colorData.color;
        }
      }
    } else {
      nicknameEl.removeAttribute('data-color-id');
      nicknameEl.style.color = '';
    }
    
    // Badge anzeigen
    const userInventory = data.inventory || {};
    const activeBadge = userInventory.activeBadge;
    const badgeEl = document.getElementById('profileModalBadge');
    if (activeBadge && userInventory.badges) {
      const badge = userInventory.badges.find(b => b.id === activeBadge);
      if (badge) {
        badgeEl.innerHTML = `${badge.icon} ${badge.name}`;
        badgeEl.title = badge.name;
      } else {
        badgeEl.textContent = '';
      }
    } else {
      badgeEl.textContent = '';
    }
    
    // Online/Offline Status
    const statusEl = document.getElementById('profileModalStatus');
    const lastActiveDate = data.lastActive?.toDate?.() ? data.lastActive.toDate() : (data.lastActive || null);
    const now = new Date();
    const diffMs = lastActiveDate ? (now - lastActiveDate) : Number.POSITIVE_INFINITY;
    const online = diffMs < 2 * 60 * 1000; // 2 Minuten
    function rel(ms){
      if (!isFinite(ms)) return 'unbekannt';
      const s = Math.floor(ms/1000);
      if (s < 30) return 'gerade eben';
      const m = Math.floor(s/60);
      if (m < 1) return 'vor 1 Min';
      if (m < 60) return `vor ${m} Min`;
      const h = Math.floor(m/60);
      if (h < 24) return `vor ${h} Std`;
      const d = Math.floor(h/24);
      return `vor ${d} Tg`;
    }
    const statusColor = online ? '#28a745' : '#6c757d';
    const statusText = online ? 'Online' : `Offline • ${rel(diffMs)}`;
    statusEl.innerHTML = `<span style="width:8px; height:8px; border-radius:50%; background:${statusColor}; display:inline-block;"></span> <span style="color:${statusColor}">${statusText}</span>`;

    // Beigetreten
    const joinDate = data.createdAt?.toDate?.();
    document.getElementById('profileModalJoinDate').textContent = joinDate ? joinDate.toLocaleDateString('de-DE') : 'Unbekannt';
    
    // Chat-Nachrichten
    const chatQuery = query(collection(db, 'chat'), where('uid', '==', uid));
    const chatSnap = await getDocs(chatQuery);
    document.getElementById('profileModalChatMessages').textContent = chatSnap.size;
    
    // Snake Highscore
    const snakeQuery = query(collection(db, 'snakeScores'), where('uid', '==', uid));
    const snakeSnap = await getDocs(snakeQuery);
    let snakeMax = 0;
    snakeSnap.forEach(d => {
      const score = d.data().score || 0;
      if (score > snakeMax) snakeMax = score;
    });
    document.getElementById('profileModalSnakeScore').textContent = snakeMax > 0 ? snakeMax : '-';
    
    // Tower Stack Highscore
    const towerQuery = query(collection(db, 'towerScores'), where('uid', '==', uid));
    const towerSnap = await getDocs(towerQuery);
    let towerMax = 0;
    towerSnap.forEach(d => {
      const score = d.data().score || 0;
      if (score > towerMax) towerMax = score;
    });
    document.getElementById('profileModalTowerScore').textContent = towerMax > 0 ? towerMax : '-';
    
    // TicTacToe Siege
    const tttWins = data.tttStats?.total || 0;
    document.getElementById('profileModalTTTWins').textContent = tttWins > 0 ? tttWins : '-';
    
    // Sudoku Siege
    const sudokuWins = data.sudokuStats?.total || 0;
    document.getElementById('profileModalSudokuWins').textContent = sudokuWins > 0 ? sudokuWins : '-';
    
    // Penalty Tore
    const penaltyQuery = query(collection(db, 'penaltyScores'), where('uid', '==', uid));
    const penaltySnap = await getDocs(penaltyQuery);
    let penaltyTotal = 0;
    penaltySnap.forEach(d => {
      penaltyTotal += d.data().goals || 0;
    });
    document.getElementById('profileModalPenaltyGoals').textContent = penaltyTotal > 0 ? penaltyTotal : '-';
    
    // Schach Siege
    const chessQuery = query(collection(db, 'chessScores'), where('uid', '==', uid));
    const chessSnap = await getDocs(chessQuery);
    const chessWins = chessSnap.size;
    document.getElementById('profileModalChessWins').textContent = chessWins > 0 ? chessWins : '-';
    
    // Lieblingsspiel berechnen (Spiel mit den meisten Einträgen)
    const gameCounts = {
      'Snake': snakeSnap.size,
      'Tower Stack': towerSnap.size,
      'TicTacToe': tttWins,
      'Sudoku': sudokuWins,
      'Elfmeterschießen': penaltySnap.size,
      'Schach': chessWins
    };
    
    let favoriteGame = '-';
    let maxCount = 0;
    for (const [game, count] of Object.entries(gameCounts)) {
      if (count > maxCount) {
        maxCount = count;
        favoriteGame = game;
      }
    }
    document.getElementById('profileModalFavoriteGame').textContent = maxCount > 0 ? favoriteGame : '-';
    
    // Höchster Slot-Gewinn (aus User-Daten)
    const slotHighWin = data.slotHighWin || 0;
    document.getElementById('profileModalSlotHighWin').textContent = slotHighWin > 0 ? slotHighWin : '-';
    
    // Modal öffnen
    document.getElementById('userProfileModal').style.display = 'flex';
  } catch (err) {
    console.error('Fehler beim Laden des Profils:', err);
    showNotification('Fehler', 'Profil konnte nicht geladen werden.');
  }
};

window.closeUserProfile = function() {
  document.getElementById('userProfileModal').style.display = 'none';
};

window.updateNickname = async function() {
  const newNick = document.getElementById('newNickname').value.trim();
  if (!newNick || !currentUser) return;
  
  // Prüfen ob Nickname schon existiert
  const usersRef = collection(db, 'users');
  const q = query(usersRef, where('nickname', '==', newNick));
  const snap = await getDocs(q);
  
  if (!snap.empty && snap.docs[0].id !== currentUser.uid) {
    showNotification('Fehler', 'Nickname bereits vergeben!');
    return;
  }
  
  try {
    // Prüfe ob bereits geändert wurde
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    const userData = userDoc.data();
    const nicknameChanged = userData.nicknameChanged || false;
    
    // Wenn bereits geändert, 1000 Münzen abziehen
    if (nicknameChanged) {
      const currentCoins = userData.coins || 0;
      if (currentCoins < 1000) {
        showNotification('Fehler', 'Nicht genug Münzen! Du brauchst 🪙 1000 Münzen.');
        return;
      }
      
      // Münzen abziehen
      await updateDoc(doc(db, 'users', currentUser.uid), { 
        nickname: newNick,
        coins: currentCoins - 1000
      });
      showNotification('Erfolg', 'Nickname aktualisiert! (-🪙 1000 Münzen)');
    } else {
      // Erste Änderung kostenlos
      await updateDoc(doc(db, 'users', currentUser.uid), { 
        nickname: newNick,
        nicknameChanged: true
      });
      showNotification('Erfolg', 'Nickname aktualisiert! (Kostenlos)');
    }
    
    currentNickname = newNick;
    location.reload();
  } catch (err) {
    showNotification('Fehler', err.message);
  }
};

window.updateEmail = async function() {
  const newEmailVal = document.getElementById('newEmail').value.trim();
  if (!newEmailVal || !currentUser) return;
  
  showNotification('Info', 'Email-Änderung erfordert erneutes Einloggen.');
  // Firebase Auth Email-Update würde hier implementiert werden
};

window.updatePassword = async function() {
  const currentPass = document.getElementById('currentPassword').value;
  const newPass = document.getElementById('newPassword').value;
  const confirmPass = document.getElementById('confirmPassword').value;
  
  if (!currentPass || !newPass || !confirmPass) {
    showNotification('Fehler', 'Alle Felder ausfüllen!');
    return;
  }
  
  if (newPass !== confirmPass) {
    showNotification('Fehler', 'Passwörter stimmen nicht überein!');
    return;
  }
  
  try {
    // Re-authenticate und Passwort ändern
    const credential = EmailAuthProvider.credential(currentUser.email, currentPass);
    await reauthenticateWithCredential(currentUser, credential);
    await updatePassword(currentUser, newPass);
    
    document.getElementById('currentPassword').value = '';
    document.getElementById('newPassword').value = '';
    document.getElementById('confirmPassword').value = '';
    
    showNotification('Erfolg', 'Passwort geändert!');
  } catch (err) {
    showNotification('Fehler', err.message);
  }
};

// Temporäre Variable für Vorschau-Bild + Editor State
let pendingProfilePicBase64 = null;
let profileEditorState = {
  image: null,
  scale: 1,
  posX: 0,
  posY: 0,
  isDragging: false,
  dragStartX: 0,
  dragStartY: 0
};

window.previewProfilePic = function() {
  const file = document.getElementById('profilePicInput').files[0];
  if (!file || !currentUser) return;
  
  // File Size Check (max 2MB)
  if (file.size > 2 * 1024 * 1024) {
    showNotification('Fehler', 'Bild zu groß! Max 2MB.');
    document.getElementById('profilePicInput').value = '';
    return;
  }
  
  // Load image into editor
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      profileEditorState.image = img;
      profileEditorState.scale = 1;
      profileEditorState.posX = 0;
      profileEditorState.posY = 0;
      
      const canvas = document.getElementById('profileCanvas');
      const container = document.getElementById('imageEditorContainer');
      
      // Setup drag handlers
      container.onmousedown = startDragProfileImage;
      container.onmousemove = dragProfileImage;
      container.onmouseup = endDragProfileImage;
      container.onmouseleave = endDragProfileImage;
      
      // Touch support
      container.ontouchstart = (e) => { e.preventDefault(); startDragProfileImage(e.touches[0]); };
      container.ontouchmove = (e) => { e.preventDefault(); dragProfileImage(e.touches[0]); };
      container.ontouchend = endDragProfileImage;
      
      document.getElementById('zoomSlider').value = 100;
      document.getElementById('profilePicPreview').style.display = 'block';
      
      renderProfileCanvas();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
};

function renderProfileCanvas() {
  const canvas = document.getElementById('profileCanvas');
  const ctx = canvas.getContext('2d');
  const img = profileEditorState.image;
  if (!img) return;
  
  const scale = profileEditorState.scale;
  const posX = profileEditorState.posX;
  const posY = profileEditorState.posY;
  
  // Clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, 300, 300);
  
  // Calculate dimensions
  const imgAspect = img.width / img.height;
  let drawWidth = 300 * scale;
  let drawHeight = 300 * scale;
  
  if (imgAspect > 1) {
    drawHeight = drawWidth / imgAspect;
  } else {
    drawWidth = drawHeight * imgAspect;
  }
  
  const x = 150 - (drawWidth / 2) + posX;
  const y = 150 - (drawHeight / 2) + posY;
  
  ctx.drawImage(img, x, y, drawWidth, drawHeight);
  
  // Update preview circle
  updateCircularPreview();
}

function updateCircularPreview() {
  const canvas = document.getElementById('profileCanvas');
  const previewImg = document.getElementById('previewImage');
  previewImg.src = canvas.toDataURL('image/jpeg', 0.9);
}

function startDragProfileImage(e) {
  profileEditorState.isDragging = true;
  profileEditorState.dragStartX = e.clientX || e.pageX;
  profileEditorState.dragStartY = e.clientY || e.pageY;
}

function dragProfileImage(e) {
  if (!profileEditorState.isDragging) return;
  const clientX = e.clientX || e.pageX;
  const clientY = e.clientY || e.pageY;
  
  const dx = clientX - profileEditorState.dragStartX;
  const dy = clientY - profileEditorState.dragStartY;
  
  profileEditorState.posX += dx;
  profileEditorState.posY += dy;
  
  profileEditorState.dragStartX = clientX;
  profileEditorState.dragStartY = clientY;
  
  renderProfileCanvas();
}

function endDragProfileImage() {
  profileEditorState.isDragging = false;
}

window.zoomProfileImage = function(delta) {
  profileEditorState.scale = Math.max(0.5, Math.min(3, profileEditorState.scale + delta));
  document.getElementById('zoomSlider').value = Math.round(profileEditorState.scale * 100);
  renderProfileCanvas();
};

window.setProfileZoom = function(value) {
  profileEditorState.scale = value / 100;
  renderProfileCanvas();
};

window.confirmProfilePic = async function() {
  if (!profileEditorState.image || !currentUser) return;
  
  try {
    // Get final cropped image from canvas
    const canvas = document.getElementById('profileCanvas');
    const croppedBase64 = canvas.toDataURL('image/jpeg', 0.85);
    
    await updateDoc(doc(db, 'users', currentUser.uid), {
      profilePic: croppedBase64
    });
    
    currentProfilePic = croppedBase64;
    
    // Update Account Settings Modal
    document.getElementById('accountProfilePic').src = croppedBase64;
    document.getElementById('profilePicPreview').style.display = 'none';
    document.getElementById('profilePicInput').value = '';
    
    // Update Navigation
    const navUserInfo = document.getElementById('navUserInfo');
    if (navUserInfo) {
      navUserInfo.innerHTML = `<img src="${croppedBase64}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:5px;"> ${currentNickname}`;
    }
    
    // Update Chat Info
    const chatInfo = document.getElementById('chatInfo');
    if (chatInfo) {
      chatInfo.innerHTML = `<img src="${croppedBase64}" style="width:20px; height:20px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:5px;"> Du schreibst als: ${currentNickname}`;
    }
    
    // Reset editor state
    pendingProfilePicBase64 = null;
    profileEditorState = { image: null, scale: 1, posX: 0, posY: 0, isDragging: false, dragStartX: 0, dragStartY: 0 };
    
    showNotification('Erfolg', 'Profilbild aktualisiert! Ranglisten werden beim nächsten Laden aktualisiert.');
  } catch (err) {
    showNotification('Fehler', err.message);
  }
};

window.cancelProfilePic = function() {
  document.getElementById('profilePicPreview').style.display = 'none';
  document.getElementById('profilePicInput').value = '';
  pendingProfilePicBase64 = null;
  profileEditorState = { image: null, scale: 1, posX: 0, posY: 0, isDragging: false, dragStartX: 0, dragStartY: 0 };
};

onAuthStateChanged(auth, async user => {
  currentUser = user || null;
  const userState = document.getElementById("userState");
  const chatInfo = document.getElementById("chatInfo");
  const newsAdminCard = document.getElementById("newsAdminCard");
  const navUserInfo = document.getElementById("navUserInfo");
  const authModal = document.getElementById("authModal");
  const pdfUploadCard = document.getElementById("pdfUploadCard");
  
  // Button Sichtbarkeit
  const loginBtn = document.getElementById('loginBtn');
  const registerBtn = document.getElementById('registerBtn');
  const accountBtn = document.getElementById('accountBtn');
  const friendsBtn = document.getElementById('friendsBtn');
  const settingsBtn = document.getElementById('settingsBtn');

  if (user) {
    const userDoc = await getDoc(doc(db, "users", user.uid));
    if (userDoc.exists()) {
      const userData = userDoc.data();
      currentNickname = userData.nickname || user.email;
      currentProfilePic = userData.profilePic || getDefaultProfilePic();
    } else {
      currentNickname = user.email;
      currentProfilePic = getDefaultProfilePic();
    }

    // Start/update presence heartbeat
    try { __startPresenceHeartbeat(); } catch(e) { console.warn('Presence heartbeat error', e); }
    
    // Buttons umschalten
    if (loginBtn) loginBtn.style.display = 'none';
    if (registerBtn) registerBtn.style.display = 'none';
    if (accountBtn) accountBtn.style.display = 'inline-block';
    if (friendsBtn) friendsBtn.style.display = 'inline-block';
    if (settingsBtn) settingsBtn.style.display = 'inline-block';

    if (userState)
      userState.textContent = "Eingeloggt als: " + currentNickname + " (" + user.email + ")";
    if (chatInfo) {
      chatInfo.innerHTML = `<img src="${currentProfilePic}" style="width:20px; height:20px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:5px;"> Du schreibst als: <span id="chatNicknameSpan">${currentNickname}</span>`;
    }

    // Nav user info with name color and open profile on click
    if (navUserInfo) {
      const invDoc = await getDoc(doc(db, 'users', user.uid));
      const invData = invDoc.exists() ? invDoc.data() : {};
      const nameColor = (invData.inventory || {}).chatNameColor;
      const nameSpan = document.createElement('span');
      nameSpan.id = 'navNicknameSpan';
      nameSpan.textContent = currentNickname;
      // Apply special effects via data-color-id or plain color
      if (nameColor === 'santa_red') {
        nameSpan.setAttribute('data-color-id', 'santa');
      } else if (nameColor === 'holly_green') {
        nameSpan.setAttribute('data-color-id', 'holly');
      } else if (nameColor === 'icy_blue') {
        nameSpan.setAttribute('data-color-id', 'icy');
      } else if (nameColor === 'advent_snow_white') {
        nameSpan.setAttribute('data-color-id', 'advent_snow');
      } else if (nameColor === 'advent_christmas_red') {
        nameSpan.setAttribute('data-color-id', 'advent_xmas');
      } else if (nameColor === 'advent_golden_star') {
        nameSpan.setAttribute('data-color-id', 'advent_gold_star');
      } else if (nameColor === 'advent_christmas_magic') {
        nameSpan.setAttribute('data-color-id', 'advent_magic');
      } else if (nameColor === 'gold') {
        nameSpan.setAttribute('data-color-id', 'gold');
      } else if (nameColor === 'ruby_red') {
        nameSpan.setAttribute('data-color-id', 'ruby');
      } else if (nameColor === 'emerald') {
        nameSpan.setAttribute('data-color-id', 'emerald');
      } else if (nameColor === 'diamond') {
        nameSpan.setAttribute('data-color-id', 'diamond');
      } else if (nameColor === 'rainbow') {
        nameSpan.setAttribute('data-color-id', 'rainbow');
      } else if (nameColor) {
        const colorData = CHAT_COLORS.find(c => c.id === nameColor);
        if (colorData) nameSpan.style.color = colorData.color;
      }

      navUserInfo.innerHTML = `<img src="${currentProfilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:5px;"> `;
      navUserInfo.appendChild(nameSpan);
      navUserInfo.onclick = () => openUserProfile(user.uid);
    }

    // News-Formular nur Admin
    if (user.email === ADMIN_EMAIL) {
      if (newsAdminCard) newsAdminCard.style.display = "block";
      if (pdfUploadCard) pdfUploadCard.style.display = "block";
    } else {
      if (newsAdminCard) newsAdminCard.style.display = "none";
      if (pdfUploadCard) pdfUploadCard.style.display = "none";
    }

    if (authModal) authModal.style.display = "none";
    
    // Battle Pass laden
    loadBattlePassData();
    loadUserCoins();
    checkDailyBonus();
    await loadUserInventory();
    // Backfill any previously claimed Advent items into inventory
    await syncAdventClaimsToInventory();
    displayInventory();
    
    // Prüfe Freundesanfragen und Nachrichten für Badge
    checkFriendsNotifications();
    
    // Starte Echtzeit-Listener für Freundesanfragen
    setupFriendRequestsListener();
    
    // Starte Echtzeit-Listener für Freunde-Chats
    setupFriendChatListeners();
    
    // Badge im Header anzeigen
    if (navUserInfo) {
      let badgeHtml = '';
      if (userInventory.activeBadge && userInventory.badges) {
        const activeBadge = userInventory.badges.find(b => b.id === userInventory.activeBadge);
        if (activeBadge) {
          badgeHtml = `<span style="margin-left:8px;" title="${activeBadge.name}">${activeBadge.icon} ${activeBadge.name}</span>`;
        }
      }
      navUserInfo.innerHTML = `<img src="${currentProfilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:5px;"> ${currentNickname}${badgeHtml}`;
    }
  } else {
    currentNickname = null;
    currentProfilePic = null;
    __stopPresenceHeartbeat();
    
    // Buttons umschalten
    if (loginBtn) loginBtn.style.display = 'inline-block';
    if (registerBtn) registerBtn.style.display = 'inline-block';
    if (accountBtn) accountBtn.style.display = 'none';
    
    if (userState) userState.textContent = "Nicht eingeloggt.";
    if (chatInfo) chatInfo.textContent = "Bitte einloggen, um zu schreiben.";
    if (navUserInfo) navUserInfo.textContent = "Nicht eingeloggt";
    if (newsAdminCard) newsAdminCard.style.display = "none";
    if (pdfUploadCard) pdfUploadCard.style.display = "none";
  }
});


/////////////////////////////////////////////////////////////////////////////
// PDF-Liste laden (ohne Firebase Storage, Dateien aus GitHub / eingebettet)
/////////////////////////////////////////////////////////////////////////////
const embeddedFiles = {
  // Beispiel: erstelle im Repo einen Ordner "files" und lade Dateien hoch.
  // Ersetze /files/MeinFormular.pdf mit echten Dateinamen aus deinem Repo.
  "123Fehlstundenzettel.pdf": "https://github.com/imthefx/123-Fehlstundenzettel-Formulare/blob/main/123Fehlstundenzettel.pdf"
};

async function loadPDFs() {
  const listEl = document.getElementById("pdfList");
  let html = "";

  for (const [filename, url] of Object.entries(embeddedFiles)) {
    html += `<p><a href="${url}" target="_blank" download="${filename}">${filename}</a></p>`;
  }

  if (!html) html = "<p>Keine Dateien vorhanden.</p>";
  listEl.innerHTML = html;
}
loadPDFs();


/////////////////////////////////////////////////////////////////////////////
// PDF Upload (nur Admin)
/////////////////////////////////////////////////////////////////////////////
window.uploadPDF = async function() {
  if (!auth.currentUser || auth.currentUser.email !== ADMIN_EMAIL) {
    showNotification("Nur Admin darf Dateien hochladen!");
    return;
  }

  const input = document.getElementById("pdfUpload");
  const files = input.files;

  if (!files || files.length === 0) {
    showNotification("Keine Datei ausgewählt.");
    return;
  }

  const progressContainer = document.getElementById("uploadProgressContainer");
  const progressBar = document.getElementById("uploadBar");
  const progressPercent = document.getElementById("uploadPercent");

  progressContainer.style.display = "block";

  let uploadedCount = 0;
  const totalFiles = files.length;

  for (const file of files) {
    const storageRef = ref(storage, "pdfs/" + file.name);
    const uploadTask = uploadBytesResumable(storageRef, file);
    
    try {
      // Warte bis Upload komplett ist
      await new Promise((resolve, reject) => {
        uploadTask.on(
          "state_changed",
          (snapshot) => {
            // State_changed wird mehrmals aufgerufen
            const bytesTransferred = snapshot.bytesTransferred;
            const totalBytes = snapshot.totalBytes;
            
            console.log(`Datei: ${file.name} - ${bytesTransferred}/${totalBytes}`);
            
            const fileProgress = (bytesTransferred / totalBytes) * 100;
            const totalProgress = ((uploadedCount + fileProgress / 100) / totalFiles) * 100;
            
            progressPercent.textContent = Math.round(totalProgress);
            progressBar.style.width = Math.round(totalProgress) + "%";
          },
          (error) => {
            console.error("Upload Fehler:", error);
            reject(error);
          },
          () => {
            // Complete
            console.log(`${file.name} fertig!`);
            uploadedCount++;
            resolve();
          }
        );
      });
      
    } catch (err) {
      showNotification("Fehler beim Upload von " + file.name + ": " + err.message);
    }
  }

  showNotification("Datei(en) hochgeladen!");
  input.value = "";
  progressContainer.style.display = "none";
  progressPercent.textContent = "0";
  progressBar.style.width = "0%";
  
  loadPDFs();
};

/////////////////////////////////////////////////////////////////////////////
// NEWS LADEN
/////////////////////////////////////////////////////////////////////////////
async function loadNews() {
  const qNews = query(collection(db, "news"), orderBy("createdAt", "desc"));
  const listEl = document.getElementById("newsList");

  onSnapshot(qNews, async snap => {
    const newsItems = [];
    snap.forEach(docu => {
      newsItems.push({ id: docu.id, ...docu.data() });
    });

    // Profilbilder und Namenfarben laden
    const profilePics = {};
    const nameColors = {};
    const nicknames = {};
    for (const item of newsItems) {
      if (item.uid) {
        try {
          const userDoc = await getDoc(doc(db, 'users', item.uid));
          if (userDoc.exists()) {
            const u = userDoc.data();
            profilePics[item.uid] = u.profilePic || getDefaultProfilePic();
            nameColors[item.uid] = (u.inventory || {}).chatNameColor || null;
            nicknames[item.uid] = u.nickname || item.author;
          } else {
            profilePics[item.uid] = getDefaultProfilePic();
            nameColors[item.uid] = null;
            nicknames[item.uid] = item.author;
          }
        } catch {
          profilePics[item.uid] = getDefaultProfilePic();
          nameColors[item.uid] = null;
          nicknames[item.uid] = item.author;
        }
      } else {
        profilePics[item.uid] = getDefaultProfilePic();
        nameColors[item.uid] = null;
        nicknames[item.uid] = item.author;
      }
    }

    let html = "";
    newsItems.forEach(d => {
      const date = d.createdAt?.toDate?.() || new Date();
      const profilePic = profilePics[d.uid];
      const cId = nameColors[d.uid];
      const nn = nicknames[d.uid] || d.author;
      const coloredName = (() => {
        if (cId === 'santa_red') return `<span data-color-id="santa">${nn}</span>`;
        if (cId === 'holly_green') return `<span data-color-id="holly">${nn}</span>`;
        if (cId === 'icy_blue') return `<span data-color-id="icy">${nn}</span>`;
        if (cId === 'advent_snow_white') return `<span data-color-id="advent_snow">${nn}</span>`;
        if (cId === 'advent_christmas_red') return `<span data-color-id="advent_xmas">${nn}</span>`;
        if (cId === 'advent_golden_star') return `<span data-color-id="advent_gold_star">${nn}</span>`;
        if (cId === 'advent_christmas_magic') return `<span data-color-id="advent_magic">${nn}</span>`;
        if (cId) {
          const c = CHAT_COLORS.find(x => x.id === cId);
          if (c) return `<span style="color:${c.color}">${nn}</span>`;
        }
        return nn;
      })();
      const authorDisplay = d.uid 
        ? `<img src="${profilePic}" style="width:20px; height:20px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:5px; cursor:pointer;" onclick="openUserProfile('${d.uid}')">`+
          `<span style="cursor:pointer;" onclick="openUserProfile('${d.uid}')">${coloredName}</span>`
        : coloredName;
      
      html += `
        <div class="card">
          <h3>${d.title}</h3>
          <small>${authorDisplay} — ${date.toLocaleString()}</small>
          <p>${d.content}</p>
        </div>
      `;
    });
    if (!html) html = "<p>Noch keine News.</p>";
    listEl.innerHTML = html;
  });
}
loadNews();

/////////////////////////////////////////////////////////////////////////////
// NEWS POSTEN (nur Admin)
/////////////////////////////////////////////////////////////////////////////
window.postNews = async function() {
  if (!auth.currentUser || auth.currentUser.email !== ADMIN_EMAIL) {
    showNotification("Nur Admin darf News posten!");
    return;
  }

  const title = document.getElementById("newsTitle").value.trim();
  const content = document.getElementById("newsContent").value.trim();
  if (!title || !content) {
    showNotification("Bitte Titel und Inhalt eingeben.");
    return;
  }

  await addDoc(collection(db, "news"), {
    title,
    content,
    // Setze Autor auf Nickname statt E-Mail
    author: (await (async () => { try { const d = await getDoc(doc(db,'users', auth.currentUser.uid)); return d.exists() ? (d.data().nickname || ADMIN_EMAIL) : ADMIN_EMAIL; } catch { return ADMIN_EMAIL; } })()),
    uid: auth.currentUser.uid,
    createdAt: serverTimestamp()
  });

  document.getElementById("newsTitle").value = "";
  document.getElementById("newsContent").value = "";

  showNotification("News veröffentlicht!");
};

/////////////////////////////////////////////////////////////////////////////
// CHAT mit Farbe und Profilbildern
/////////////////////////////////////////////////////////////////////////////

// Funktion: Löscht alte Nachrichten wenn mehr als 100 vorhanden sind
async function cleanupOldMessages() {
  const qCount = query(collection(db, "chat"), orderBy("createdAt", "asc"));
  const snap = await getDocs(qCount);
  
  const MAX_MESSAGES = 100;
  
  // Wenn mehr als 25 Nachrichten, lösche die ältesten
  if (snap.docs.length > MAX_MESSAGES) {
    const toDelete = snap.docs.length - MAX_MESSAGES;
    
    for (let i = 0; i < toDelete; i++) {
      await deleteDoc(snap.docs[i].ref);
    }
  }
}

/////////////////////////////////////////////////////////////////////////////
// TicTacToe ONLINE
/////////////////////////////////////////////////////////////////////////////
let tttGameId = null;
let tttPlayerId = null;
let tttPlayerSymbol = null;
/////////////////////////////////////////////////////////////////////////////
// TIC TAC TOE vs KI
/////////////////////////////////////////////////////////////////////////////

let tttAIBoard = Array(9).fill(null);
let tttAIGameActive = false;
let tttAIPlayerSymbol = "X";
let tttAISymbol = "O";
let tttAIDifficulty = "profi";

window.startTTTvsAI = function() {
  const difficultySelect = document.getElementById("tttDifficulty");
  tttAIDifficulty = difficultySelect ? difficultySelect.value : "profi";
  
  tttAIBoard = Array(9).fill(null);
  tttAIGameActive = true;
  tttAIPlayerSymbol = "X";
  tttAISymbol = "O";
  drawTTTAI();
  
  const difficultyNames = { noob: "Noob", profi: "Profi", champion: "Champion" };
  document.getElementById("tttStatus").textContent = `Du bist am Zug! (${difficultyNames[tttAIDifficulty]})`;
};

window.resetTTTAI = function() {
  tttAIBoard = Array(9).fill(null);
  tttAIGameActive = false;
  drawTTTAI();
  document.getElementById("tttStatus").textContent = "Klick 'Neues Spiel'";
};

function drawTTTAI() {
  const box = document.getElementById("tttBoard");
  const status = document.getElementById("tttStatus");

  if (!tttAIGameActive) {
    box.innerHTML = "";
    for (let i = 0; i < 9; i++) {
      const btn = document.createElement("button");
      btn.textContent = "";
      btn.className = "ttt-btn";
      btn.disabled = true;
      box.appendChild(btn);
    }
    status.textContent = "Klick 'Neues Spiel'";
    return;
  }

  box.innerHTML = "";
  tttAIBoard.forEach((cell, i) => {
    const btn = document.createElement("button");
    btn.textContent = cell || "";
    btn.className = "ttt-btn";
    btn.disabled = tttAIBoard[i] !== null;
    btn.onclick = () => tttAIPlayerMove(i);
    box.appendChild(btn);
  });

  const winner = tttWinner(tttAIBoard);
  if (winner) {
    if (winner === tttAIPlayerSymbol) {
      playGameSound('ttt_win');
      status.textContent = "Du hast gewonnen! 🎉";
      // Münzbelohnung basierend auf Schwierigkeit
      if (currentUser && currentNickname) {
        const rewards = { noob: 3, profi: 5, champion: 10 };
        const coins = rewards[tttAIDifficulty] || 5;
        addCoins(coins);
        
        // Speichere Sieg in Firebase
        saveTTTWin(tttAIDifficulty);
        
        setTimeout(() => {
          showNotification("Sieg!", `Du hast gewonnen! +${coins} Münzen (🪙)`);
        }, 100);
      }
    } else {
      playGameSound('ttt_lose');
      status.textContent = "KI hat gewonnen!";
    }
    tttAIGameActive = false;
  } else if (tttAIBoard.every(c => c !== null)) {
    status.textContent = "Unentschieden!";
    tttAIGameActive = false;
  }
}

function tttAIPlayerMove(i) {
  if (!tttAIGameActive || tttAIBoard[i]) return;

  tttAIBoard[i] = tttAIPlayerSymbol;
  playGameSound('ttt_place');
  drawTTTAI();

  const winner = tttWinner(tttAIBoard);
  if (winner || tttAIBoard.every(c => c !== null)) {
    return;
  }

  // KI-Zug nach kurzer Verzögerung
  setTimeout(() => {
    tttAIMakeMove();
    drawTTTAI();
  }, 300);
}

function tttAIMakeMove() {
  if (tttAIDifficulty === "noob") {
    // Noob: 70% Zufallszug, 30% optimaler Zug
    if (Math.random() < 0.7) {
      const emptySpots = [];
      for (let i = 0; i < 9; i++) {
        if (tttAIBoard[i] === null) emptySpots.push(i);
      }
      if (emptySpots.length > 0) {
        const randomMove = emptySpots[Math.floor(Math.random() * emptySpots.length)];
        tttAIBoard[randomMove] = tttAISymbol;
        return;
      }
    }
  } else if (tttAIDifficulty === "profi") {
    // Profi: 50% Zufallszug, 50% optimaler Zug
    if (Math.random() < 0.5) {
      const emptySpots = [];
      for (let i = 0; i < 9; i++) {
        if (tttAIBoard[i] === null) emptySpots.push(i);
      }
      if (emptySpots.length > 0) {
        const randomMove = emptySpots[Math.floor(Math.random() * emptySpots.length)];
        tttAIBoard[randomMove] = tttAISymbol;
        return;
      }
    }
  }
  
  // Champion oder Fallback: Minimax-Algorithmus für optimale KI
  const bestMove = findBestMove(tttAIBoard);
  if (bestMove !== -1) {
    tttAIBoard[bestMove] = tttAISymbol;
  }
}

function findBestMove(board) {
  let bestScore = -Infinity;
  let move = -1;

  for (let i = 0; i < 9; i++) {
    if (board[i] === null) {
      board[i] = tttAISymbol;
      let score = minimax(board, 0, false);
      board[i] = null;
      if (score > bestScore) {
        bestScore = score;
        move = i;
      }
    }
  }
  return move;
}

function minimax(board, depth, isMaximizing) {
  const winner = tttWinner(board);
  if (winner === tttAISymbol) return 10 - depth;
  if (winner === tttAIPlayerSymbol) return depth - 10;
  if (board.every(c => c !== null)) return 0;

  if (isMaximizing) {
    let bestScore = -Infinity;
    for (let i = 0; i < 9; i++) {
      if (board[i] === null) {
        board[i] = tttAISymbol;
        let score = minimax(board, depth + 1, false);
        board[i] = null;
        bestScore = Math.max(score, bestScore);
      }
    }
    return bestScore;
  } else {
    let bestScore = Infinity;
    for (let i = 0; i < 9; i++) {
      if (board[i] === null) {
        board[i] = tttAIPlayerSymbol;
        let score = minimax(board, depth + 1, true);
        board[i] = null;
        bestScore = Math.min(score, bestScore);
      }
    }
    return bestScore;
  }
}

function tttWinner(board) {
  const lines = [
    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Horizontal
    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Vertikal
    [0, 4, 8], [2, 4, 6]             // Diagonal
  ];
  
  for (let [a, b, c] of lines) {
    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
      return board[a];
    }
  }
  return null;
}

// Speichere Sieg in Firebase
async function saveTTTWin(difficulty) {
  if (!currentUser || !currentNickname) return;
  
  try {
    const userRef = doc(db, "users", currentUser.uid);
    const userDoc = await getDoc(userRef);
    
    let tttStats = userDoc.exists() && userDoc.data().tttStats ? userDoc.data().tttStats : {
      noob: 0,
      profi: 0,
      champion: 0,
      total: 0
    };
    
    tttStats[difficulty] = (tttStats[difficulty] || 0) + 1;
    tttStats.total = (tttStats.total || 0) + 1;
    
    await setDoc(userRef, {
      tttStats: tttStats,
      nickname: currentNickname
    }, { merge: true });
  } catch (err) {
    console.error("Fehler beim Speichern des TTT Sieges:", err);
  }
}

// Tic Tac Toe Ranking Modal
window.switchTTTRankingTab = function(mode) {
  currentTTTRankingMode = mode;
  document.getElementById('tttRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('tttRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('tttRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('tttRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadTTTRankings();
};

window.openTTTRanking = async function() {
  const modal = document.getElementById("tttRankingModal");
  if (!modal) return;
  
  await loadTTTRankings();
  modal.style.display = "flex";
};

window.closeTTTRanking = function() {
  const modal = document.getElementById("tttRankingModal");
  if (modal) modal.style.display = "none";
};

window.loadTTTRankings = async function() {
  const listEl = document.getElementById("tttRankingList");
  const filterEl = document.getElementById("tttRankingFilter");
  const filter = filterEl ? filterEl.value : "all";
  
  listEl.innerHTML = "<p>Wird geladen...</p>";
  
  try {
    const usersRef = collection(db, "users");
    const snap = await getDocs(usersRef);
    
    let players = [];
    snap.forEach(d => {
      const data = d.data();
      if (data.tttStats) {
        let wins = 0;
        if (filter === "all") {
          wins = data.tttStats.total || 0;
        } else {
          wins = data.tttStats[filter] || 0;
        }
        
        if (wins > 0) {
          players.push({
            uid: d.id,
            nickname: data.nickname || "guest",
            profilePic: data.profilePic || getDefaultProfilePic(),
            wins: wins,
            noobWins: data.tttStats.noob || 0,
            profiWins: data.tttStats.profi || 0,
            championWins: data.tttStats.champion || 0
          });
        }
      }
    });
    
    players.sort((a, b) => b.wins - a.wins);
    
    // Freunde-Filter anwenden
    if (currentTTTRankingMode === 'friends') {
      players = filterFriendsOnly(players);
    }
    
    const top10 = players.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = "<p>Noch keine Siege vorhanden.</p>";
      return;
    }
    
    const isDark = document.body.classList.contains("dark-mode");
    
        // Load name colors for top10
        const nameColors = {};
        for (const p of top10) {
          try {
            const uDoc = await getDoc(doc(db, 'users', p.uid));
            if (uDoc.exists()) {
              const inv = (uDoc.data().inventory || {});
              nameColors[p.uid] = inv.chatNameColor || null;
            } else {
              nameColors[p.uid] = null;
            }
          } catch {
            nameColors[p.uid] = null;
          }
        }
    const headerBg = "#007bff";
    const headerText = "#fff";
    const rowBg1 = isDark ? "#333" : "#f9f9f9";
    const rowBg2 = isDark ? "#222" : "#fff";
    const textColor = isDark ? "#f2f4f8" : "#111";
    const borderColor = isDark ? "#555" : "#ddd";
    
    const filterNames = { all: "Gesamt", noob: "Noob", profi: "Profi", champion: "Champion" };
    
    let html = `<table class='ranking-table' style='width:100%; border-collapse:collapse; color:${textColor};'>`;
    html += `<tr style='background:${headerBg}; color:${headerText};'><th style='padding:10px;'>#</th><th style='padding:10px;'>Spieler</th><th style='padding:10px;'>${filterNames[filter]} Siege</th>`;
    
    if (filter === "all") {
      html += `<th style='padding:10px; font-size:11px;'>N/P/C</th>`;
    }
    
    html += `</tr>`;
    
    top10.forEach((player, idx) => {
      const bgColor = idx % 2 === 0 ? rowBg1 : rowBg2;
      const medal = idx === 0 ? "🥇" : idx === 1 ? "🥈" : idx === 2 ? "🥉" : "";
      html += `
        <tr style="background:${bgColor}; border-bottom:1px solid ${borderColor}; color:${textColor};">
          <td style="padding:10px; text-align:center;">${medal} ${idx + 1}</td>
          <td style="padding:10px; cursor:pointer;" onclick="openUserProfile('${player.uid}')">
            <img src="${player.profilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;">
            ${(() => {
              const cId = nameColors[player.uid];
              if (cId === 'santa_red') return '<span data-color-id="santa">' + player.nickname + '</span>';
              if (cId === 'holly_green') return '<span data-color-id="holly">' + player.nickname + '</span>';
              if (cId === 'icy_blue') return '<span data-color-id="icy">' + player.nickname + '</span>';
              if (cId === 'advent_snow_white') return '<span data-color-id="advent_snow">' + player.nickname + '</span>';
              if (cId === 'advent_christmas_red') return '<span data-color-id="advent_xmas">' + player.nickname + '</span>';
              if (cId === 'advent_golden_star') return '<span data-color-id="advent_gold_star">' + player.nickname + '</span>';
              if (cId === 'advent_christmas_magic') return '<span data-color-id="advent_magic">' + player.nickname + '</span>';
              if (cId === 'gold') return '<span data-color-id="gold">' + player.nickname + '</span>';
              if (cId === 'ruby_red') return '<span data-color-id="ruby">' + player.nickname + '</span>';
              if (cId === 'emerald') return '<span data-color-id="emerald">' + player.nickname + '</span>';
              if (cId === 'diamond') return '<span data-color-id="diamond">' + player.nickname + '</span>';
              if (cId === 'rainbow') return '<span data-color-id="rainbow">' + player.nickname + '</span>';
              if (cId) {
                const c = CHAT_COLORS.find(x => x.id === cId);
                if (c) return '<span style="color:' + c.color + '">' + player.nickname + '</span>';
              }
              return player.nickname;
            })()}
          </td>
          <td style="padding:10px; font-weight:bold;">${player.wins}</td>`;
      
      if (filter === "all") {
        html += `<td style="padding:10px; font-size:11px;">${player.noobWins}/${player.profiWins}/${player.championWins}</td>`;
      }
      
      html += `</tr>`;
    });
    
    html += "</table>";
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error("Fehler beim Laden der TTT Rankings:", err);
    listEl.innerHTML = "<p>Fehler beim Laden der Rankings.</p>";
  }
}

// Init beim Start
drawTTTAI();

/////////////////////////////////////////////////////////////////////////////
// GAME SOUNDS - Zentrale Sound Engine für alle Spiele
/////////////////////////////////////////////////////////////////////////////

const gameAudioContext = new (window.AudioContext || window.webkitAudioContext)();

function playGameSound(type, game = 'general') {
  const oscillator = gameAudioContext.createOscillator();
  const gainNode = gameAudioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(gameAudioContext.destination);
  
  const now = gameAudioContext.currentTime;
  
  switch(type) {
    // Snake Sounds
    case 'snake_eat':
      oscillator.frequency.value = 600;
      oscillator.type = 'square';
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      oscillator.start(now);
      oscillator.stop(now + 0.1);
      break;
      
    case 'snake_die':
      oscillator.frequency.value = 100;
      oscillator.type = 'sawtooth';
      gainNode.gain.setValueAtTime(0.25, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      oscillator.start(now);
      oscillator.stop(now + 0.3);
      break;
      
    // Flappy Bird Sounds
    case 'flap':
      oscillator.frequency.value = 350;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.15, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
      oscillator.start(now);
      oscillator.stop(now + 0.08);
      break;
      
    case 'score':
      const notes = [523, 659]; // C, E
      notes.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.12, now + i * 0.08);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.12);
        osc.start(now + i * 0.08);
        osc.stop(now + i * 0.08 + 0.12);
      });
      break;
      
    case 'crash':
      oscillator.frequency.value = 80;
      oscillator.type = 'sawtooth';
      gainNode.gain.setValueAtTime(0.3, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
      oscillator.start(now);
      oscillator.stop(now + 0.4);
      break;
      
    // TicTacToe Sounds
    case 'ttt_place':
      oscillator.frequency.value = 440;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.15, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      oscillator.start(now);
      oscillator.stop(now + 0.1);
      break;
      
    case 'ttt_win':
      const winNotes = [523, 659, 784]; // C, E, G
      winNotes.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.15, now + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.15);
        osc.start(now + i * 0.1);
        osc.stop(now + i * 0.1 + 0.15);
      });
      break;
      
    case 'ttt_lose':
      oscillator.frequency.value = 200;
      oscillator.type = 'square';
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      oscillator.start(now);
      oscillator.stop(now + 0.3);
      break;
      
    // Tower Stack Sounds
    case 'tower_place':
      oscillator.frequency.value = 300 + (Math.random() * 200);
      oscillator.type = 'triangle';
      gainNode.gain.setValueAtTime(0.15, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
      oscillator.start(now);
      oscillator.stop(now + 0.12);
      break;
      
    case 'tower_fall':
      oscillator.frequency.value = 150;
      oscillator.type = 'sawtooth';
      gainNode.gain.setValueAtTime(0.25, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
      oscillator.start(now);
      oscillator.stop(now + 0.5);
      break;
      
    // Sudoku Sounds
    case 'sudoku_place':
      oscillator.frequency.value = 500;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.12, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
      oscillator.start(now);
      oscillator.stop(now + 0.08);
      break;
      
    case 'sudoku_error':
      oscillator.frequency.value = 220;
      oscillator.type = 'sawtooth';
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      oscillator.start(now);
      oscillator.stop(now + 0.2);
      break;
      
    case 'sudoku_complete':
      const completeNotes = [523, 659, 784, 1047]; // C, E, G, C
      completeNotes.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.15, now + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.15);
        osc.start(now + i * 0.1);
        osc.stop(now + i * 0.1 + 0.15);
      });
      break;
      
    // Penalty Sounds
    case 'penalty_shoot':
      oscillator.frequency.value = 180;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.25, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      oscillator.start(now);
      oscillator.stop(now + 0.15);
      break;
      
    case 'penalty_goal':
      const goalNotes = [392, 523, 659, 784]; // G, C, E, G
      goalNotes.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'triangle';
        gain.gain.setValueAtTime(0.2, now + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
        osc.start(now + i * 0.1);
        osc.stop(now + i * 0.1 + 0.2);
      });
      break;
      
    case 'penalty_save':
      oscillator.frequency.value = 250;
      oscillator.type = 'square';
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
      oscillator.start(now);
      oscillator.stop(now + 0.25);
      break;
      
    // Quest Completion Sound
    case 'quest_complete':
      const questNotes = [523, 659, 784, 1047]; // C, E, G, C(oktave)
      const questDurations = [0.15, 0.15, 0.15, 0.3];
      questNotes.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        const startTime = now + i * 0.1;
        const duration = questDurations[i];
        gain.gain.setValueAtTime(0.2, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
        osc.start(startTime);
        osc.stop(startTime + duration);
      });
      break;

    // Memory Game Sounds
    case 'memory_flip':
      oscillator.frequency.value = 420;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.18, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.09);
      oscillator.start(now);
      oscillator.stop(now + 0.09);
      break;

    case 'memory_match':
      const matchNotes = [440, 554, 659]; // A, C#, E (A-Dur Dreiklang)
      matchNotes.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'triangle';
        const startTime = now + i * 0.07;
        gain.gain.setValueAtTime(0.17, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.18);
        osc.start(startTime);
        osc.stop(startTime + 0.18);
      });
      break;

    case 'memory_mismatch':
      oscillator.frequency.value = 200;
      oscillator.type = 'sawtooth';
      gainNode.gain.setValueAtTime(0.22, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
      oscillator.start(now);
      oscillator.stop(now + 0.25);
      break;

    case 'memory_win':
      const winSeq = [523, 659, 784, 988]; // C E G B
      winSeq.forEach((freq, i) => {
        const osc = gameAudioContext.createOscillator();
        const gain = gameAudioContext.createGain();
        osc.connect(gain);
        gain.connect(gameAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        const startTime = now + i * 0.12;
        gain.gain.setValueAtTime(0.2, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.25);
        osc.start(startTime);
        osc.stop(startTime + 0.25);
      });
      break;
  }
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Snake
/////////////////////////////////////////////////////////////////////////////
const canvas = document.getElementById("snakeCanvas");
const ctx = canvas.getContext("2d");

let snake = [{x:8,y:8}];
let dir = {x:1,y:0};
let food = randFood();
let snakeRunning = false;

// Score / Highscores
let score = 0;
let highLocal = parseInt(localStorage.getItem("snakeHighLocal") || "0", 10) || 0;
let highGlobal = 0;

// DOM-Elemente
const snakeScoreEl = document.getElementById("snakeScore");
const snakeHighLocalEl = document.getElementById("snakeHighLocal");
const snakeHighGlobalEl = document.getElementById("snakeHighGlobal");

// Init Anzeige
if (snakeScoreEl) snakeScoreEl.textContent = score;
if (snakeHighLocalEl) snakeHighLocalEl.textContent = highLocal;
if (snakeHighGlobalEl) snakeHighGlobalEl.textContent = highGlobal;

function randFood() {
  return {x: Math.floor(Math.random()*16), y: Math.floor(Math.random()*16)};
}

function updateScoreDisplays() {
  if (snakeScoreEl) snakeScoreEl.textContent = score;
  if (snakeHighLocalEl) snakeHighLocalEl.textContent = highLocal;
  if (snakeHighGlobalEl) snakeHighGlobalEl.textContent = highGlobal;
}

async function updateGlobalHighscore() {
  try {
    const snap = await getDocs(collection(db, "snakeScores"));
    let max = 0;
    snap.forEach(d => {
      const s = d.data().score || 0;
      if (s > max) max = s;
    });
    highGlobal = max;
    updateScoreDisplays();
  } catch (err) {
    console.error("Fehler globaler Highscore:", err);
  }
}

updateGlobalHighscore();

function loopSnake() {
  if (!snakeRunning) return;

  const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

  if (head.x<0||head.x>=16||head.y<0||head.y>=16 || snake.some(s=>s.x===head.x && s.y===head.y)) {
    snakeRunning = false;
    playGameSound('snake_die');
    gameOver();
    return;
  }

  snake.unshift(head);
  if (head.x === food.x && head.y === food.y) {
    // gegessen -> Score erhöhen, neues Futter
    score++;
    updateScoreDisplays();
    food = randFood();
    playGameSound('snake_eat');
  } else {
    snake.pop();
  }

  drawSnake();
}

function drawSnake() {
  const isDark = document.body.classList.contains("dark-mode");
  ctx.fillStyle = isDark ? "#000" : "#fff";
  ctx.fillRect(0,0,320,320);

  ctx.fillStyle = "red";
  ctx.fillRect(food.x*20, food.y*20, 18, 18);

  ctx.fillStyle = "green";
  snake.forEach(s => {
    ctx.fillRect(s.x*20, s.y*20, 18, 18);
  });

  // Score im Canvas optional anzeigen (bereits im DOM)
}

function resetSnakeInternal() {
  snake = [{x:8,y:8}];
  dir = {x:1,y:0};
  food = randFood();
  snakeRunning = false;
  score = 0;
  updateScoreDisplays();
  drawSnake();
}

window.startSnake = function() {
  // Start-Button startet immer neu
  resetSnakeInternal();
  snakeRunning = true;
};

window.pauseSnake = function() { snakeRunning = false; };
window.resetSnake = function() { resetSnakeInternal(); };

document.addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  if (k==="w" && dir.y!==1) dir={x:0,y:-1};
  if (k==="s" && dir.y!==-1) dir={x:0,y:1};
  if (k==="a" && dir.x!==1) dir={x:-1,y:0};
  if (k==="d" && dir.x!==-1) dir={x:1,y:0};
});

setInterval(loopSnake, 120);
drawSnake();

async function gameOver() {
  // Lokalen Highscore prüfen/aktualisieren
  if (score > highLocal) {
    highLocal = score;
    try { localStorage.setItem("snakeHighLocal", String(highLocal)); } catch(e){}
  }

  updateScoreDisplays();

  // Globalen Score in Firestore speichern (falls möglich)
  try {
    await addDoc(collection(db, "snakeScores"), {
      uid: currentUser?.uid || null,
      score,
      nickname: currentNickname || "guest",
      createdAt: serverTimestamp()
    });
  } catch (err) {
    console.warn("Konnte globalen Score nicht speichern:", err);
  }

  // Globalen Highscore neu laden
  await updateGlobalHighscore();

  // 🪙 MÜNZEN HINZUFÜGEN (1 pro Punkt)
  if (currentUser) {
    await addCoins(score);
    // Track Snake Score für Battle Pass
    await updateBPQuestProgress('snakeScore', score);
    // Einzigartiges Spiel für "Abwechslung"
    await trackGamePlayed('snake');
  }

  showNotification("Game Over! Dein Score: " + score + " | 🪙 +" + score + " Münzen");
}

/////////////////////////////////////////////////////////////////////////////
// Snake Ranking Modal
/////////////////////////////////////////////////////////////////////////////
window.switchSnakeRankingTab = function(mode) {
  currentSnakeRankingMode = mode;
  document.getElementById('snakeRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('snakeRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('snakeRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('snakeRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadSnakeRankings(mode);
};

window.openSnakeRanking = async function() {
  const modal = document.getElementById("snakeRankingModal");
  if (!modal) return;
  
  // Lade Rankings
  await loadSnakeRankings();
  
  modal.style.display = "flex";
};

window.closeSnakeRanking = function() {
  const modal = document.getElementById("snakeRankingModal");
  if (!modal) return;
  modal.style.display = "none";
};

// Klick auf Modal-Hintergrund schließt es
const snakeRankingModalEl = document.getElementById("snakeRankingModal");
if (snakeRankingModalEl) {
  snakeRankingModalEl.addEventListener("click", (e) => {
    if (e.target === snakeRankingModalEl) {
      window.closeSnakeRanking();
    }
  });
}

/////////////////////////////////////////////////////////////////////////////
// Flappy Bird Ranking
/////////////////////////////////////////////////////////////////////////////

async function loadFlappyRankings(mode) {
  const listEl = document.getElementById("flappyRankingList");
  if (!listEl) return;
  
  if (mode) currentFlappyRankingMode = mode;
  
  listEl.innerHTML = "<p>Wird geladen...</p>";
  
  try {
    // Hole alle Scores aus Firebase
    const snapshot = await getDocs(collection(db, 'flappyScores'));
    
    if (snapshot.empty) {
      listEl.innerHTML = "<p style='text-align:center; opacity:0.6;'>Noch keine Einträge</p>";
      return;
    }
    
    let scores = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      scores.push({
        uid: data.uid,
        nickname: data.nickname || 'Unbekannt',
        score: data.score || 0
      });
    });
    
    scores.sort((a, b) => b.score - a.score);
    
    // Freunde-Filter anwenden
    if (currentFlappyRankingMode === 'friends') {
      scores = filterFriendsOnly(scores);
    }
    
    const top10 = scores.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = "<p style='text-align:center; opacity:0.6;'>Noch keine Einträge</p>";
      return;
    }
    
    let html = "<table style='width:100%; border-collapse:collapse;'>";
    html += "<thead><tr style='border-bottom:2px solid #007bff;'><th style='padding:10px;'>#</th><th style='padding:10px; text-align:left;'>Spieler</th><th style='padding:10px;'>Score</th></tr></thead><tbody>";
    
    let rank = 1;
    for (const item of top10) {
      const profilePic = await getUserProfilePic(item.uid);
      
      html += `<tr style='border-bottom:1px solid #ddd;'>`;
      html += `<td style='padding:10px; text-align:center; font-weight:bold;'>${rank}</td>`;
      html += `<td style='padding:10px; cursor:pointer;' onclick='openUserProfile("${item.uid}")'>`;
      html += `<img src='${profilePic}' style='width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;'>`;
      html += `${item.nickname}</td>`;
      html += `<td style='padding:10px; text-align:center; font-weight:bold; color:#007bff;'>${item.score}</td>`;
      html += `</tr>`;
      rank++;
    }
    
    html += "</tbody></table>";
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error('Fehler beim Laden der Flappy Rankings:', err);
    listEl.innerHTML = "<p style='color:red;'>Fehler beim Laden der Rangliste</p>";
  }
}

window.switchFlappyRankingTab = function(mode) {
  currentFlappyRankingMode = mode;
  document.getElementById('flappyRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('flappyRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('flappyRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('flappyRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadFlappyRankings(mode);
};

window.openFlappyRanking = async function() {
  const modal = document.getElementById("flappyRankingModal");
  if (!modal) return;
  
  await loadFlappyRankings();
  modal.style.display = "flex";
};

window.closeFlappyRanking = function() {
  const modal = document.getElementById("flappyRankingModal");
  if (!modal) return;
  modal.style.display = "none";
};

// Klick auf Modal-Hintergrund schließt es
const flappyRankingModalEl = document.getElementById("flappyRankingModal");
if (flappyRankingModalEl) {
  flappyRankingModalEl.addEventListener("click", (e) => {
    if (e.target === flappyRankingModalEl) {
      window.closeFlappyRanking();
    }
  });
}

/////////////////////////////////////////////////////////////////////////////
// Dino Game Ranking
/////////////////////////////////////////////////////////////////////////////

async function loadDinoRankings(mode) {
  const listEl = document.getElementById("dinoRankingList");
  if (!listEl) return;
  
  if (mode) currentDinoRankingMode = mode;
  
  listEl.innerHTML = "<p>Wird geladen...</p>";
  
  try {
    const snapshot = await getDocs(collection(db, 'dinoScores'));
    
    if (snapshot.empty) {
      listEl.innerHTML = "<p style='text-align:center; opacity:0.6;'>Noch keine Einträge</p>";
      return;
    }
    
    let scores = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      scores.push({
        uid: data.uid,
        nickname: data.nickname || 'Unbekannt',
        score: data.score || 0
      });
    });
    
    scores.sort((a, b) => b.score - a.score);
    
    // Freunde-Filter anwenden
    if (currentDinoRankingMode === 'friends') {
      scores = filterFriendsOnly(scores);
    }
    
    const top10 = scores.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = "<p style='text-align:center; opacity:0.6;'>Noch keine Einträge</p>";
      return;
    }
    
    let html = "<table style='width:100%; border-collapse:collapse;'>";
    html += "<thead><tr style='border-bottom:2px solid #007bff;'><th style='padding:10px;'>#</th><th style='padding:10px; text-align:left;'>Spieler</th><th style='padding:10px;'>Score</th></tr></thead><tbody>";
    
    let rank = 1;
    for (const item of top10) {
      const profilePic = await getUserProfilePic(item.uid);
      
      html += `<tr style='border-bottom:1px solid #ddd;'>`;
      html += `<td style='padding:10px; text-align:center; font-weight:bold;'>${rank}</td>`;
      html += `<td style='padding:10px; cursor:pointer;' onclick='openUserProfile("${item.uid}")'>`;
      html += `<img src='${profilePic}' style='width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;'>`;
      html += `${item.nickname}</td>`;
      html += `<td style='padding:10px; text-align:center; font-weight:bold; color:#007bff;'>${item.score}</td>`;
      html += `</tr>`;
      rank++;
    }
    
    html += "</tbody></table>";
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error('Fehler beim Laden der Dino Rankings:', err);
    listEl.innerHTML = "<p style='color:red;'>Fehler beim Laden der Rangliste</p>";
  }
}

window.switchDinoRankingTab = function(mode) {
  currentDinoRankingMode = mode;
  document.getElementById('dinoRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('dinoRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('dinoRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('dinoRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadDinoRankings(mode);
};

window.openDinoRanking = async function() {
  const modal = document.getElementById("dinoRankingModal");
  if (!modal) return;
  
  await loadDinoRankings();
  modal.style.display = "flex";
};

window.closeDinoRanking = function() {
  const modal = document.getElementById("dinoRankingModal");
  if (!modal) return;
  modal.style.display = "none";
};

const dinoRankingModalEl = document.getElementById("dinoRankingModal");
if (dinoRankingModalEl) {
  dinoRankingModalEl.addEventListener("click", (e) => {
    if (e.target === dinoRankingModalEl) {
      window.closeDinoRanking();
    }
  });
}

/////////////////////////////////////////////////////////////////////////////
// Flappy Bird
/////////////////////////////////////////////////////////////////////////////
const flappyCanvas = document.getElementById("flappyCanvas");
const flappyCtx = flappyCanvas.getContext("2d");

// Bird
let birdY = flappyCanvas.height / 2;
let birdX = 50;
const birdSize = 20;
let birdVelocity = 0;
const gravity = 0.6;
const flapPower = -7;

// Pipes
let pipes = [];
const pipeWidth = 50;
const pipeGap = 120;
const pipeSpeed = 4;
let pipeCounter = 0;

// Game State
let flappyRunning = false;
let flappyScore = 0;
let flappyHigh = parseInt(localStorage.getItem("flappyHigh") || "0", 10) || 0;

// DOM
const flappyScoreEl = document.getElementById("flappyScore");
const flappyHighEl = document.getElementById("flappyHigh");

if (flappyScoreEl) flappyScoreEl.textContent = flappyScore;
if (flappyHighEl) flappyHighEl.textContent = flappyHigh;

function resetFlappyGame() {
  birdY = flappyCanvas.height / 2;
  birdVelocity = 0;
  pipes = [];
  pipeCounter = 0;
  flappyScore = 0;
  flappyRunning = false;
  if (flappyScoreEl) flappyScoreEl.textContent = flappyScore;
  drawFlappy();
}

window.startFlappy = function() {
  resetFlappyGame();
  flappyRunning = true;
};

window.resetFlappy = function() {
  resetFlappyGame();
};

function drawFlappy() {
  const isDark = document.body.classList.contains("dark-mode");
  
  // Background
  flappyCtx.fillStyle = isDark ? "#1a1a2e" : "#87ceeb";
  flappyCtx.fillRect(0, 0, flappyCanvas.width, flappyCanvas.height);

  // Bird
  flappyCtx.fillStyle = "#FFD700";
  flappyCtx.beginPath();
  flappyCtx.arc(birdX, birdY, birdSize, 0, Math.PI * 2);
  flappyCtx.fill();

  // Bird Eye
  flappyCtx.fillStyle = "#000";
  flappyCtx.beginPath();
  flappyCtx.arc(birdX + 7, birdY - 5, 3, 0, Math.PI * 2);
  flappyCtx.fill();

  // Pipes
  flappyCtx.fillStyle = "#228B22";
  pipes.forEach(pipe => {
    // Top pipe
    flappyCtx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
    // Bottom pipe
    flappyCtx.fillRect(pipe.x, pipe.topHeight + pipeGap, pipeWidth, flappyCanvas.height - pipe.topHeight - pipeGap);
  });

  // Score
  flappyCtx.fillStyle = isDark ? "#f2f4f8" : "#000";
  flappyCtx.font = "24px Arial";
  flappyCtx.fillText("Score: " + flappyScore, 10, 30);
}

function loopFlappy() {
  if (!flappyRunning) return;

  // Physics
  birdVelocity += gravity;
  birdY += birdVelocity;

  // Collision mit oben/unten
  if (birdY - birdSize <= 0 || birdY + birdSize >= flappyCanvas.height) {
    flappyRunning = false;
    playGameSound('crash');
    endFlappyGame();
    return;
  }

  // Pipes spawnen
  pipeCounter++;
  if (pipeCounter > 100) {
    const randomGapStart = Math.random() * (flappyCanvas.height - pipeGap - 100) + 50;
    pipes.push({
      x: flappyCanvas.width,
      topHeight: randomGapStart
    });
    pipeCounter = 0;
  }

  // Pipes bewegen & Collision prüfen
  for (let i = pipes.length - 1; i >= 0; i--) {
    pipes[i].x -= pipeSpeed;

    // Pipe verlässt Bildschirm
    if (pipes[i].x + pipeWidth < 0) {
      pipes.splice(i, 1);
      flappyScore++;
      if (flappyScoreEl) flappyScoreEl.textContent = flappyScore;
      playGameSound('score');
      continue;
    }

    // Collision mit Pipe
    if (birdX + birdSize > pipes[i].x && birdX - birdSize < pipes[i].x + pipeWidth) {
      if (birdY - birdSize < pipes[i].topHeight || birdY + birdSize > pipes[i].topHeight + pipeGap) {
        flappyRunning = false;
        playGameSound('crash');
        endFlappyGame();
        return;
      }
    }
  }

  drawFlappy();
}

async function endFlappyGame() {
  // Highscore updaten
  if (flappyScore > flappyHigh) {
    flappyHigh = flappyScore;
    localStorage.setItem("flappyHigh", String(flappyHigh));
    if (flappyHighEl) flappyHighEl.textContent = flappyHigh;
  }

  // 🪙 MÜNZEN HINZUFÜGEN (3 pro Punkt)
  if (currentUser) {
    await addCoins(flappyScore * 3);
    // Track Flappy Score für Battle Pass
    await updateBPQuestProgress('flappyScore', flappyScore);
    // Einzigartiges Spiel für "Abwechslung"
    await trackGamePlayed('flappy');
    
    // Score in Firebase speichern
    try {
      await addDoc(collection(db, 'flappyScores'), {
        uid: currentUser.uid,
        nickname: currentNickname || 'Anonym',
        score: flappyScore,
        timestamp: serverTimestamp()
      });
    } catch (err) {
      console.error('Fehler beim Speichern des Flappy Scores:', err);
    }
  }

  showNotification("Flappy Bird", "Game Over! Score: " + flappyScore + " | 🪙 +" + flappyScore * 3 + " Münzen | Highscore: " + flappyHigh);
}

// Flap bei Space oder Klick
document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && flappyRunning) {
    e.preventDefault();
    birdVelocity = flapPower;
  }
});

flappyCanvas.addEventListener("click", () => {
  if (flappyRunning) {
    birdVelocity = flapPower;
    playGameSound('flap');
  }
});

setInterval(loopFlappy, 30);
drawFlappy();

/////////////////////////////////////////////////////////////////////////////
// DINO GAME 🦖
/////////////////////////////////////////////////////////////////////////////

const dinoCanvas = document.getElementById("dinoCanvas");
const dinoCtx = dinoCanvas ? dinoCanvas.getContext("2d") : null;

let dinoRunning = false;
let dinoScore = 0;
let dinoHigh = 0;
let dinoX = 50;
let dinoY = 250; // Top-Left Y des Dinos (stehend)
let dinoWidth = 44;
let dinoHeight = 40; // Stehhöhe
let dinoVelocityY = 0;
let dinoGravity = 0.85;
let dinoJumpPower = -16.5;
let dinoOnGround = true;
let dinoIsDucking = false; // Neue Ducken-Mechanik
let dinoSpeed = 6.2;
let dinoObstacles = [];
let dinoFrameCount = 0;
let dinoSpawnRate = 68;
let dinoClouds = [];
let dinoHills = [];

// Lade lokalen Highscore
try {
  const saved = localStorage.getItem("dinoHigh");
  if (saved) dinoHigh = parseInt(saved, 10);
} catch(e){}

function updateDinoDisplay() {
  const scoreEl = document.getElementById("dinoScore");
  const highEl = document.getElementById("dinoHigh");
  if (scoreEl) scoreEl.textContent = dinoScore;
  if (highEl) highEl.textContent = dinoHigh;
}

window.startDino = function() {
  dinoRunning = true;
  dinoScore = 0;
  dinoY = 250;
  dinoVelocityY = 0;
  dinoOnGround = true;
  dinoIsDucking = false;
  dinoSpeed = 6.2;
  dinoObstacles = [];
  dinoFrameCount = 0;
  dinoSpawnRate = 68;
  // Parallax-Elemente erstellen
  dinoClouds = Array.from({length: 5}, () => ({
    x: Math.random() * dinoCanvas.width,
    y: 40 + Math.random() * 120,
    w: 50 + Math.random() * 80,
    h: 18 + Math.random() * 12,
    s: 0.6 + Math.random() * 0.6
  }));
  dinoHills = [
    { x: 0, y: 270, w: 220, h: 40, s: 0.8 },
    { x: 250, y: 265, w: 280, h: 55, s: 0.6 },
    { x: 560, y: 275, w: 240, h: 35, s: 0.7 }
  ];
  updateDinoDisplay();
};

window.resetDino = function() {
  dinoRunning = false;
  dinoScore = 0;
  dinoY = 250;
  dinoVelocityY = 0;
  dinoOnGround = true;
  dinoIsDucking = false;
  dinoSpeed = 6.2;
  dinoObstacles = [];
  dinoFrameCount = 0;
  dinoSpawnRate = 68;
  // Parallax-Elemente zurücksetzen
  dinoClouds = Array.from({length: 5}, () => ({
    x: Math.random() * dinoCanvas.width,
    y: 40 + Math.random() * 120,
    w: 50 + Math.random() * 80,
    h: 18 + Math.random() * 12,
    s: 0.6 + Math.random() * 0.6
  }));
  dinoHills = [
    { x: 0, y: 270, w: 220, h: 40, s: 0.8 },
    { x: 250, y: 265, w: 280, h: 55, s: 0.6 },
    { x: 560, y: 275, w: 240, h: 35, s: 0.7 }
  ];
  updateDinoDisplay();
  drawDino();
};

function loopDino() {
  if (!dinoRunning || !dinoCtx) return;
  
  dinoFrameCount++;
  dinoScore = Math.floor(dinoFrameCount / 10);
  
  // Geschwindigkeit erhöhen mit der Zeit (schneller und aggressiver)
  if (dinoFrameCount % 140 === 0) {
    dinoSpeed += 0.75;
    if (dinoSpawnRate > 36) dinoSpawnRate -= 4;
  }
  
  // Spieler Physik
  dinoVelocityY += dinoGravity;
  dinoY += dinoVelocityY;
  
  // Boden-Kollision
  const groundY = 250;
  if (dinoY >= groundY) {
    dinoY = groundY;
    dinoVelocityY = 0;
    dinoOnGround = true;
  } else {
    dinoOnGround = false;
  }
  
  // Hindernisse spawnen (mehr Variation)
  if (dinoFrameCount % dinoSpawnRate === 0) {
    const rnd = Math.random();
    if (rnd < 0.6) {
      // Kaktus(e)
      const tall = Math.random() < 0.35;
      const baseH = tall ? 60 : (35 + Math.random() * 15);
      const cactus = { x: dinoCanvas.width, y: 255, width: 24, height: baseH, type: 'cactus' };
      dinoObstacles.push(cactus);
      // Chance auf ein Doppelhindernis
      if (Math.random() < 0.35) {
        dinoObstacles.push({ x: cactus.x + 40 + Math.random() * 20, y: 255, width: 20, height: baseH - 10, type: 'cactus' });
      }
    } else {
      // Vogel in zwei Höhen
      const y = Math.random() > 0.5 ? 200 : 160;
      dinoObstacles.push({ x: dinoCanvas.width, y, width: 34, height: 24, type: 'bird', flap: 0 });
    }
  }
  
  // Hindernisse bewegen und prüfen
  for (let i = dinoObstacles.length - 1; i >= 0; i--) {
    dinoObstacles[i].x -= dinoSpeed;
    
    // Entfernen wenn aus dem Bild
    if (dinoObstacles[i].x + dinoObstacles[i].width < 0) {
      dinoObstacles.splice(i, 1);
      continue;
    }
    
    // Kollisionserkennung
    const hitH = (dinoIsDucking && dinoOnGround) ? 25 : dinoHeight;
    if (
      dinoX < dinoObstacles[i].x + dinoObstacles[i].width &&
      dinoX + dinoWidth > dinoObstacles[i].x &&
      dinoY < dinoObstacles[i].y + dinoObstacles[i].height &&
      dinoY + hitH > dinoObstacles[i].y
    ) {
      endDino();
      return;
    }
  }
  
  drawDino();
  updateDinoDisplay();
}

function drawDino() {
  if (!dinoCtx) return;
  
  // Hintergrund (Gradient-Himmel)
  const sky = dinoCtx.createLinearGradient(0,0,0,dinoCanvas.height);
  sky.addColorStop(0, '#b9eaff');
  sky.addColorStop(1, '#ffffff');
  dinoCtx.fillStyle = sky;
  dinoCtx.fillRect(0, 0, dinoCanvas.width, dinoCanvas.height);

  // Parallax: Wolken
  dinoClouds.forEach(c => {
    c.x -= c.s * 0.6;
    if (c.x + c.w < 0) c.x = dinoCanvas.width + Math.random()*100;
    dinoCtx.fillStyle = 'rgba(255,255,255,0.95)';
    dinoCtx.beginPath();
    dinoCtx.roundRect ? dinoCtx.roundRect(c.x, c.y, c.w, c.h, 10) : dinoCtx.rect(c.x, c.y, c.w, c.h);
    dinoCtx.fill();
  });

  // Parallax: Hügel/Dünen
  dinoHills.forEach(h => {
    h.x -= h.s;
    if (h.x + h.w < 0) h.x = dinoCanvas.width + Math.random()*80;
    dinoCtx.fillStyle = '#e6e2d3';
    dinoCtx.beginPath();
    dinoCtx.moveTo(h.x, 290);
    dinoCtx.quadraticCurveTo(h.x + h.w/2, h.y - h.h, h.x + h.w, 290);
    dinoCtx.closePath();
    dinoCtx.fill();
  });
  
  // Boden
  dinoCtx.strokeStyle = "#535353";
  dinoCtx.lineWidth = 2;
  dinoCtx.beginPath();
  dinoCtx.moveTo(0, 290);
  dinoCtx.lineTo(dinoCanvas.width, 290);
  dinoCtx.stroke();
  // Bodenstreifen
  dinoCtx.strokeStyle = '#b0b0b0';
  dinoCtx.setLineDash([10, 12]);
  dinoCtx.beginPath();
  dinoCtx.moveTo(0, 300-8);
  dinoCtx.lineTo(dinoCanvas.width, 300-8);
  dinoCtx.stroke();
  dinoCtx.setLineDash([]);
  
  // Dino (stilisiert: Körper + Kopf + Beine animiert)
  const bodyH = (dinoIsDucking && dinoOnGround) ? 25 : dinoHeight;
  const legPhase = (dinoOnGround ? (dinoFrameCount % 20) : 0);
  dinoCtx.fillStyle = '#444';
  // Körper
  dinoCtx.beginPath();
  const radius = 6;
  if (dinoCtx.roundRect) {
    dinoCtx.roundRect(dinoX, dinoY, dinoWidth, bodyH, radius);
  } else {
    dinoCtx.rect(dinoX, dinoY, dinoWidth, bodyH);
  }
  dinoCtx.fill();
  // Kopf
  const headW = 18, headH = bodyH - 6;
  dinoCtx.fillStyle = '#555';
  dinoCtx.beginPath();
  if (dinoCtx.roundRect) {
    dinoCtx.roundRect(dinoX + dinoWidth - headW + 4, dinoY + 3, headW, headH, 6);
  } else {
    dinoCtx.rect(dinoX + dinoWidth - headW + 4, dinoY + 3, headW, headH);
  }
  dinoCtx.fill();
  // Auge
  dinoCtx.fillStyle = '#fff';
  dinoCtx.fillRect(dinoX + dinoWidth - 12, dinoY + 7, 4, 4);
  dinoCtx.fillStyle = '#111';
  dinoCtx.fillRect(dinoX + dinoWidth - 11, dinoY + 8, 2, 2);
  // Beine (lauf-Animation)
  dinoCtx.strokeStyle = '#333';
  dinoCtx.lineWidth = 4;
  if (dinoOnGround) {
    const legA = legPhase < 10 ? 6 : -6;
    const baseY = dinoY + bodyH;
    dinoCtx.beginPath();
    dinoCtx.moveTo(dinoX + 10, baseY);
    dinoCtx.lineTo(dinoX + 10, baseY + 10 + legA);
    dinoCtx.stroke();
    dinoCtx.beginPath();
    dinoCtx.moveTo(dinoX + 26, baseY);
    dinoCtx.lineTo(dinoX + 26, baseY + 10 - legA);
    dinoCtx.stroke();
  }
  
  // Hindernisse (gestaltet)
  dinoObstacles.forEach(obs => {
    if (obs.type === 'cactus') {
      dinoCtx.fillStyle = '#0f9d58';
      // Stamm
      dinoCtx.fillRect(obs.x, obs.y, obs.width, obs.height);
      // Arme
      dinoCtx.fillRect(obs.x - 6, obs.y + obs.height * 0.45, 6, 16);
      dinoCtx.fillRect(obs.x + obs.width, obs.y + obs.height * 0.35, 6, 18);
    } else {
      // Vogel mit Flügelanimation
      const flap = Math.sin((dinoFrameCount % 60) / 60 * Math.PI * 2) * 6;
      dinoCtx.fillStyle = '#3b3b3b';
      // Körper
      dinoCtx.fillRect(obs.x, obs.y, obs.width, obs.height);
      // Flügel
      dinoCtx.beginPath();
      dinoCtx.moveTo(obs.x + obs.width * 0.3, obs.y + obs.height / 2);
      dinoCtx.lineTo(obs.x + obs.width * 0.6, obs.y + obs.height / 2 - flap);
      dinoCtx.lineTo(obs.x + obs.width * 0.9, obs.y + obs.height / 2);
      dinoCtx.fill();
    }
  });
  
  // Score anzeigen
  dinoCtx.fillStyle = "#333";
  dinoCtx.font = "16px Arial";
  dinoCtx.fillText("HI " + dinoHigh.toString().padStart(5, '0') + "  " + dinoScore.toString().padStart(5, '0'), dinoCanvas.width - 150, 30);
}

async function endDino() {
  dinoRunning = false;
  playGameSound('game_over');
  
  // Highscore update
  if (dinoScore > dinoHigh) {
    dinoHigh = dinoScore;
    try {
      localStorage.setItem("dinoHigh", String(dinoHigh));
    } catch(e){}
    
    // Score in Firebase speichern
    if (currentUser && currentNickname) {
      try {
        await addDoc(collection(db, "dinoScores"), {
          uid: currentUser.uid,
          nickname: currentNickname,
          score: dinoScore,
          createdAt: serverTimestamp()
        });
      } catch (err) {
        console.error('Fehler beim Speichern des Dino Scores:', err);
      }
    }
  }
  
  // Münzen hinzufügen
  if (currentUser && dinoScore > 0) {
    const coins = Math.floor(dinoScore / 5);
    await addCoins(coins);
    await updateBPQuestProgress('dinoScore', dinoScore);
    await trackGamePlayed('dino');
    showNotification("Dino Run", `Game Over! Score: ${dinoScore} | 🪙 +${coins} Münzen`);
  } else {
    showNotification("Dino Run", `Game Over! Score: ${dinoScore}`);
  }
  
  updateDinoDisplay();
}

// Jump bei Space oder Klick
document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && dinoRunning && dinoOnGround) {
    e.preventDefault();
    dinoVelocityY = dinoJumpPower;
    dinoOnGround = false;
    playGameSound('jump');
  }
  // Ducken halten (Pfeil runter oder S)
  if ((e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') && dinoRunning && dinoOnGround) {
    dinoIsDucking = true;
  }
});

if (dinoCanvas) {
  dinoCanvas.addEventListener("click", () => {
    if (dinoRunning && dinoOnGround) {
      dinoVelocityY = dinoJumpPower;
      dinoOnGround = false;
      playGameSound('jump');
    }
  });
}

// Ducken loslassen
document.addEventListener('keyup', (e) => {
  if (e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') {
    dinoIsDucking = false;
  }
});

setInterval(loopDino, 30);
drawDino();
updateDinoDisplay();

/////////////////////////////////////////////////////////////////////////////
// TOWER STACK GAME 🏗️
/////////////////////////////////////////////////////////////////////////////

let towerCanvas = null;
let towerCtx = null;
let towerScore = 0;
let towerBest = parseInt(localStorage.getItem("towerBest") || "0");
let towerRunning = false;
let towerBlocks = [];
let currentBlock = null;
let blockDirection = 1;
let blockSpeed = 2;
let baseWidth = 120;
let blockHeight = 30;
let towerScoreEl = null;
let towerBestEl = null;
let cameraOffset = 0;

// Initialisiere Tower Stack nach DOM-Laden
function initTowerStack() {
  towerCanvas = document.getElementById("towerCanvas");
  towerCtx = towerCanvas ? towerCanvas.getContext("2d") : null;
  towerScoreEl = document.getElementById("towerScore");
  towerBestEl = document.getElementById("towerBest");
  
  if (towerBestEl) towerBestEl.textContent = towerBest;
  if (towerCanvas && towerCtx) {
    drawTowerStack();
    
    // Click Event für Tower Canvas
    towerCanvas.addEventListener("click", () => {
      if (towerRunning && currentBlock) {
        placeBlock();
      }
    });
  }
}

// Rufe Initialisierung auf sobald DOM bereit ist
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initTowerStack);
} else {
  initTowerStack();
}

window.startTowerStack = function() {
  if (!towerCanvas || !towerCtx) {
    showNotification("Fehler", "Tower Stack Canvas konnte nicht geladen werden.");
    return;
  }
  if (towerRunning) return;
  
  // Reset alles
  towerScore = 0;
  towerBlocks = [];
  currentBlock = null;
  blockSpeed = 2;
  blockDirection = 1;
  cameraOffset = 0;
  
  // Basis-Block
  towerBlocks.push({
    x: (towerCanvas.width - baseWidth) / 2,
    y: towerCanvas.height - blockHeight,
    width: baseWidth
  });
  
  // Erster beweglicher Block
  spawnNewBlock();
  
  towerRunning = true;
  if (towerScoreEl) towerScoreEl.textContent = towerScore;
  
  loopTowerStack();
};

function spawnNewBlock() {
  const lastBlock = towerBlocks[towerBlocks.length - 1];
  blockDirection = Math.random() > 0.5 ? 1 : -1;
  currentBlock = {
    x: blockDirection === 1 ? 0 : towerCanvas.width - lastBlock.width,
    y: lastBlock.y - blockHeight,
    width: lastBlock.width
  };
}

function drawTowerStack() {
  if (!towerCtx) return;
  
  // Hintergrund
  towerCtx.fillStyle = "#87CEEB";
  towerCtx.fillRect(0, 0, towerCanvas.width, towerCanvas.height);
  
  // Gezeichnete Blöcke mit Kamera-Offset
  towerBlocks.forEach((block, idx) => {
    towerCtx.fillStyle = `hsl(${idx * 30}, 70%, 60%)`;
    towerCtx.fillRect(block.x, block.y + cameraOffset, block.width, blockHeight);
    towerCtx.strokeStyle = "#333";
    towerCtx.strokeRect(block.x, block.y + cameraOffset, block.width, blockHeight);
  });
  
  // Aktueller beweglicher Block mit Kamera-Offset
  if (currentBlock) {
    towerCtx.fillStyle = `hsl(${towerBlocks.length * 30}, 70%, 60%)`;
    towerCtx.fillRect(currentBlock.x, currentBlock.y + cameraOffset, currentBlock.width, blockHeight);
    towerCtx.strokeStyle = "#333";
    towerCtx.strokeRect(currentBlock.x, currentBlock.y + cameraOffset, currentBlock.width, blockHeight);
  }
  
  // Score (bleibt immer oben sichtbar)
  towerCtx.fillStyle = "#000";
  towerCtx.font = "20px Arial";
  towerCtx.fillText("Score: " + towerScore, 10, 25);
}

function loopTowerStack() {
  if (!towerRunning) return;
  
  if (currentBlock) {
    // Block bewegen
    currentBlock.x += blockSpeed * blockDirection;
    
    // Richtung umkehren bei Rand
    if (currentBlock.x <= 0) {
      currentBlock.x = 0;
      blockDirection = 1;
    } else if (currentBlock.x + currentBlock.width >= towerCanvas.width) {
      currentBlock.x = towerCanvas.width - currentBlock.width;
      blockDirection = -1;
    }
  }
  
  drawTowerStack();
  requestAnimationFrame(loopTowerStack);
}

function placeBlock() {
  if (!currentBlock || !towerRunning) return;
  
  const lastBlock = towerBlocks[towerBlocks.length - 1];
  
  // Berechne Überlappung
  const overlapStart = Math.max(currentBlock.x, lastBlock.x);
  const overlapEnd = Math.min(currentBlock.x + currentBlock.width, lastBlock.x + lastBlock.width);
  const overlap = overlapEnd - overlapStart;
  
  if (overlap <= 0) {
    // Kein Overlap - Game Over
    playGameSound('tower_fall');
    endTowerStack();
    return;
  }
  
  // Neuer Block mit reduzierter Breite
  const newBlock = {
    x: overlapStart,
    y: currentBlock.y,
    width: overlap
  };
  
  towerBlocks.push(newBlock);
  towerScore++;
  playGameSound('tower_place');
  if (towerScoreEl) towerScoreEl.textContent = towerScore;
  
  // Schwierigkeit erhöhen
  if (towerScore % 5 === 0) {
    blockSpeed += 0.5;
  }
  
  // Kamera nach oben verschieben wenn Block zu weit oben ist
  if (newBlock.y + cameraOffset < 100) {
    cameraOffset += blockHeight;
  }
  
  // Nächster Block
  spawnNewBlock();
}

async function endTowerStack() {
  towerRunning = false;
  
  // Best Score updaten
  if (towerScore > towerBest) {
    towerBest = towerScore;
    localStorage.setItem("towerBest", String(towerBest));
    if (towerBestEl) towerBestEl.textContent = towerBest;
    
    // Score in Firebase speichern
    if (currentUser && currentNickname) {
      try {
        await addDoc(collection(db, "towerScores"), {
          uid: currentUser.uid,
          nickname: currentNickname,
          score: towerScore,
          createdAt: serverTimestamp()
        });
      } catch (err) {
        console.error("Fehler beim Speichern des Tower Scores:", err);
      }
    }
  }
  
  // Münzen hinzufügen (1 pro Punkt, aber erst ab Score 2)
  if (currentUser && towerScore >= 2) {
    await addCoins(towerScore);
    await trackGamePlayed('tower');
    showNotification("Tower Stack", "Game Over! Score: " + towerScore + " | 🪙 +" + towerScore + " Münzen | Best: " + towerBest);
  } else if (currentUser && towerScore < 2) {
    showNotification("Tower Stack", "Game Over! Score: " + towerScore + " | Mindestens 2 Punkte für Münzen! | Best: " + towerBest);
  } else {
    showNotification("Tower Stack", "Game Over! Score: " + towerScore + " | Best: " + towerBest);
  }
}

// Platzierung bei Space oder Klick
document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && towerRunning && currentBlock) {
    e.preventDefault();
    placeBlock();
  }
});

// Tower Ranking Modal// Tower Ranking Modal
window.switchTowerRankingTab = function(mode) {
  currentTowerRankingMode = mode;
  document.getElementById('towerRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('towerRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('towerRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('towerRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadTowerRankings(mode);
};

window.openTowerRanking = async function() {
  const modal = document.getElementById("towerRankingModal");
  if (!modal) return;
  
  await loadTowerRankings();
  modal.style.display = "flex";
};

window.closeTowerRanking = function() {
  const modal = document.getElementById("towerRankingModal");
  if (modal) modal.style.display = "none";
};

async function loadTowerRankings(mode) {
  const listEl = document.getElementById("towerRankingList");
  listEl.innerHTML = "<p>Wird geladen...</p>";
  
  if (mode) currentTowerRankingMode = mode;
  
  try {
    const snap = await getDocs(collection(db, "towerScores"));
    
    let scores = [];
    snap.forEach(d => {
      scores.push({
        uid: d.data().uid || null,
        nickname: d.data().nickname || "guest",
        score: d.data().score || 0,
        date: d.data().createdAt?.toDate?.() || new Date()
      });
    });
    
    scores.sort((a, b) => b.score - a.score);
    
    // Freunde-Filter anwenden
    if (currentTowerRankingMode === 'friends') {
      scores = filterFriendsOnly(scores);
    }
    
    const top10 = scores.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = "<p>Noch keine Scores vorhanden.</p>";
      return;
    }
    
    // Profilbilder laden
    const profilePics = {};
    for (const score of top10) {
      if (score.uid) {
        try {
          const userDoc = await getDoc(doc(db, 'users', score.uid));
          profilePics[score.uid] = userDoc.exists() ? (userDoc.data().profilePic || getDefaultProfilePic()) : getDefaultProfilePic();
        } catch {
          profilePics[score.uid] = getDefaultProfilePic();
        }
      } else {
        profilePics[score.uid] = getDefaultProfilePic();
      }
    }
    
    const isDark = document.body.classList.contains("dark-mode");
    const headerBg = "#007bff";
    const headerText = "#fff";
    const rowBg1 = isDark ? "#333" : "#f9f9f9";
    const rowBg2 = isDark ? "#222" : "#fff";
    const textColor = isDark ? "#f2f4f8" : "#111";
    const borderColor = isDark ? "#555" : "#ddd";
    
    let html = `<table class='ranking-table' style='width:100%; border-collapse:collapse; color:${textColor};'>`;
    html += `<tr style='background:${headerBg}; color:${headerText};'><th style='padding:10px;'>#</th><th style='padding:10px;'>Spieler</th><th style='padding:10px;'>Score</th><th style='padding:10px;'>Datum</th></tr>`;
    
    top10.forEach((item, idx) => {
      const bgColor = idx % 2 === 0 ? rowBg1 : rowBg2;
      const medal = idx === 0 ? "🥇" : idx === 1 ? "🥈" : idx === 2 ? "🥉" : "";
      const profilePic = profilePics[item.uid];
      html += `
        <tr style="background:${bgColor}; border-bottom:1px solid ${borderColor}; color:${textColor};">
          <td style="padding:10px; text-align:center;">${medal} ${idx + 1}</td>
          <td style="padding:10px; cursor:pointer;" onclick="openUserProfile('${item.uid}')">
            <img src="${profilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;">
            ${item.nickname}
          </td>
          <td style="padding:10px; font-weight:bold;">${item.score}</td>
          <td style="padding:10px; font-size:12px;">${item.date.toLocaleDateString("de-DE")}</td>
        </tr>
      `;
    });
    
    html += "</table>";
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error("Fehler beim Laden der Tower Rankings:", err);
    listEl.innerHTML = "<p>Fehler beim Laden der Rankings.</p>";
  }
}

/////////////////////////////////////////////////////////////////////////////
// WORDLE GAME 📝
/////////////////////////////////////////////////////////////////////////////

// Deutsche Wörterlisten
const WORDLE_WORDS = {
  4: ["HAUS", "BAUM", "BLAU", "TIER", "WIND", "BROT", "BOOT", "MEER", "BERG", "WALD", "LIED", "KIND", "HAND", "BEIN", "BUCH", "FELD", "ZELT", "GOLD", "VOGE", "FISC", "GRÜN", "ZAHN", "WORT", "TOLL", "WELT", "ZEIT", "WERK", "HUND", "RUND", "TANZ", "FILM", "BALL", "KOPF", "SALZ", "WARM", "KALT", "JUNG", "WILD", "MANN", "FRAU", "BIER", "WEIN", "HERZ", "GLAS", "RING", "TURM", "BANK"],
  5: ["STEIN", "WOLKE", "SONNE", "FEUER", "WASSER", "STERN", "BRIEF", "TISCH", "STUHL", "PFERD", "VOGEL", "FISCH", "BLUME", "GABEL", "FAHRT", "NACHT", "LICHT", "KUNST", "MUSIK", "TANTE", "ONKEL", "FREMD", "KREIS", "PUNKT", "STARK", "KLEIN", "BRAUN", "GRUEN", "TRAUM", "PIZZA", "KOHLE", "ZUNGE", "KNOPF", "LAMPE", "MAUER"],
  6: ["FENSTER", "HIMMEL", "GARTEN", "WOLKEN", "MENSCH", "KINDER", "HAEUSER", "BLUMEN", "TISCHE", "STUEHLE", "KATZEN", "VOEGEL", "FISCHE", "BUECHER", "STERNE", "LIEDER", "FARBEN", "STAEDTE", "LAENDER", "FREUND", "STRAND", "WINTER", "SOMMER", "HERBST", "MORGEN", "ABENDS", "RAKETE", "BRILLE", "SCHULE", "KAFFEE"]
};

let wordleWord = "";
let wordleLength = 5;
let wordleAttempts = 0;
let wordleMaxAttempts = 5;
let wordleGameActive = false;

// Wordle starten
window.startNewWordle = function() {
  wordleLength = parseInt(document.getElementById("wordleLength").value);
  const words = WORDLE_WORDS[wordleLength];
  wordleWord = words[Math.floor(Math.random() * words.length)].toUpperCase();
  wordleAttempts = 0;
  wordleGameActive = true;
  
  console.log("🎯 Wordle Wort:", wordleWord); // Debug
  
  // Grid erstellen
  const grid = document.getElementById("wordleGrid");
  grid.innerHTML = "";
  grid.style.display = "grid";
  grid.style.gridTemplateColumns = `repeat(${wordleLength}, 50px)`;
  grid.style.gap = "5px";
  grid.style.justifyContent = "center";
  
  for (let row = 0; row < wordleMaxAttempts; row++) {
    for (let col = 0; col < wordleLength; col++) {
      const cell = document.createElement("div");
      cell.className = "wordle-cell";
      cell.id = `wordle-${row}-${col}`;
      cell.style.width = "50px";
      cell.style.height = "50px";
      cell.style.border = "2px solid #444";
      cell.style.display = "flex";
      cell.style.alignItems = "center";
      cell.style.justifyContent = "center";
      cell.style.fontSize = "24px";
      cell.style.fontWeight = "bold";
      cell.style.borderRadius = "5px";
      cell.style.backgroundColor = "#222";
      grid.appendChild(cell);
    }
  }
  
  document.getElementById("wordleInput").value = "";
  document.getElementById("wordleInput").maxLength = wordleLength;
  document.getElementById("wordleStatus").textContent = `Versuche: ${wordleAttempts}/${wordleMaxAttempts}`;
};

// Wordle Guess verarbeiten
window.submitWordleGuess = async function() {
  if (!wordleGameActive) {
    showNotification("⚠️ Bitte starte zuerst ein neues Spiel!");
    return;
  }
  
  const input = document.getElementById("wordleInput").value.toUpperCase().trim();
  
  if (input.length !== wordleLength) {
    showNotification(`⚠️ Bitte ein ${wordleLength}-Buchstaben-Wort eingeben!`);
    return;
  }
  
  // Buchstaben in Grid eintragen und färben
  for (let i = 0; i < wordleLength; i++) {
    const cell = document.getElementById(`wordle-${wordleAttempts}-${i}`);
    const letter = input[i];
    cell.textContent = letter;
    cell.style.color = "#fff";
    
    // Farbe bestimmen
    if (wordleWord[i] === letter) {
      cell.style.backgroundColor = "#538d4e"; // Grün
    } else if (wordleWord.includes(letter)) {
      cell.style.backgroundColor = "#b59f3b"; // Gelb
    } else {
      cell.style.backgroundColor = "#3a3a3c"; // Grau
    }
  }
  
  wordleAttempts++;
  
  // Gewonnen?
  if (input === wordleWord) {
    wordleGameActive = false;
    const rewards = { 4: 10, 5: 15, 6: 20 };
    const coins = rewards[wordleLength];
    
    await addCoins(coins);
    await trackGamePlayed('wordle');
    
    document.getElementById("wordleStatus").innerHTML = `
      🎉 Gewonnen! Das Wort war: <strong>${wordleWord}</strong><br>
      +${coins} Münzen 🪙
    `;
    showNotification(`🎉 Richtig! +${coins} Münzen`);
    return;
  }
  
  // Verloren?
  if (wordleAttempts >= wordleMaxAttempts) {
    wordleGameActive = false;
    document.getElementById("wordleStatus").innerHTML = `
      ❌ Verloren! Das Wort war: <strong>${wordleWord}</strong>
    `;
    showNotification(`❌ Das Wort war: ${wordleWord}`);
    return;
  }
  
  // Nächster Versuch
  document.getElementById("wordleInput").value = "";
  document.getElementById("wordleStatus").textContent = `Versuche: ${wordleAttempts}/${wordleMaxAttempts}`;
};

// Init beim Laden
document.addEventListener('DOMContentLoaded', function() {
  if (document.getElementById("wordleGrid")) {
    startNewWordle();
  }
});

/////////////////////////////////////////////////////////////////////////////
// WER WIRD MILLIONÄR GAME 🏆
/////////////////////////////////////////////////////////////////////////////

const MILLIONAIRE_QUESTIONS = [
  // Frage 1-5 (Sehr Leicht) - 5, 10, 15, 20, 30
  {
    question: "Welche Farbe entsteht, wenn man Rot und Gelb mischt?",
    answers: ["Orange", "Grün", "Lila", "Braun"],
    correct: 0
  },
  {
    question: "Wie viele Beine hat eine Katze?",
    answers: ["2", "4", "6", "8"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Deutschland?",
    answers: ["München", "Hamburg", "Berlin", "Frankfurt"],
    correct: 2
  },
  {
    question: "Welches Tier bellt?",
    answers: ["Katze", "Hund", "Kuh", "Pferd"],
    correct: 1
  },
  {
    question: "Wie viele Stunden hat ein Tag?",
    answers: ["12", "20", "24", "30"],
    correct: 2
  },
  {
    question: "Welche Jahreszeit kommt nach dem Sommer?",
    answers: ["Frühling", "Winter", "Herbst", "Regen"],
    correct: 2
  },
  {
    question: "Was trinken Kühe?",
    answers: ["Wasser", "Milch", "Saft", "Limonade"],
    correct: 0
  },
  {
    question: "Welcher Tag kommt nach Montag?",
    answers: ["Mittwoch", "Dienstag", "Donnerstag", "Freitag"],
    correct: 1
  },
  {
    question: "Wie viele Finger hat eine Hand?",
    answers: ["4", "5", "6", "10"],
    correct: 1
  },
  {
    question: "Was ist 2 + 2?",
    answers: ["3", "4", "5", "6"],
    correct: 1
  },
  
  // Frage 11-20 (Leicht) - 50, 75, 100, 150, 200, 300, 400, 600, 800, 1000
  {
    question: "In welcher Stadt steht der Eiffelturm?",
    answers: ["London", "Paris", "Rom", "Madrid"],
    correct: 1
  },
  {
    question: "Welches ist das größte Säugetier der Welt?",
    answers: ["Elefant", "Blauwal", "Giraffe", "Nashorn"],
    correct: 1
  },
  {
    question: "Wie viele Kontinente gibt es?",
    answers: ["5", "6", "7", "8"],
    correct: 2
  },
  {
    question: "Welcher Planet ist der Sonne am nächsten?",
    answers: ["Venus", "Merkur", "Erde", "Mars"],
    correct: 1
  },
  {
    question: "Wie viele Spieler hat ein Fußballteam auf dem Feld?",
    answers: ["9", "10", "11", "12"],
    correct: 2
  },
  {
    question: "Wer malte die Mona Lisa?",
    answers: ["Picasso", "Van Gogh", "Leonardo da Vinci", "Rembrandt"],
    correct: 2
  },
  {
    question: "Welches Gas atmen Menschen ein?",
    answers: ["Sauerstoff", "Stickstoff", "Kohlendioxid", "Helium"],
    correct: 0
  },
  {
    question: "In welchem Jahr fiel die Berliner Mauer?",
    answers: ["1987", "1989", "1991", "1993"],
    correct: 1
  },
  {
    question: "Wie heißt der längste Fluss der Welt?",
    answers: ["Nil", "Amazonas", "Rhein", "Donau"],
    correct: 0
  },
  {
    question: "Welches Element hat das chemische Symbol 'H'?",
    answers: ["Helium", "Wasserstoff", "Eisen", "Quecksilber"],
    correct: 1
  },
  
  // Frage 21-30 (Mittel)
  {
    question: "Welches chemische Element hat das Symbol 'Au'?",
    answers: ["Silber", "Gold", "Kupfer", "Aluminium"],
    correct: 1
  },
  {
    question: "Wer schrieb 'Faust'?",
    answers: ["Schiller", "Goethe", "Kafka", "Lessing"],
    correct: 1
  },
  {
    question: "Wie viele Knochen hat ein erwachsener Mensch?",
    answers: ["186", "206", "226", "246"],
    correct: 1
  },
  {
    question: "In welchem Jahr begann der Erste Weltkrieg?",
    answers: ["1912", "1914", "1916", "1918"],
    correct: 1
  },
  {
    question: "Welche Geschwindigkeit hat Licht im Vakuum (ca.)?",
    answers: ["100.000 km/s", "200.000 km/s", "300.000 km/s", "400.000 km/s"],
    correct: 2
  },
  {
    question: "Wer erfand die Glühbirne?",
    answers: ["Nikola Tesla", "Thomas Edison", "Albert Einstein", "Alexander Bell"],
    correct: 1
  },
  {
    question: "Welche Sprache wird in Brasilien gesprochen?",
    answers: ["Spanisch", "Portugiesisch", "Französisch", "Italienisch"],
    correct: 1
  },
  {
    question: "Wie heißt der höchste Berg der Erde?",
    answers: ["K2", "Mount Everest", "Kilimandscharo", "Mont Blanc"],
    correct: 1
  },
  {
    question: "Welches Organ produziert Insulin?",
    answers: ["Leber", "Niere", "Bauchspeicheldrüse", "Magen"],
    correct: 2
  },
  {
    question: "In welchem Land wurde Pizza erfunden?",
    answers: ["Frankreich", "Spanien", "Griechenland", "Italien"],
    correct: 3
  },
  
  // Frage 31-40 (Schwer)
  {
    question: "Welcher römische Kaiser wurde an den Iden des März ermordet?",
    answers: ["Augustus", "Nero", "Julius Caesar", "Caligula"],
    correct: 2
  },
  {
    question: "Wie viele Symphonien komponierte Beethoven?",
    answers: ["7", "9", "11", "13"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Australien?",
    answers: ["Sydney", "Melbourne", "Canberra", "Brisbane"],
    correct: 2
  },
  {
    question: "Welches ist das kleinste Land der Welt?",
    answers: ["Monaco", "Vatikanstadt", "San Marino", "Liechtenstein"],
    correct: 1
  },
  {
    question: "In welchem Jahr wurde die Titanic versenkt?",
    answers: ["1910", "1912", "1914", "1916"],
    correct: 1
  },
  {
    question: "Welcher Künstler schnitt sich das Ohr ab?",
    answers: ["Picasso", "Van Gogh", "Dalí", "Monet"],
    correct: 1
  },
  {
    question: "Wie heißt der längste Fluss Europas?",
    answers: ["Donau", "Rhein", "Wolga", "Elbe"],
    correct: 2
  },
  {
    question: "Welche Temperatur hat absoluter Nullpunkt?",
    answers: ["-273,15°C", "-200°C", "-100°C", "-373,15°C"],
    correct: 0
  },
  {
    question: "Wer entwickelte die Relativitätstheorie?",
    answers: ["Isaac Newton", "Albert Einstein", "Stephen Hawking", "Niels Bohr"],
    correct: 1
  },
  {
    question: "Wie viele Zeitzonen hat Russland?",
    answers: ["7", "9", "11", "13"],
    correct: 2
  },
  
  // Frage 41-50 (Sehr Schwer)
  {
    question: "Welches Elementarteilchen wurde 2012 am CERN entdeckt?",
    answers: ["Quark", "Higgs-Boson", "Neutrino", "Photon"],
    correct: 1
  },
  {
    question: "Wer schrieb 'Also sprach Zarathustra'?",
    answers: ["Kant", "Hegel", "Nietzsche", "Schopenhauer"],
    correct: 2
  },
  {
    question: "Welcher Pharao ließ die größte Pyramide bauen?",
    answers: ["Ramses II", "Tutanchamun", "Cheops", "Snofru"],
    correct: 2
  },
  {
    question: "In welchem Jahr entdeckte Kolumbus Amerika?",
    answers: ["1488", "1492", "1498", "1502"],
    correct: 1
  },
  {
    question: "Wie lautet die chemische Formel von Schwefelsäure?",
    answers: ["H2SO3", "H2SO4", "H3PO4", "HCl"],
    correct: 1
  },
  {
    question: "Welcher Mathematiker formulierte das Unvollständigkeitstheorem?",
    answers: ["Gödel", "Euler", "Fermat", "Gauss"],
    correct: 0
  },
  {
    question: "Wie viele Bytes sind ein Terabyte?",
    answers: ["1.000.000.000", "1.073.741.824", "1.099.511.627.776", "1.000.000"],
    correct: 2
  },
  {
    question: "Welcher Maler gründete den Kubismus mit?",
    answers: ["Monet", "Picasso", "Kandinsky", "Klee"],
    correct: 1
  },
  {
    question: "In welchem Jahr endete der Dreißigjährige Krieg?",
    answers: ["1618", "1638", "1648", "1658"],
    correct: 2
  },
  {
    question: "Wie heißt die kleinste Einheit der DNA?",
    answers: ["Nukleon", "Nukleotid", "Nukleus", "Neutron"],
    correct: 1
  },
  
  // Frage 51-100 (Extrem Schwer & Mixed)
  {
    question: "Welches ist die schnellste Landtier der Welt?",
    answers: ["Gepard", "Löwe", "Gazelle", "Strauß"],
    correct: 0
  },
  {
    question: "Wie viele Zähne hat ein erwachsener Mensch normalerweise?",
    answers: ["28", "30", "32", "34"],
    correct: 2
  },
  {
    question: "Welche Währung wird in Japan verwendet?",
    answers: ["Yuan", "Won", "Yen", "Baht"],
    correct: 2
  },
  {
    question: "Wer komponierte die 'Kleine Nachtmusik'?",
    answers: ["Beethoven", "Mozart", "Bach", "Vivaldi"],
    correct: 1
  },
  {
    question: "Welches ist das härteste natürlich vorkommende Material?",
    answers: ["Stahl", "Diamant", "Titan", "Quarz"],
    correct: 1
  },
  {
    question: "In welchem Jahr wurde die Europäische Union gegründet?",
    answers: ["1957", "1967", "1977", "1993"],
    correct: 3
  },
  {
    question: "Wie heißt die Hauptstadt von Kanada?",
    answers: ["Toronto", "Vancouver", "Ottawa", "Montreal"],
    correct: 2
  },
  {
    question: "Welcher Ozean ist der größte?",
    answers: ["Atlantik", "Pazifik", "Indischer Ozean", "Arktischer Ozean"],
    correct: 1
  },
  {
    question: "Wer war der erste Mensch im Weltall?",
    answers: ["Neil Armstrong", "Buzz Aldrin", "Juri Gagarin", "John Glenn"],
    correct: 2
  },
  {
    question: "Wie viele Herzkammern hat ein menschliches Herz?",
    answers: ["2", "3", "4", "6"],
    correct: 2
  },
  {
    question: "Welches Gas macht den größten Teil der Erdatmosphäre aus?",
    answers: ["Sauerstoff", "Kohlendioxid", "Stickstoff", "Argon"],
    correct: 2
  },
  {
    question: "Wer schrieb 'Der alte Mann und das Meer'?",
    answers: ["Mark Twain", "Ernest Hemingway", "F. Scott Fitzgerald", "John Steinbeck"],
    correct: 1
  },
  {
    question: "Welche Programmiersprache wurde 1991 von Guido van Rossum entwickelt?",
    answers: ["Java", "C++", "Python", "Ruby"],
    correct: 2
  },
  {
    question: "Wie viele Sekunden hat ein Jahr (ungefähr)?",
    answers: ["31,5 Millionen", "36,5 Millionen", "41,5 Millionen", "46,5 Millionen"],
    correct: 0
  },
  {
    question: "Welcher Künstler malte 'Die Sternennacht'?",
    answers: ["Monet", "Van Gogh", "Renoir", "Cézanne"],
    correct: 1
  },
  {
    question: "Was ist die chemische Bezeichnung für Kochsalz?",
    answers: ["NaCl", "KCl", "CaCl2", "MgCl2"],
    correct: 0
  },
  {
    question: "Welcher ist der zweitgrößte Planet in unserem Sonnensystem?",
    answers: ["Jupiter", "Saturn", "Uranus", "Neptun"],
    correct: 1
  },
  {
    question: "Wer erfand das Telefon?",
    answers: ["Thomas Edison", "Nikola Tesla", "Alexander Graham Bell", "Guglielmo Marconi"],
    correct: 2
  },
  {
    question: "In welcher Stadt befindet sich das Kolosseum?",
    answers: ["Athen", "Rom", "Istanbul", "Kairo"],
    correct: 1
  },
  {
    question: "Wie heißt der größte Wüste der Welt?",
    answers: ["Sahara", "Gobi", "Antarktis", "Arabische Wüste"],
    correct: 2
  },
  {
    question: "Welches Tier legt die größten Eier?",
    answers: ["Emu", "Strauß", "Dinosaurier", "Kasuar"],
    correct: 1
  },
  {
    question: "Wie viele Bundesländer hat Deutschland?",
    answers: ["14", "15", "16", "17"],
    correct: 2
  },
  {
    question: "Welcher Schauspieler spielte Iron Man im MCU?",
    answers: ["Chris Evans", "Chris Hemsworth", "Robert Downey Jr.", "Mark Ruffalo"],
    correct: 2
  },
  {
    question: "Was ist die Quadratwurzel von 144?",
    answers: ["10", "11", "12", "13"],
    correct: 2
  },
  {
    question: "Welches Land hat die meisten Einwohner?",
    answers: ["Indien", "China", "USA", "Indonesien"],
    correct: 0
  },
  {
    question: "Wer schrieb 'Romeo und Julia'?",
    answers: ["Charles Dickens", "William Shakespeare", "Jane Austen", "Oscar Wilde"],
    correct: 1
  },
  {
    question: "Wie viele Tasten hat ein Klavier?",
    answers: ["76", "82", "88", "94"],
    correct: 2
  },
  {
    question: "Welches Element ist bei Raumtemperatur flüssig?",
    answers: ["Brom", "Quecksilber", "Beide", "Keines"],
    correct: 2
  },
  {
    question: "In welchem Jahr endete der Zweite Weltkrieg?",
    answers: ["1943", "1944", "1945", "1946"],
    correct: 2
  },
  {
    question: "Welcher Planet hat die meisten Monde?",
    answers: ["Jupiter", "Saturn", "Uranus", "Neptun"],
    correct: 1
  },
  {
    question: "Wie heißt der Erfinder des World Wide Web?",
    answers: ["Bill Gates", "Steve Jobs", "Tim Berners-Lee", "Mark Zuckerberg"],
    correct: 2
  },
  {
    question: "Welche Blutgruppe ist der Universalspender?",
    answers: ["A+", "B+", "AB+", "0-"],
    correct: 3
  },
  {
    question: "Wie viele Saiten hat eine Gitarre normalerweise?",
    answers: ["4", "5", "6", "7"],
    correct: 2
  },
  {
    question: "Welches ist das giftigste Tier der Welt?",
    answers: ["Kobra", "Skorpion", "Seewespe (Qualle)", "Pfeilgiftfrosch"],
    correct: 2
  },
  {
    question: "In welchem Land liegt die Stadt Machu Picchu?",
    answers: ["Mexiko", "Peru", "Chile", "Bolivien"],
    correct: 1
  },
  {
    question: "Was ist die Hauptzutat von Guacamole?",
    answers: ["Tomaten", "Avocado", "Paprika", "Zwiebel"],
    correct: 1
  },
  {
    question: "Wie heißt das längste Buch der Bibel?",
    answers: ["Genesis", "Psalmen", "Jesaja", "Matthäus"],
    correct: 1
  },
  {
    question: "Welcher Film gewann 11 Oscars im Jahr 2004?",
    answers: ["Gladiator", "Herr der Ringe: Die Rückkehr des Königs", "Titanic", "Avatar"],
    correct: 1
  },
  {
    question: "Was bedeutet 'HTTP' in einer URL?",
    answers: ["HyperText Transfer Protocol", "High Transfer Text Protocol", "Home Tool Transfer Protocol", "HyperText Technical Protocol"],
    correct: 0
  },
  {
    question: "Wie viele Olympische Ringe gibt es?",
    answers: ["3", "4", "5", "6"],
    correct: 2
  },
  {
    question: "Welche Stadt wird 'Die ewige Stadt' genannt?",
    answers: ["Athen", "Rom", "Jerusalem", "Kairo"],
    correct: 1
  },
  {
    question: "Wer war der erste Präsident der USA?",
    answers: ["Thomas Jefferson", "John Adams", "George Washington", "Benjamin Franklin"],
    correct: 2
  },
  {
    question: "Wie heißt die Angst vor Spinnen?",
    answers: ["Klaustrophobie", "Arachnophobie", "Agoraphobie", "Akrophobie"],
    correct: 1
  },
  {
    question: "Welches ist das meistverkaufte Videospiel aller Zeiten?",
    answers: ["Tetris", "Minecraft", "GTA V", "Wii Sports"],
    correct: 1
  },
  {
    question: "Was ist das chemische Symbol für Eisen?",
    answers: ["Ei", "Fe", "Ir", "En"],
    correct: 1
  },
  {
    question: "In welchem Jahr wurde Google gegründet?",
    answers: ["1996", "1998", "2000", "2002"],
    correct: 1
  },
  {
    question: "Wie viele Buchstaben hat das griechische Alphabet?",
    answers: ["22", "24", "26", "28"],
    correct: 1
  },
  {
    question: "Welcher Künstler ist bekannt für seine Campbell's Suppendosen?",
    answers: ["Pablo Picasso", "Andy Warhol", "Salvador Dalí", "Jackson Pollock"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Norwegen?",
    answers: ["Stockholm", "Helsinki", "Oslo", "Kopenhagen"],
    correct: 2
  },
  
  // Frage 101-200 (Erweiterte Fragen - Gemischt)
  {
    question: "Welches Vitamin wird durch Sonnenlicht produziert?",
    answers: ["Vitamin A", "Vitamin C", "Vitamin D", "Vitamin E"],
    correct: 2
  },
  {
    question: "Wie viele Seiten hat ein Würfel?",
    answers: ["4", "6", "8", "12"],
    correct: 1
  },
  {
    question: "Welcher Fluss fließt durch Paris?",
    answers: ["Rhein", "Seine", "Themse", "Donau"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Spanien?",
    answers: ["Barcelona", "Valencia", "Madrid", "Sevilla"],
    correct: 2
  },
  {
    question: "Wie viele Zentimeter sind ein Meter?",
    answers: ["10", "50", "100", "1000"],
    correct: 2
  },
  {
    question: "Welches Tier ist das Symbol von WWF?",
    answers: ["Tiger", "Panda", "Elefant", "Löwe"],
    correct: 1
  },
  {
    question: "Wie heißt der größte Knochen im menschlichen Körper?",
    answers: ["Oberarmknochen", "Oberschenkelknochen", "Schienbein", "Wirbelsäule"],
    correct: 1
  },
  {
    question: "Welcher Planet ist als 'Roter Planet' bekannt?",
    answers: ["Venus", "Mars", "Jupiter", "Saturn"],
    correct: 1
  },
  {
    question: "Wie viele Nullen hat eine Million?",
    answers: ["5", "6", "7", "8"],
    correct: 1
  },
  {
    question: "Welches Land hat die Form eines Stiefels?",
    answers: ["Griechenland", "Spanien", "Italien", "Kroatien"],
    correct: 2
  },
  {
    question: "Was ist H2O?",
    answers: ["Wasserstoffperoxid", "Wasser", "Salzsäure", "Sauerstoff"],
    correct: 1
  },
  {
    question: "Wie nennt man ein Baby-Pferd?",
    answers: ["Kalb", "Lamm", "Fohlen", "Ferkel"],
    correct: 2
  },
  {
    question: "Welche Farbe hat ein Smaragd?",
    answers: ["Rot", "Blau", "Grün", "Gelb"],
    correct: 2
  },
  {
    question: "Wie viele Ecken hat ein Dreieck?",
    answers: ["2", "3", "4", "5"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von England?",
    answers: ["Manchester", "Liverpool", "London", "Birmingham"],
    correct: 2
  },
  {
    question: "Welches Tier kann nicht rückwärts laufen?",
    answers: ["Pferd", "Känguru", "Elefant", "Giraffe"],
    correct: 1
  },
  {
    question: "Wie viele Monate haben 31 Tage?",
    answers: ["5", "6", "7", "8"],
    correct: 2
  },
  {
    question: "Was ist die schnellste Geschwindigkeit: Schall oder Licht?",
    answers: ["Schall", "Licht", "Gleich schnell", "Kommt drauf an"],
    correct: 1
  },
  {
    question: "Welches Organ filtert das Blut?",
    answers: ["Herz", "Lunge", "Niere", "Leber"],
    correct: 2
  },
  {
    question: "Wie heißt das größte Tier der Welt?",
    answers: ["Elefant", "Blauwal", "Giraffe", "Hai"],
    correct: 1
  },
  {
    question: "Welche Farbe entsteht aus Blau und Gelb?",
    answers: ["Grün", "Lila", "Orange", "Braun"],
    correct: 0
  },
  {
    question: "Wie viele Grad hat ein rechter Winkel?",
    answers: ["45", "60", "90", "180"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Frankreich?",
    answers: ["Lyon", "Marseille", "Paris", "Nizza"],
    correct: 2
  },
  {
    question: "Welches Gas atmen Pflanzen ein?",
    answers: ["Sauerstoff", "Kohlendioxid", "Stickstoff", "Helium"],
    correct: 1
  },
  {
    question: "Wie nennt man ein junges Schaf?",
    answers: ["Kalb", "Lamm", "Fohlen", "Welpe"],
    correct: 1
  },
  {
    question: "Welcher Kontinent ist der größte?",
    answers: ["Afrika", "Amerika", "Asien", "Europa"],
    correct: 2
  },
  {
    question: "Was ist die Summe der Winkel in einem Dreieck?",
    answers: ["90°", "180°", "270°", "360°"],
    correct: 1
  },
  {
    question: "Welches Metall ist bei Raumtemperatur flüssig?",
    answers: ["Gold", "Silber", "Quecksilber", "Blei"],
    correct: 2
  },
  {
    question: "Wie viele Wochen hat ein Jahr (ca.)?",
    answers: ["48", "50", "52", "54"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Österreich?",
    answers: ["Salzburg", "Graz", "Wien", "Innsbruck"],
    correct: 2
  },
  {
    question: "Welcher Berg ist der höchste in Afrika?",
    answers: ["Mount Kenya", "Kilimandscharo", "Atlas", "Drakensberg"],
    correct: 1
  },
  {
    question: "Wie heißt der kleinste Planet in unserem Sonnensystem?",
    answers: ["Mars", "Merkur", "Venus", "Pluto"],
    correct: 1
  },
  {
    question: "Was bedeutet 'PC' in der Informatik?",
    answers: ["Private Computer", "Personal Computer", "Public Computer", "Portable Computer"],
    correct: 1
  },
  {
    question: "Welches ist das häufigste Element im Universum?",
    answers: ["Sauerstoff", "Kohlenstoff", "Wasserstoff", "Helium"],
    correct: 2
  },
  {
    question: "Wie viele Spieler sind in einem Basketballteam auf dem Feld?",
    answers: ["4", "5", "6", "7"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Schweden?",
    answers: ["Oslo", "Kopenhagen", "Stockholm", "Helsinki"],
    correct: 2
  },
  {
    question: "Welches Tier lebt am längsten?",
    answers: ["Elefant", "Schildkröte", "Wal", "Papagei"],
    correct: 2
  },
  {
    question: "Wie nennt man die Wissenschaft von den Sternen?",
    answers: ["Astrologie", "Astronomie", "Geologie", "Biologie"],
    correct: 1
  },
  {
    question: "Was ist die kleinste Einheit des Lebens?",
    answers: ["Atom", "Molekül", "Zelle", "Organ"],
    correct: 2
  },
  {
    question: "Wie viele Gramm sind ein Kilogramm?",
    answers: ["10", "100", "1000", "10000"],
    correct: 2
  },
  {
    question: "Welcher Ozean liegt zwischen Europa und Amerika?",
    answers: ["Pazifik", "Atlantik", "Indischer Ozean", "Arktischer Ozean"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Portugal?",
    answers: ["Porto", "Lissabon", "Faro", "Coimbra"],
    correct: 1
  },
  {
    question: "Wie heißt der höchste Wasserfall der Welt?",
    answers: ["Niagarafälle", "Victoriafälle", "Iguazú-Wasserfälle", "Salto Ángel"],
    correct: 3
  },
  {
    question: "Welches ist das einzige Säugetier, das fliegen kann?",
    answers: ["Flughund", "Fledermaus", "Gleithörnchen", "Fliegender Fisch"],
    correct: 1
  },
  {
    question: "Was ist die Währung von Japan?",
    answers: ["Yuan", "Won", "Yen", "Baht"],
    correct: 2
  },
  {
    question: "Wie viele Farben hat ein Regenbogen?",
    answers: ["5", "6", "7", "8"],
    correct: 2
  },
  {
    question: "Welches Land hat die meisten Nachbarländer?",
    answers: ["Deutschland", "China", "Russland", "Brasilien"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Griechenland?",
    answers: ["Thessaloniki", "Athen", "Korinth", "Sparta"],
    correct: 1
  },
  {
    question: "Wie nennt man den Übergang vom Tag zur Nacht?",
    answers: ["Morgendämmerung", "Dämmerung", "Abenddämmerung", "Mitternacht"],
    correct: 2
  },
  {
    question: "Welches Tier hat drei Herzen?",
    answers: ["Oktopus", "Tintenfisch", "Beide", "Keines"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Dänemark?",
    answers: ["Oslo", "Stockholm", "Kopenhagen", "Reykjavik"],
    correct: 2
  },
  {
    question: "Wie viele Minuten sind zwei Stunden?",
    answers: ["60", "100", "120", "140"],
    correct: 2
  },
  {
    question: "Welcher Künstler malte die 'Guernica'?",
    answers: ["Dalí", "Picasso", "Miró", "Goya"],
    correct: 1
  },
  {
    question: "Was ist der pH-Wert von neutralem Wasser?",
    answers: ["0", "7", "10", "14"],
    correct: 1
  },
  {
    question: "Wie heißt die Hauptstadt der Schweiz?",
    answers: ["Zürich", "Genf", "Bern", "Basel"],
    correct: 2
  },
  {
    question: "Welches Tier kann am höchsten springen?",
    answers: ["Känguru", "Floh", "Gepard", "Delfin"],
    correct: 1
  },
  {
    question: "Was ist die kleinste Primzahl?",
    answers: ["0", "1", "2", "3"],
    correct: 2
  },
  {
    question: "Wie viele Kontinente gibt es auf der Erde?",
    answers: ["5", "6", "7", "8"],
    correct: 2
  },
  {
    question: "Welches Element hat das Symbol 'O'?",
    answers: ["Gold", "Osmium", "Sauerstoff", "Oktan"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Belgien?",
    answers: ["Antwerpen", "Brügge", "Brüssel", "Gent"],
    correct: 2
  },
  {
    question: "Wie heißt der größte See Afrikas?",
    answers: ["Tanganjikasee", "Malawisee", "Victoriasee", "Tschadsee"],
    correct: 2
  },
  {
    question: "Welches Tier hat den längsten Hals?",
    answers: ["Kamel", "Strauß", "Giraffe", "Schwan"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Polen?",
    answers: ["Krakau", "Warschau", "Danzig", "Breslau"],
    correct: 1
  },
  {
    question: "Wie viele Bits sind ein Byte?",
    answers: ["4", "8", "16", "32"],
    correct: 1
  },
  {
    question: "Welcher Planet hat einen großen roten Fleck?",
    answers: ["Mars", "Jupiter", "Saturn", "Neptun"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Tschechien?",
    answers: ["Bratislava", "Prag", "Brünn", "Pilsen"],
    correct: 1
  },
  {
    question: "Wie nennt man ein Wort, das vorwärts und rückwärts gleich ist?",
    answers: ["Anagramm", "Palindrom", "Homonym", "Synonym"],
    correct: 1
  },
  {
    question: "Welches ist das leichteste Element?",
    answers: ["Helium", "Wasserstoff", "Lithium", "Kohlenstoff"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Ungarn?",
    answers: ["Prag", "Bratislava", "Budapest", "Bukarest"],
    correct: 2
  },
  {
    question: "Wie viele Augen hat eine Spinne normalerweise?",
    answers: ["2", "4", "6", "8"],
    correct: 3
  },
  {
    question: "Welcher Kontinent hat die meisten Länder?",
    answers: ["Europa", "Asien", "Afrika", "Südamerika"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Irland?",
    answers: ["Cork", "Galway", "Dublin", "Limerick"],
    correct: 2
  },
  {
    question: "Wie heißt die Lehre von den Lebewesen?",
    answers: ["Physik", "Chemie", "Biologie", "Geologie"],
    correct: 2
  },
  {
    question: "Welches Tier legt Eier und säugt seine Jungen?",
    answers: ["Krokodil", "Schnabeltier", "Eidechse", "Schildkröte"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Finnland?",
    answers: ["Stockholm", "Oslo", "Helsinki", "Kopenhagen"],
    correct: 2
  },
  {
    question: "Wie viele Herzen hat ein Regenwurm?",
    answers: ["1", "3", "5", "10"],
    correct: 2
  },
  {
    question: "Welcher Planet dreht sich am schnellsten?",
    answers: ["Erde", "Mars", "Jupiter", "Saturn"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Kroatien?",
    answers: ["Split", "Dubrovnik", "Zagreb", "Rijeka"],
    correct: 2
  },
  {
    question: "Wie nennt man die Furcht vor engen Räumen?",
    answers: ["Agoraphobie", "Klaustrophobie", "Akrophobie", "Arachnophobie"],
    correct: 1
  },
  {
    question: "Welches ist das härteste Mineral?",
    answers: ["Quarz", "Topas", "Korund", "Diamant"],
    correct: 3
  },
  {
    question: "Was ist die Hauptstadt von Slowenien?",
    answers: ["Maribor", "Ljubljana", "Celje", "Koper"],
    correct: 1
  },
  {
    question: "Wie viele Liter Blut hat ein erwachsener Mensch ca.?",
    answers: ["3", "5", "7", "10"],
    correct: 1
  },
  {
    question: "Welches Land hat die meisten Vulkane?",
    answers: ["Island", "Japan", "Indonesien", "Italien"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Lettland?",
    answers: ["Tallinn", "Vilnius", "Riga", "Minsk"],
    correct: 2
  },
  {
    question: "Wie heißt die größte Insel der Welt?",
    answers: ["Madagaskar", "Grönland", "Neuguinea", "Borneo"],
    correct: 1
  },
  {
    question: "Welches Element hat das Symbol 'Ag'?",
    answers: ["Gold", "Silber", "Aluminium", "Argentinien"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Estland?",
    answers: ["Riga", "Vilnius", "Tallinn", "Helsinki"],
    correct: 2
  },
  {
    question: "Wie viele Chromosomen hat ein Mensch?",
    answers: ["23", "46", "92", "100"],
    correct: 1
  },
  {
    question: "Welcher Erfinder hatte über 1000 Patente?",
    answers: ["Einstein", "Edison", "Tesla", "Bell"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Litauen?",
    answers: ["Riga", "Tallinn", "Vilnius", "Warschau"],
    correct: 2
  },
  {
    question: "Wie nennt man die Lehre von der Erde?",
    answers: ["Geografie", "Geologie", "Geometrie", "Geopolitik"],
    correct: 1
  },
  {
    question: "Welches Tier kann seine Farbe ändern?",
    answers: ["Frosch", "Chamäleon", "Eidechse", "Schlange"],
    correct: 1
  },
  
  // Neue Fragen 151-250
  {
    question: "Wie viele Zehen hat eine Katze an den Vorderpfoten?",
    answers: ["4", "5", "6", "8"],
    correct: 1
  },
  {
    question: "Welches ist das einzige Land, das aus einem ganzen Kontinent besteht?",
    answers: ["Russland", "Australien", "Kanada", "Brasilien"],
    correct: 1
  },
  {
    question: "Was bedeutet 'www' in einer Internetadresse?",
    answers: ["World Wide Web", "World Web Works", "Web World Wide", "Western Web World"],
    correct: 0
  },
  {
    question: "Wie heißt die Hauptstadt von Island?",
    answers: ["Akureyri", "Reykjavik", "Kópavogur", "Hafnarfjörður"],
    correct: 1
  },
  {
    question: "Welcher Monat hat die wenigsten Tage?",
    answers: ["Januar", "Februar", "November", "Dezember"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Neuseeland?",
    answers: ["Auckland", "Wellington", "Christchurch", "Hamilton"],
    correct: 1
  },
  {
    question: "Wie viele Knochen hat ein erwachsener Mensch?",
    answers: ["186", "206", "226", "246"],
    correct: 1
  },
  {
    question: "Welcher Ozean ist der salzigste?",
    answers: ["Pazifik", "Atlantik", "Indischer Ozean", "Rotes Meer"],
    correct: 3
  },
  {
    question: "Was ist das schwerste Organ im menschlichen Körper?",
    answers: ["Gehirn", "Herz", "Leber", "Haut"],
    correct: 3
  },
  {
    question: "Wie heißt der höchste Berg in den Alpen?",
    answers: ["Matterhorn", "Mont Blanc", "Eiger", "Zugspitze"],
    correct: 1
  },
  {
    question: "Welches Land hat die längste Küste der Welt?",
    answers: ["Australien", "Russland", "Kanada", "USA"],
    correct: 2
  },
  {
    question: "Was ist die Währung von Südkorea?",
    answers: ["Yen", "Yuan", "Won", "Baht"],
    correct: 2
  },
  {
    question: "Wie viele Augenlider hat ein Kamel?",
    answers: ["2", "3", "4", "6"],
    correct: 1
  },
  {
    question: "Welcher Fluss ist der längste in Europa?",
    answers: ["Donau", "Rhein", "Wolga", "Elbe"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Argentinien?",
    answers: ["Córdoba", "Rosario", "Buenos Aires", "Mendoza"],
    correct: 2
  },
  {
    question: "Wie nennt man ein Tier, das nur Pflanzen frisst?",
    answers: ["Karnivore", "Herbivore", "Omnivore", "Insektivore"],
    correct: 1
  },
  {
    question: "Welches Element hat das chemische Symbol 'Cu'?",
    answers: ["Kobalt", "Kupfer", "Calcium", "Kohlenstoff"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Brasilien?",
    answers: ["Rio de Janeiro", "São Paulo", "Brasília", "Salvador"],
    correct: 2
  },
  {
    question: "Wie viele Atemzüge macht ein Mensch pro Minute durchschnittlich?",
    answers: ["8-12", "12-20", "20-30", "30-40"],
    correct: 1
  },
  {
    question: "Welcher Vogel kann nicht fliegen?",
    answers: ["Papagei", "Adler", "Pinguin", "Kolibri"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Mexiko?",
    answers: ["Guadalajara", "Monterrey", "Mexiko-Stadt", "Cancún"],
    correct: 2
  },
  {
    question: "Wie heißt die größte Wüste Asiens?",
    answers: ["Taklamakan", "Gobi", "Thar", "Karakum"],
    correct: 1
  },
  {
    question: "Welches Vitamin ist auch als Ascorbinsäure bekannt?",
    answers: ["Vitamin A", "Vitamin B", "Vitamin C", "Vitamin D"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Chile?",
    answers: ["Valparaíso", "Santiago", "Concepción", "Viña del Mar"],
    correct: 1
  },
  {
    question: "Wie viele Herzen hat eine Krake?",
    answers: ["1", "2", "3", "4"],
    correct: 2
  },
  {
    question: "Welcher Planet ist der Erde am nächsten?",
    answers: ["Mars", "Venus", "Merkur", "Jupiter"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Ägypten?",
    answers: ["Alexandria", "Kairo", "Gizeh", "Luxor"],
    correct: 1
  },
  {
    question: "Wie nennt man die Angst vor Höhe?",
    answers: ["Agoraphobie", "Klaustrophobie", "Akrophobie", "Arachnophobie"],
    correct: 2
  },
  {
    question: "Welches ist das kleinste Land der Welt?",
    answers: ["Monaco", "Vatikanstadt", "San Marino", "Liechtenstein"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Thailand?",
    answers: ["Phuket", "Chiang Mai", "Bangkok", "Pattaya"],
    correct: 2
  },
  {
    question: "Wie viele Rippen hat ein Mensch normalerweise?",
    answers: ["20", "22", "24", "26"],
    correct: 2
  },
  {
    question: "Welcher Berg ist der höchste außerhalb Asiens?",
    answers: ["Mount McKinley", "Aconcagua", "Kilimandscharo", "Mont Blanc"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Südafrika (eine von drei)?",
    answers: ["Johannesburg", "Pretoria", "Durban", "Port Elizabeth"],
    correct: 1
  },
  {
    question: "Wie heißt der größte Mond des Saturn?",
    answers: ["Europa", "Titan", "Ganymed", "Io"],
    correct: 1
  },
  {
    question: "Welches Element hat das Symbol 'Pb'?",
    answers: ["Platin", "Blei", "Palladium", "Phosphor"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Marokko?",
    answers: ["Casablanca", "Marrakesch", "Rabat", "Fès"],
    correct: 2
  },
  {
    question: "Wie viele Kammern hat der Magen einer Kuh?",
    answers: ["1", "2", "3", "4"],
    correct: 3
  },
  {
    question: "Welcher Fluss fließt durch London?",
    answers: ["Severn", "Themse", "Trent", "Mersey"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Peru?",
    answers: ["Cusco", "Arequipa", "Lima", "Trujillo"],
    correct: 2
  },
  {
    question: "Wie nennt man ein Tier, das sowohl Pflanzen als auch Fleisch frisst?",
    answers: ["Karnivore", "Herbivore", "Omnivore", "Insektivore"],
    correct: 2
  },
  {
    question: "Welches ist das schnellste Tier im Wasser?",
    answers: ["Delfin", "Hai", "Marlin", "Schwertfisch"],
    correct: 3
  },
  {
    question: "Was ist die Hauptstadt von Vietnam?",
    answers: ["Ho-Chi-Minh-Stadt", "Hanoi", "Da Nang", "Hội An"],
    correct: 1
  },
  {
    question: "Wie viele Zähne hat ein erwachsener Hund?",
    answers: ["32", "36", "42", "48"],
    correct: 2
  },
  {
    question: "Welcher Planet hat die meisten Ringe?",
    answers: ["Jupiter", "Saturn", "Uranus", "Neptun"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Kenia?",
    answers: ["Mombasa", "Nairobi", "Kisumu", "Nakuru"],
    correct: 1
  },
  {
    question: "Wie heißt die Wissenschaft von den Pilzen?",
    answers: ["Botanik", "Mykologie", "Zoologie", "Mikrobiologie"],
    correct: 1
  },
  {
    question: "Welches ist das giftigste Land-Tier?",
    answers: ["Schwarze Mamba", "Pfeilgiftfrosch", "Skorpion", "Spinne"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Kolumbien?",
    answers: ["Medellín", "Cali", "Bogotá", "Cartagena"],
    correct: 2
  },
  {
    question: "Wie viele Beine hat eine Ameise?",
    answers: ["4", "6", "8", "10"],
    correct: 1
  },
  {
    question: "Welcher Fluss ist der längste in Südamerika?",
    answers: ["Orinoco", "Paraná", "Amazonas", "São Francisco"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Malaysia?",
    answers: ["Penang", "Johor Bahru", "Kuala Lumpur", "Malakka"],
    correct: 2
  },
  {
    question: "Wie nennt man die Lehre von den Pflanzen?",
    answers: ["Botanik", "Biologie", "Zoologie", "Geologie"],
    correct: 0
  },
  {
    question: "Welches Element hat das Symbol 'Hg'?",
    answers: ["Helium", "Wasserstoff", "Quecksilber", "Hafnium"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Singapur?",
    answers: ["Singapur", "Johor", "Malakka", "Kuala Lumpur"],
    correct: 0
  },
  {
    question: "Wie viele Lungen hat ein Mensch?",
    answers: ["1", "2", "3", "4"],
    correct: 1
  },
  {
    question: "Welcher ist der größte Regenwald der Welt?",
    answers: ["Kongo-Regenwald", "Amazonas-Regenwald", "Borneo-Regenwald", "Madagaskar"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Venezuela?",
    answers: ["Maracaibo", "Valencia", "Caracas", "Barquisimeto"],
    correct: 2
  },
  {
    question: "Wie heißt das größte Korallenriff der Welt?",
    answers: ["Great Barrier Reef", "Belize Barrier Reef", "Florida Reef", "Rotes Meer Riff"],
    correct: 0
  },
  {
    question: "Welches Tier hat das stärkste Gift?",
    answers: ["Kobra", "Taipan", "Seewespe", "Pfeilgiftfrosch"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Ecuador?",
    answers: ["Guayaquil", "Cuenca", "Quito", "Manta"],
    correct: 2
  },
  {
    question: "Wie viele Augen hat eine Biene?",
    answers: ["2", "3", "5", "6"],
    correct: 2
  },
  {
    question: "Welcher ist der tiefste Punkt der Erde?",
    answers: ["Puerto-Rico-Graben", "Java-Graben", "Marianengraben", "Tonga-Graben"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Philippinen?",
    answers: ["Cebu", "Davao", "Manila", "Quezon City"],
    correct: 2
  },
  {
    question: "Wie nennt man ein Tier ohne Wirbelsäule?",
    answers: ["Wirbellos", "Invertebrat", "Vertebrat", "Spineless"],
    correct: 1
  },
  {
    question: "Welches Land hat die meisten Zeitzonen?",
    answers: ["USA", "Russland", "Kanada", "Frankreich"],
    correct: 3
  },
  {
    question: "Was ist die Hauptstadt von Pakistan?",
    answers: ["Karachi", "Lahore", "Islamabad", "Faisalabad"],
    correct: 2
  },
  {
    question: "Wie viele Monde hat der Mars?",
    answers: ["0", "1", "2", "3"],
    correct: 2
  },
  {
    question: "Welcher Baum wird am ältesten?",
    answers: ["Eiche", "Mammutbaum", "Borstenkiefer", "Baobab"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Bangladesch?",
    answers: ["Chittagong", "Dhaka", "Khulna", "Sylhet"],
    correct: 1
  },
  {
    question: "Wie viele Flügel hat eine Biene?",
    answers: ["2", "4", "6", "8"],
    correct: 1
  },
  {
    question: "Welcher ist der größte Gletscher außerhalb der Polarregionen?",
    answers: ["Aletschgletscher", "Fedtschenko-Gletscher", "Siachen-Gletscher", "Vatnajökull"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Uruguay?",
    answers: ["Punta del Este", "Montevideo", "Salto", "Colonia"],
    correct: 1
  },
  {
    question: "Wie nennt man die Lehre von den Insekten?",
    answers: ["Entomologie", "Arachnologie", "Herpetologie", "Ornithologie"],
    correct: 0
  },
  {
    question: "Welches Tier hat die längste Lebensdauer?",
    answers: ["Grönlandwal", "Riesenschildkröte", "Grönlandhai", "Elefant"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Myanmar?",
    answers: ["Rangun", "Naypyidaw", "Mandalay", "Bagan"],
    correct: 1
  },
  {
    question: "Wie viele Herzen hat ein Tintenfisch?",
    answers: ["1", "2", "3", "4"],
    correct: 2
  },
  {
    question: "Welcher ist der kälteste bewohnte Ort der Erde?",
    answers: ["Jakutsk", "Oimjakon", "Werchojansk", "Norilsk"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Kambodscha?",
    answers: ["Siem Reap", "Phnom Penh", "Battambang", "Sihanoukville"],
    correct: 1
  },
  {
    question: "Wie viele Gehirnhälften hat ein Mensch?",
    answers: ["1", "2", "3", "4"],
    correct: 1
  },
  {
    question: "Welches ist das lauteste Tier der Welt?",
    answers: ["Löwe", "Elefant", "Blauwal", "Brüllaffe"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Bolivien?",
    answers: ["La Paz", "Sucre", "Santa Cruz", "Cochabamba"],
    correct: 1
  },
  {
    question: "Wie nennt man Tiere, die nachts aktiv sind?",
    answers: ["Diurnal", "Nokturnal", "Krepuskular", "Kathemeral"],
    correct: 1
  },
  {
    question: "Welcher Fluss fließt durch Ägypten?",
    answers: ["Euphrat", "Tigris", "Nil", "Jordan"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Laos?",
    answers: ["Luang Prabang", "Vientiane", "Pakse", "Savannakhet"],
    correct: 1
  },
  {
    question: "Wie viele Beine hat eine Spinne?",
    answers: ["6", "8", "10", "12"],
    correct: 1
  },
  {
    question: "Welches ist das größte Lebewesen der Welt?",
    answers: ["Blauwal", "Riesenmammutbaum", "Hallimasch", "Elefant"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Nepal?",
    answers: ["Pokhara", "Kathmandu", "Lalitpur", "Biratnagar"],
    correct: 1
  },
  {
    question: "Wie heißt die größte Bucht der Welt?",
    answers: ["Golf von Mexiko", "Bucht von Bengalen", "Hudsonbai", "Große Australische Bucht"],
    correct: 1
  },
  {
    question: "Welches Element hat das Symbol 'Sn'?",
    answers: ["Silber", "Zinn", "Natrium", "Schwefel"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Sri Lanka?",
    answers: ["Colombo", "Sri Jayawardenepura Kotte", "Kandy", "Galle"],
    correct: 1
  },
  {
    question: "Wie viele Wirbel hat ein menschlicher Rücken?",
    answers: ["24", "33", "42", "50"],
    correct: 1
  },
  {
    question: "Welcher ist der höchste aktive Vulkan?",
    answers: ["Vesuv", "Ätna", "Ojos del Salado", "Kilimandscharo"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Afghanistan?",
    answers: ["Herat", "Kandahar", "Kabul", "Masar-e Scharif"],
    correct: 2
  },
  {
    question: "Wie nennt man die Lehre von den Vögeln?",
    answers: ["Ornithologie", "Entomologie", "Ichthyologie", "Herpetologie"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Rumänien?",
    answers: ["Budapest", "Sofia", "Bukarest", "Belgrad"],
    correct: 2
  },
  {
    question: "Wie viele Beine hat ein Insekt?",
    answers: ["4", "6", "8", "10"],
    correct: 1
  },
  {
    question: "Welcher ist der tiefste Punkt der Erde?",
    answers: ["Marianengraben", "Puerto-Rico-Graben", "Java-Graben", "Tonga-Graben"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Bulgarien?",
    answers: ["Belgrad", "Bukarest", "Sofia", "Skopje"],
    correct: 2
  },
  {
    question: "Wie heißt der größte Mond im Sonnensystem?",
    answers: ["Titan", "Ganymed", "Europa", "Kallisto"],
    correct: 1
  },
  {
    question: "Welches Element hat das Symbol 'Cu'?",
    answers: ["Kobalt", "Kupfer", "Chrom", "Calcium"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Serbien?",
    answers: ["Sofia", "Bukarest", "Belgrad", "Zagreb"],
    correct: 2
  },
  {
    question: "Wie viele Zähne hat ein erwachsener Hai ca.?",
    answers: ["50", "100", "300", "3000"],
    correct: 2
  },
  {
    question: "Welche Stadt ist auch als 'Big Apple' bekannt?",
    answers: ["Los Angeles", "Chicago", "New York", "Boston"],
    correct: 2
  },
  
  // Neue Fragen 251-350
  {
    question: "Wie viele Sekunden hat eine Stunde?",
    answers: ["1800", "3600", "7200", "10800"],
    correct: 1
  },
  {
    question: "Welcher Vogel legt die größten Eier?",
    answers: ["Strauß", "Emu", "Albatros", "Kondor"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Jordanien?",
    answers: ["Aqaba", "Petra", "Amman", "Irbid"],
    correct: 2
  },
  {
    question: "Wie nennt man einen weiblichen Fuchs?",
    answers: ["Füchsin", "Fuchsdame", "Fähe", "Foxine"],
    correct: 2
  },
  {
    question: "Welches ist das größte Land in Afrika?",
    answers: ["Sudan", "Libyen", "Algerien", "Kongo"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Libanon?",
    answers: ["Tripoli", "Sidon", "Beirut", "Tyrus"],
    correct: 2
  },
  {
    question: "Wie viele Rippen hat eine Giraffe?",
    answers: ["14", "16", "18", "20"],
    correct: 0
  },
  {
    question: "Welcher Planet dreht sich rückwärts?",
    answers: ["Merkur", "Venus", "Mars", "Uranus"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Tunesien?",
    answers: ["Sfax", "Sousse", "Tunis", "Kairouan"],
    correct: 2
  },
  {
    question: "Wie heißt der größte Diamant der Welt?",
    answers: ["Hope", "Regent", "Cullinan", "Koh-i-Noor"],
    correct: 2
  },
  {
    question: "Welches Tier hat die längste Zunge?",
    answers: ["Giraffe", "Chamäleon", "Ameisenbär", "Kolibri"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Kuba?",
    answers: ["Santiago", "Havanna", "Guantánamo", "Holguín"],
    correct: 1
  },
  {
    question: "Wie viele Millimeter sind ein Zentimeter?",
    answers: ["5", "10", "50", "100"],
    correct: 1
  },
  {
    question: "Welcher Berg ist der höchste in Nordamerika?",
    answers: ["Mount Logan", "Denali", "Mount Whitney", "Mount Rainier"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Algerien?",
    answers: ["Oran", "Constantine", "Algier", "Annaba"],
    correct: 2
  },
  {
    question: "Wie nennt man die Angst vor Wasser?",
    answers: ["Hydrophobie", "Aquaphobie", "Thalassophobie", "Beide A+B"],
    correct: 3
  },
  {
    question: "Welches ist das häufigste Gas in der Luft?",
    answers: ["Sauerstoff", "Stickstoff", "Kohlendioxid", "Argon"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Äthiopien?",
    answers: ["Nairobi", "Kampala", "Addis Abeba", "Asmara"],
    correct: 2
  },
  {
    question: "Wie viele Tentakel hat ein Tintenfisch?",
    answers: ["6", "8", "10", "12"],
    correct: 1
  },
  {
    question: "Welcher Fluss ist der längste in Deutschland?",
    answers: ["Elbe", "Rhein", "Donau", "Main"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Ghana?",
    answers: ["Lagos", "Abuja", "Accra", "Kumasi"],
    correct: 2
  },
  {
    question: "Wie heißt das größte Raubtier an Land?",
    answers: ["Sibirischer Tiger", "Löwe", "Eisbär", "Braunbär"],
    correct: 2
  },
  {
    question: "Welches Element hat das Symbol 'K'?",
    answers: ["Kobalt", "Kalium", "Kadmium", "Krypton"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Senegal?",
    answers: ["Abidjan", "Bamako", "Dakar", "Conakry"],
    correct: 2
  },
  {
    question: "Wie viele Quadrate sind auf einem Schachbrett?",
    answers: ["64", "81", "100", "204"],
    correct: 3
  },
  {
    question: "Welcher Ozean ist der kleinste?",
    answers: ["Indischer Ozean", "Arktischer Ozean", "Atlantik", "Südlicher Ozean"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Tansania?",
    answers: ["Daressalam", "Dodoma", "Arusha", "Mwanza"],
    correct: 1
  },
  {
    question: "Wie nennt man ein Tier, das Eier legt?",
    answers: ["Ovipar", "Vivipar", "Ovovivipar", "Placentar"],
    correct: 0
  },
  {
    question: "Welcher Planet hat den kürzesten Tag?",
    answers: ["Merkur", "Venus", "Jupiter", "Saturn"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Uganda?",
    answers: ["Nairobi", "Dodoma", "Kampala", "Kigali"],
    correct: 2
  },
  {
    question: "Wie viele Zähne hat ein Elefant zum Kauen?",
    answers: ["2", "4", "8", "32"],
    correct: 1
  },
  {
    question: "Welches ist das giftigste Element?",
    answers: ["Arsen", "Plutonium", "Polonium", "Quecksilber"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Sambia?",
    answers: ["Harare", "Lusaka", "Lilongwe", "Gaborone"],
    correct: 1
  },
  {
    question: "Wie heißt die größte Spinnenart?",
    answers: ["Vogelspinne", "Goliath-Vogelspinne", "Schwarze Witwe", "Bananenspinne"],
    correct: 1
  },
  {
    question: "Welcher Berg ist der höchste in Europa?",
    answers: ["Mont Blanc", "Matterhorn", "Elbrus", "Monte Rosa"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Simbabwe?",
    answers: ["Bulawayo", "Harare", "Mutare", "Gweru"],
    correct: 1
  },
  {
    question: "Wie viele Mägen hat ein Pferd?",
    answers: ["1", "2", "3", "4"],
    correct: 0
  },
  {
    question: "Welches ist das seltenste Blutgruppe?",
    answers: ["A-", "B-", "AB-", "0-"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Mosambik?",
    answers: ["Beira", "Nampula", "Maputo", "Quelimane"],
    correct: 2
  },
  {
    question: "Wie nennt man die Wissenschaft von den Fischen?",
    answers: ["Ichthyologie", "Herpetologie", "Ornithologie", "Mammalogie"],
    correct: 0
  },
  {
    question: "Welcher Kontinent hat keine Wüsten?",
    answers: ["Europa", "Australien", "Südamerika", "Keine Antwort"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Namibia?",
    answers: ["Swakopmund", "Walvis Bay", "Windhoek", "Oshakati"],
    correct: 2
  },
  {
    question: "Wie viele Fußballfelder passen in einen Quadratkilometer?",
    answers: ["100", "140", "200", "250"],
    correct: 1
  },
  {
    question: "Welches Tier hat das beste Gedächtnis?",
    answers: ["Delfin", "Elefant", "Rabe", "Schimpanse"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Botswana?",
    answers: ["Francistown", "Maun", "Gaborone", "Kasane"],
    correct: 2
  },
  {
    question: "Wie heißt der größte Stern im Universum?",
    answers: ["Beteigeuze", "VY Canis Majoris", "UY Scuti", "Antares"],
    correct: 2
  },
  {
    question: "Welcher Fluss fließt durch Rom?",
    answers: ["Po", "Arno", "Tiber", "Adda"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Angola?",
    answers: ["Benguela", "Huambo", "Luanda", "Lobito"],
    correct: 2
  },
  {
    question: "Wie viele Flossen hat ein typischer Fisch?",
    answers: ["3", "5", "7", "9"],
    correct: 2
  },
  {
    question: "Welches ist das längste Buch der Bibel nach Kapiteln?",
    answers: ["Genesis", "Psalmen", "Jesaja", "Jeremia"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Madagaskar?",
    answers: ["Toamasina", "Antsirabe", "Antananarivo", "Mahajanga"],
    correct: 2
  },
  {
    question: "Wie nennt man Tiere, die Aas fressen?",
    answers: ["Karnivoren", "Aasfresser", "Saprophagen", "Detritivoren"],
    correct: 1
  },
  {
    question: "Welcher Planet hat die stärksten Winde?",
    answers: ["Jupiter", "Saturn", "Uranus", "Neptun"],
    correct: 3
  },
  {
    question: "Was ist die Hauptstadt von Mauretanien?",
    answers: ["Nouadhibou", "Nouakchott", "Kaédi", "Zouerate"],
    correct: 1
  },
  {
    question: "Wie viele Beine hat ein Tausendfüßler wirklich?",
    answers: ["100", "750", "Bis zu 750", "Genau 1000"],
    correct: 2
  },
  {
    question: "Welches ist das schnellste Tier an Land über kurze Distanz?",
    answers: ["Gepard", "Springbock", "Löwe", "Windhund"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Niger?",
    answers: ["Agadez", "Zinder", "Niamey", "Maradi"],
    correct: 2
  },
  {
    question: "Wie heißt die größte Schlange der Welt?",
    answers: ["Anakonda", "Python", "Königskobra", "Boa"],
    correct: 0
  },
  {
    question: "Welcher Fluss fließt durch Budapest?",
    answers: ["Dnjepr", "Donau", "Weichsel", "Oder"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Mali?",
    answers: ["Timbuktu", "Gao", "Bamako", "Sikasso"],
    correct: 2
  },
  {
    question: "Wie viele Knochen hat eine Schlange?",
    answers: ["0", "50-100", "200-400", "500-600"],
    correct: 2
  },
  {
    question: "Welches ist das tiefste Meer?",
    answers: ["Philippinensee", "Korallensee", "Arabisches Meer", "Karibik"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Tschad?",
    answers: ["Moundou", "Sarh", "N'Djamena", "Abéché"],
    correct: 2
  },
  {
    question: "Wie nennt man die Lehre von den Reptilien?",
    answers: ["Herpetologie", "Ichthyologie", "Ornithologie", "Mammalogie"],
    correct: 0
  },
  {
    question: "Welcher Planet hat die meisten Vulkane?",
    answers: ["Erde", "Mars", "Venus", "Io (Mond)"],
    correct: 3
  },
  {
    question: "Was ist die Hauptstadt von Burkina Faso?",
    answers: ["Bobo-Dioulasso", "Koudougou", "Ouagadougou", "Banfora"],
    correct: 2
  },
  {
    question: "Wie viele Augen hat eine Libelle?",
    answers: ["2", "5", "Tausende", "Zehntausende"],
    correct: 3
  },
  {
    question: "Welches ist das älteste noch existierende Land?",
    answers: ["Ägypten", "China", "Iran", "San Marino"],
    correct: 3
  },
  {
    question: "Was ist die Hauptstadt von Benin?",
    answers: ["Cotonou", "Porto-Novo", "Parakou", "Abomey"],
    correct: 1
  },
  {
    question: "Wie heißt das größte Nagetier der Welt?",
    answers: ["Biber", "Capybara", "Stachelschwein", "Paka"],
    correct: 1
  },
  {
    question: "Welcher Fluss ist der wasserreichste?",
    answers: ["Amazonas", "Kongo", "Ganges", "Mississippi"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Elfenbeinküste?",
    answers: ["Abidjan", "Yamoussoukro", "Bouaké", "Daloa"],
    correct: 1
  },
  {
    question: "Wie viele Herzen hat ein Regenwurm?",
    answers: ["1", "3", "5", "10"],
    correct: 2
  },
  {
    question: "Welches ist das häufigste Metall in der Erdkruste?",
    answers: ["Eisen", "Aluminium", "Kupfer", "Gold"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Liberia?",
    answers: ["Gbarnga", "Buchanan", "Monrovia", "Harper"],
    correct: 2
  },
  {
    question: "Wie nennt man ein Tier, das nur Fleisch frisst?",
    answers: ["Karnivore", "Herbivore", "Omnivore", "Insektivore"],
    correct: 0
  },
  {
    question: "Welcher Planet ist am heißesten?",
    answers: ["Merkur", "Venus", "Mars", "Jupiter"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Sierra Leone?",
    answers: ["Bo", "Kenema", "Freetown", "Makeni"],
    correct: 2
  },
  {
    question: "Wie viele Füße hat ein Tintenfisch?",
    answers: ["0", "2", "8", "10"],
    correct: 0
  },
  {
    question: "Welches ist das einzige Säugetier, das Eier legt?",
    answers: ["Ameisenigel", "Schnabeltier", "Beide", "Keines"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Guinea?",
    answers: ["Kankan", "Nzérékoré", "Conakry", "Kindia"],
    correct: 2
  },
  {
    question: "Wie heißt der größte Vogel der Welt?",
    answers: ["Kondor", "Albatros", "Strauß", "Emu"],
    correct: 2
  },
  {
    question: "Welcher Fluss fließt durch Prag?",
    answers: ["Elbe", "Moldau", "Oder", "Donau"],
    correct: 1
  },
  {
    question: "Was ist die Hauptstadt von Gambia?",
    answers: ["Serekunda", "Brikama", "Banjul", "Bakau"],
    correct: 2
  },
  {
    question: "Wie viele Zähne hat ein Krokodil?",
    answers: ["30-40", "50-60", "60-80", "80-100"],
    correct: 2
  },
  {
    question: "Welches ist das kleinste Säugetier der Welt?",
    answers: ["Zwergspitzmaus", "Etruskerspitzmaus", "Hummelfledermaus", "Zwergmaus"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Eritrea?",
    answers: ["Massawa", "Keren", "Asmara", "Assab"],
    correct: 2
  },
  {
    question: "Wie nennt man die Wissenschaft vom Wetter?",
    answers: ["Klimatologie", "Meteorologie", "Atmosphärologie", "Wetterologie"],
    correct: 1
  },
  {
    question: "Welcher Planet rotiert auf der Seite?",
    answers: ["Merkur", "Venus", "Uranus", "Neptun"],
    correct: 2
  },
  {
    question: "Was ist die Hauptstadt von Dschibuti?",
    answers: ["Ali Sabieh", "Tadjoura", "Dschibuti", "Obock"],
    correct: 2
  },
  {
    question: "Wie viele Tentakel hat eine Qualle normalerweise?",
    answers: ["4", "8", "Variiert", "Unendlich"],
    correct: 2
  },
  {
    question: "Welches ist das größte Riff der Welt?",
    answers: ["Great Barrier Reef", "Belize Barrier Reef", "Rotes Meer Riff", "Neukaledonisches Riff"],
    correct: 0
  },
  {
    question: "Was ist die Hauptstadt von Somalia?",
    answers: ["Hargeisa", "Berbera", "Mogadischu", "Kismayo"],
    correct: 2
  },
  {
    question: "Wie heißt das größte Raubtier im Meer?",
    answers: ["Weißer Hai", "Orca", "Riesenkalmar", "Pottwal"],
    correct: 3
  }
  ,
  // Frage 201-300 (Neue Fragen – Gemischt)
  { question: "Welche Farbe hat die Banane im reifen Zustand?", answers: ["Grün", "Gelb", "Rot", "Blau"], correct: 1 },
  { question: "Wie viele Tage hat ein Schaltjahr?", answers: ["364", "365", "366", "367"], correct: 2 },
  { question: "Welches ist das größte Land der Welt nach Fläche?", answers: ["USA", "China", "Kanada", "Russland"], correct: 3 },
  { question: "Welche Sprache spricht man in Mexiko vorwiegend?", answers: ["Portugiesisch", "Spanisch", "Englisch", "Französisch"], correct: 1 },
  { question: "Wie viele Kontinente gibt es offiziell?", answers: ["5", "6", "7", "8"], correct: 2 },
  { question: "Wie heißt die Hauptstadt von Niederlanden?", answers: ["Amsterdam", "Rotterdam", "Den Haag", "Utrecht"], correct: 0 },
  { question: "Welches Metall leitet Strom am besten?", answers: ["Gold", "Silber", "Kupfer", "Aluminium"], correct: 1 },
  { question: "Wie viele Planeten hat unser Sonnensystem (seit 2006)?", answers: ["8", "9", "10", "7"], correct: 0 },
  { question: "Welches Tier ist kein Primat?", answers: ["Gorilla", "Schimpanse", "Lemur", "Koala"], correct: 3 },
  { question: "Woraus besteht Glas hauptsächlich?", answers: ["Sand", "Holz", "Ton", "Salz"], correct: 0 },
  { question: "Welche Farbe hat die Ampel für 'Stop'?", answers: ["Rot", "Gelb", "Grün", "Blau"], correct: 0 },
  { question: "Wie nennt man gefrorenes Wasser?", answers: ["Nebel", "Eis", "Tau", "Reif"], correct: 1 },
  { question: "Welche Einheit misst Stromstärke?", answers: ["Volt", "Watt", "Ampere", "Ohm"], correct: 2 },
  { question: "Welches Tier ist ein Raubfisch?", answers: ["Karpfen", "Hecht", "Forelle", "Wels"], correct: 1 },
  { question: "Welche Stadt ist für das Oktoberfest bekannt?", answers: ["Berlin", "München", "Hamburg", "Köln"], correct: 1 },
  { question: "Welche Zahl ist eine Primzahl?", answers: ["9", "15", "17", "21"], correct: 2 },
  { question: "Welches Organ ist für das Sehen zuständig?", answers: ["Herz", "Leber", "Auge", "Niere"], correct: 2 },
  { question: "Wie viele Minuten hat eine Stunde?", answers: ["30", "45", "60", "90"], correct: 2 },
  { question: "Welches Getränk enthält am meisten Koffein?", answers: ["Kakao", "Cola", "Kaffee", "Tee"], correct: 2 },
  { question: "Welche Stadt ist die Hauptstadt von Schweiz?", answers: ["Zürich", "Genf", "Bern", "Basel"], correct: 2 },
  { question: "Welches Tier ist ein Säugetier?", answers: ["Hai", "Delfin", "Forelle", "Krabbe"], correct: 1 },
  { question: "Welches Gerät misst Temperatur?", answers: ["Barometer", "Thermometer", "Hygrometer", "Anemometer"], correct: 1 },
  { question: "Wie heißt der längste Tag im Jahr?", answers: ["Wintersonnenwende", "Sommersonnenwende", "Tagundnachtgleiche", "Neujahr"], correct: 1 },
  { question: "Welche Farbe hat Kupfer oft als Patina?", answers: ["Schwarz", "Grün", "Weiß", "Rot"], correct: 1 },
  { question: "Wie viele Spieler hat ein Volleyballteam auf dem Feld?", answers: ["5", "6", "7", "8"], correct: 1 },
  { question: "Welches ist ein Webprotokoll?", answers: ["SMTP", "HTTP", "FTP", "SSH"], correct: 1 },
  { question: "Welcher Planet ist als Morgenstern bekannt?", answers: ["Mars", "Venus", "Merkur", "Jupiter"], correct: 1 },
  { question: "Wie heißt die Hauptstadt von Türkei?", answers: ["Istanbul", "Ankara", "Izmir", "Antalya"], correct: 1 },
  { question: "Welche Form hat ein Stoppschild?", answers: ["Sechseck", "Achteck", "Dreieck", "Kreis"], correct: 1 },
  { question: "Wie nennt man die Lehre vom Geld?", answers: ["Soziologie", "Numismatik", "Ökologie", "Logik"], correct: 1 },
  { question: "Welches ist kein Betriebssystem?", answers: ["Windows", "Linux", "Android", "Photoshop"], correct: 3 },
  { question: "Welches ist ein Gewürz?", answers: ["Basalt", "Paprika", "Quarz", "Granit"], correct: 1 },
  { question: "Wie heißt der höchste Berg Europas (wenn Kaukasus zählt)?", answers: ["Mont Blanc", "Matterhorn", "Elbrus", "Grossglockner"], correct: 2 },
  { question: "Welches ist ein Primärfarbton?", answers: ["Cyan", "Magenta", "Gelb", "Türkis"], correct: 2 },
  { question: "Wie viele Bundesländer hat Österreich?", answers: ["7", "8", "9", "10"], correct: 2 },
  { question: "Welches Tier ist ein Insekt?", answers: ["Spinne", "Biene", "Skorpion", "Hund"], correct: 1 },
  { question: "Welcher Fluss fließt durch London?", answers: ["Seine", "Themse", "Elbe", "Donau"], correct: 1 },
  { question: "Welche Einheit misst Energie?", answers: ["Newton", "Joule", "Pascal", "Lux"], correct: 1 },
  { question: "Welches Tier ist ein Reptil?", answers: ["Frosch", "Salamander", "Eidechse", "Marienkäfer"], correct: 2 },
  { question: "Wie nennt man eine Gedankenfabrik?", answers: ["Think-Tank", "Brain-Box", "Mind-Set", "Idea-Center"], correct: 0 },
  { question: "Welches Land liegt NICHT in Skandinavien?", answers: ["Norwegen", "Dänemark", "Finnland", "Estland"], correct: 3 },
  { question: "Welche Zahl ist römisch 'X'?", answers: ["5", "10", "50", "100"], correct: 1 },
  { question: "Welches Getränk ist fermentiert?", answers: ["Milch", "Wasser", "Joghurt", "Saft"], correct: 2 },
  { question: "Welches ist die kleinste Einheit der Schrift?", answers: ["Wort", "Satz", "Buchstabe", "Absatz"], correct: 2 },
  { question: "Wie heißt die Hauptstadt von Marokko?", answers: ["Casablanca", "Rabat", "Fes", "Marrakesch"], correct: 1 },
  { question: "Welche Programmiersprache läuft im Browser?", answers: ["Python", "JavaScript", "C#", "Go"], correct: 1 },
  { question: "Welches ist ein Süßwassersee?", answers: ["Mittelmeer", "Kaspisches Meer", "Baikalsee", "Ostsee"], correct: 2 },
  { question: "Wie heißt die Hauptstadt von Australien?", answers: ["Sydney", "Melbourne", "Canberra", "Perth"], correct: 2 },
  { question: "Welches Tier hat einen Beutel?", answers: ["Känguru", "Koala", "Wombat", "Alle"], correct: 3 },
  { question: "Welche Zahl ist binär 1010?", answers: ["8", "9", "10", "11"], correct: 2 },
  { question: "Welches ist ein Textdateiformat?", answers: [".jpg", ".png", ".txt", ".mp3"], correct: 2 },
  { question: "Wie viele Seiten hat ein Pentagon?", answers: ["4", "5", "6", "7"], correct: 1 },
  { question: "Welches ist kein Kontinent?", answers: ["Australien", "Antarktis", "Arktis", "Afrika"], correct: 2 },
  { question: "Welche Stadt liegt an der Donau?", answers: ["Paris", "Wien", "Madrid", "Lissabon"], correct: 1 },
  { question: "Wie nennt man die Lehre von der Umwelt?", answers: ["Ökologie", "Etymologie", "Ethnologie", "Epidemiologie"], correct: 0 },
  { question: "Welches ist ein typischer Programmiersprachen-Datentyp?", answers: ["Array", "Formel", "Textblock", "Schriftart"], correct: 0 },
  { question: "Welche Säure findet man in Zitrusfrüchten?", answers: ["Milchsäure", "Essigsäure", "Zitronensäure", "Ameisensäure"], correct: 2 },
  { question: "Wie heißt die Hauptstadt von Südafrika (eine davon)?", answers: ["Johannesburg", "Kapstadt", "Durban", "Pretoria"], correct: 3 },
  { question: "Welches ist ein Cloud-Anbieter?", answers: ["Azure", "Node", "React", "Webpack"], correct: 0 },
  { question: "Welche Zahl ist 3^4?", answers: ["27", "64", "81", "243"], correct: 1 },
  { question: "Welche Musiknote ist höher?", answers: ["A", "C", "E", "G"], correct: 1 },
  { question: "Welcher Sport verwendet ein Shuttlecock?", answers: ["Tennis", "Badminton", "Squash", "Padel"], correct: 1 },
  { question: "Welche Programmiersprache stammt von Sun Microsystems?", answers: ["Java", "Python", "Rust", "Swift"], correct: 0 },
  { question: "Wie heißt die Hauptstadt von Argentinien?", answers: ["Lima", "Buenos Aires", "Santiago", "Montevideo"], correct: 1 },
  { question: "Welches ist ein Edelgas?", answers: ["Neon", "Stickstoff", "Sauerstoff", "Wasserstoff"], correct: 0 },
  { question: "Welche Maßeinheit misst Leistung?", answers: ["Watt", "Volt", "Ampere", "Ohm"], correct: 0 },
  { question: "Welches Land ist für Sushi bekannt?", answers: ["China", "Japan", "Korea", "Thailand"], correct: 1 },
  { question: "Welcher Fluss ist der längste in Deutschland?", answers: ["Elbe", "Rhein", "Donau", "Weser"], correct: 1 },
  { question: "Was ist HTML?", answers: ["Programmiersprache", "Auszeichnungssprache", "Datenbank", "Protokoll"], correct: 1 },
  { question: "Welches Tier ist ein Weichtier?", answers: ["Krake", "Krabbe", "Lachs", "Qualle"], correct: 0 },
  { question: "Welches Getränk entsteht durch Destillation?", answers: ["Wein", "Bier", "Whisky", "Most"], correct: 2 },
  { question: "Wie viele Millimeter sind ein Zentimeter?", answers: ["1", "5", "10", "100"], correct: 2 },
  { question: "Welches Vitamin ist wichtig für die Blutgerinnung?", answers: ["Vitamin A", "Vitamin K", "Vitamin B12", "Vitamin D"], correct: 1 },
  { question: "Welches ist ein Schweizer Kanton?", answers: ["Tirol", "Graubünden", "Südtirol", "Vorarlberg"], correct: 1 },
  { question: "Welche Zahl ist römisch 'L'?", answers: ["5", "50", "500", "100"], correct: 1 },
  { question: "Welches Tier ist ein Nagetier?", answers: ["Hase", "Meerschweinchen", "Hamster", "Alle"], correct: 3 },
  { question: "Welche Sprache spricht man in Brasilien?", answers: ["Spanisch", "Portugiesisch", "Französisch", "Englisch"], correct: 1 },
  { question: "Welche Zahl ist 2^10?", answers: ["512", "1024", "2048", "4096"], correct: 1 },
  { question: "Welches ist ein Pilz?", answers: ["Champignon", "Brokkoli", "Zucchini", "Paprika"], correct: 0 },
  { question: "Wie viele Beine hat ein Tausendfüßler ungefähr?", answers: ["20-100", "100-200", "200-400", "400-1000"], correct: 0 },
  { question: "Welches ist die Hauptstadt von Neuseeland?", answers: ["Auckland", "Wellington", "Christchurch", "Hamilton"], correct: 1 },
  { question: "Welches ist ein Dateikompressionsformat?", answers: [".zip", ".docx", ".xlsx", ".pptx"], correct: 0 },
  { question: "Welches Material ist magnetisch?", answers: ["Kupfer", "Aluminium", "Eisen", "Bronze"], correct: 2 },
  { question: "Wie viele Bits hat eine IPv4-Adresse?", answers: ["16", "32", "64", "128"], correct: 1 },
  { question: "Welches Land hat die Hauptstadt 'Reykjavik'?", answers: ["Finnland", "Island", "Norwegen", "Schweden"], correct: 1 },
  { question: "Welches ist eine Monosaccharid?", answers: ["Glukose", "Saccharose", "Laktose", "Maltose"], correct: 0 },
  { question: "Welche Farbe hat Silber?", answers: ["Silbern", "Grau", "Weiß", "Alle ähnlich"], correct: 3 },
  { question: "Welches Land nutzt den Euro?", answers: ["Schweiz", "Norwegen", "Polen", "Portugal"], correct: 3 },
  { question: "Welche Zahl ist die kleinste dreistellige Zahl?", answers: ["100", "101", "110", "111"], correct: 0 },
  { question: "Welches ist ein Kontinent?", answers: ["Europa", "EU", "Eurozone", "Schengen"], correct: 0 },
  { question: "Welche Einheit misst Frequenz?", answers: ["Hertz", "Joule", "Pascal", "Newton"], correct: 0 },
  { question: "Welches Tier ist ein Amphib?", answers: ["Salamander", "Schildkröte", "Krokodil", "Eidechse"], correct: 0 },
  { question: "Welche Stadt ist Hauptstadt von Kanada?", answers: ["Toronto", "Ottawa", "Montreal", "Vancouver"], correct: 1 },
  { question: "Welche Internet-Domain steht für Deutschland?", answers: [".de", ".at", ".ch", ".dk"], correct: 0 },
  { question: "Welches Gas verursacht Treibhauseffekt stark?", answers: ["Sauerstoff", "Stickstoff", "CO2", "Argon"], correct: 2 },
  { question: "Welches ist ein Sternbild?", answers: ["Orion", "Titan", "Europa", "Ganymed"], correct: 0 },
  { question: "Welche Sprache ist amtlich in Österreich?", answers: ["Deutsch", "Ungarisch", "Slowenisch", "Kroatisch"], correct: 0 },
  { question: "Welches Gewürz ist aus getrockneten Beeren?", answers: ["Paprika", "Pfeffer", "Zimt", "Koriander"], correct: 1 },
  { question: "Welche Zahl ist die Quadratwurzel aus 169?", answers: ["11", "12", "13", "14"], correct: 2 }
];

const MILLIONAIRE_WINNINGS = [1, 2, 5, 10, 15, 25, 40, 60, 90, 130, 180, 250, 330, 420, 500];

let millionaireCurrentQuestion = 0;
let millionaireCurrentWinnings = 0;
let millionaireGameActive = false;
let millionaireJoker5050Used = false;
let millionaireJokerAudienceUsed = false;
let millionaireShuffledQuestions = [];
let millionaireAnswerCooldown = false;

// Spiel starten - wähle 15 zufällige Fragen mit steigender Schwierigkeit
window.startMillionaire = function() {
  millionaireCurrentQuestion = 0;
  millionaireCurrentWinnings = 0;
  millionaireGameActive = true;
  millionaireJoker5050Used = false;
  millionaireJokerAudienceUsed = false;
  
  // Teile Fragen in Schwierigkeitsgruppen auf
  const easyQuestions = MILLIONAIRE_QUESTIONS.slice(0, 30);      // Frage 1-30 (Sehr Leicht)
  const mediumQuestions = MILLIONAIRE_QUESTIONS.slice(30, 100);   // Frage 31-100 (Mittel)
  const hardQuestions = MILLIONAIRE_QUESTIONS.slice(100, 150);    // Frage 101-150 (Schwer)
  const veryHardQuestions = MILLIONAIRE_QUESTIONS.slice(150, 200); // Frage 151-200 (Sehr Schwer)
  
  // Wähle zufällig aus jeder Kategorie
  millionaireShuffledQuestions = [
    ...shuffleArray(easyQuestions).slice(0, 3),        // 3 leichte Fragen
    ...shuffleArray(mediumQuestions).slice(0, 4),      // 4 mittlere Fragen
    ...shuffleArray(hardQuestions).slice(0, 5),        // 5 schwere Fragen
    ...shuffleArray(veryHardQuestions).slice(0, 3)     // 3 sehr schwere Fragen
  ];
  
  // Joker zurücksetzen
  document.getElementById("joker5050").textContent = "50:50 ✅";
  document.getElementById("joker5050").style.background = "#4CAF50";
  document.getElementById("jokerAudience").textContent = "Publikum 👥";
  document.getElementById("jokerAudience").style.background = "#4CAF50";
  
  document.getElementById("cashOutBtn").style.display = "none";
  
  showMillionaireQuestion();
};

// Hilfsfunktion zum Mischen
function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Frage anzeigen
function showMillionaireQuestion() {
  if (millionaireCurrentQuestion >= 15) {
    // Gewonnen!
    millionaireGameActive = false;
    document.getElementById("millionaireQuestion").innerHTML = `
      <p style="font-size:24px; font-weight:bold; text-align:center; color:#FFD700;">
        🎉 JACKPOT! Du hast 500 Münzen gewonnen! 🎉
      </p>
    `;
    document.getElementById("millionaireAnswers").innerHTML = "";
    addCoins(500);
    trackGamePlayed('millionaire');
    return;
  }
  
  const q = millionaireShuffledQuestions[millionaireCurrentQuestion];
  millionaireCurrentWinnings = millionaireCurrentQuestion > 0 ? MILLIONAIRE_WINNINGS[millionaireCurrentQuestion - 1] : 0;
  
  document.getElementById("millionaireQuestionNum").textContent = millionaireCurrentQuestion + 1;
  document.getElementById("millionaireWinnings").textContent = `${millionaireCurrentWinnings} 🪙`;
  document.getElementById("millionaireQuestion").innerHTML = `
    <p style="font-size:18px; font-weight:bold; text-align:center; margin:0;">${q.question}</p>
  `;
  
  // Antworten erstellen
  const answersDiv = document.getElementById("millionaireAnswers");
  answersDiv.innerHTML = "";
  
  q.answers.forEach((answer, index) => {
    const btn = document.createElement("button");
    btn.id = `millionaire-answer-${index}`;
    btn.textContent = answer;
    btn.style.padding = "15px";
    btn.style.fontSize = "16px";
    btn.style.background = "#2a2a3e";
    btn.style.border = "2px solid #444";
    btn.style.borderRadius = "5px";
    btn.style.cursor = "pointer";
    btn.onclick = () => checkMillionaireAnswer(index);
    answersDiv.appendChild(btn);
  });
  
  // Cash Out Button anzeigen (ab Frage 2)
  if (millionaireCurrentQuestion > 0) {
    document.getElementById("cashOutBtn").style.display = "block";
  }
}

// Antwort prüfen
async function checkMillionaireAnswer(selected) {
  if (!millionaireGameActive || millionaireAnswerCooldown) return;
  
  // Cooldown aktivieren
  millionaireAnswerCooldown = true;
  
  // Alle Buttons deaktivieren
  for (let i = 0; i < 4; i++) {
    const button = document.getElementById(`millionaire-answer-${i}`);
    if (button) {
      button.style.pointerEvents = "none";
      button.style.opacity = "0.7";
    }
  }
  
  const q = millionaireShuffledQuestions[millionaireCurrentQuestion];
  const btn = document.getElementById(`millionaire-answer-${selected}`);
  
  if (selected === q.correct) {
    // Richtig!
    btn.style.background = "#4CAF50";
    btn.style.border = "2px solid #00ff00";
    
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    millionaireCurrentQuestion++;
    millionaireAnswerCooldown = false;
    showMillionaireQuestion();
    
  } else {
    // Falsch!
    btn.style.background = "#f44336";
    btn.style.border = "2px solid #ff0000";
    
    // Zeige richtige Antwort
    const correctBtn = document.getElementById(`millionaire-answer-${q.correct}`);
    correctBtn.style.background = "#4CAF50";
    correctBtn.style.border = "2px solid #00ff00";
    
    millionaireGameActive = false;
    
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    millionaireAnswerCooldown = false;
    
    // Spiel verloren – immer 0 Münzen bei falscher Antwort
    millionaireCurrentWinnings = 0; // sicherstellen
    const finalWinnings = 0;
    try { trackGamePlayed('millionaire'); } catch(e){}
    // Keine Coins vergeben, klare Verlustmeldung
    showNotification('Wer wird Millionär', 'Falsch beantwortet – du gehst ohne Gewinn nach Hause.');
    document.getElementById("millionaireQuestion").innerHTML = `
      <p style="font-size:18px; font-weight:bold; text-align:center; color:#f44336;">
        ❌ Falsch! Du gehst ohne Gewinn nach Hause.
      </p>
    `;
    document.getElementById("millionaireAnswers").innerHTML = "";
    document.getElementById("cashOutBtn").style.display = "none";
  }
}

// Gewinn mitnehmen
window.cashOutMillionaire = async function() {
  if (!millionaireGameActive) return;
  
  millionaireGameActive = false;
  const winnings = millionaireCurrentWinnings;
  
  await addCoins(winnings);
  await trackGamePlayed('millionaire');
  
  document.getElementById("millionaireQuestion").innerHTML = `
    <p style="font-size:20px; font-weight:bold; text-align:center; color:#FFD700;">
      💰 Du hast ${winnings} Münzen mitgenommen! 💰
    </p>
  `;
  document.getElementById("millionaireAnswers").innerHTML = "";
  document.getElementById("cashOutBtn").style.display = "none";
  
  showNotification(`💰 ${winnings} Münzen erhalten!`);
};

// 50:50 Joker
window.use5050Joker = function() {
  if (!millionaireGameActive || millionaireJoker5050Used) return;
  
  millionaireJoker5050Used = true;
  document.getElementById("joker5050").textContent = "50:50 ❌";
  document.getElementById("joker5050").style.background = "#666";
  
  const q = millionaireShuffledQuestions[millionaireCurrentQuestion];
  const correctAnswer = q.correct;
  
  // Finde 2 falsche Antworten zum Entfernen
  const wrongAnswers = [0, 1, 2, 3].filter(i => i !== correctAnswer);
  const toRemove = wrongAnswers.sort(() => Math.random() - 0.5).slice(0, 2);
  
  toRemove.forEach(index => {
    const btn = document.getElementById(`millionaire-answer-${index}`);
    if (btn) {
      btn.style.opacity = "0.3";
      btn.style.pointerEvents = "none";
    }
  });
  
  showNotification("🎯 Zwei falsche Antworten wurden entfernt!");
};

// Publikums-Joker
window.useAudienceJoker = function() {
  if (!millionaireGameActive || millionaireJokerAudienceUsed) return;
  
  millionaireJokerAudienceUsed = true;
  document.getElementById("jokerAudience").textContent = "Publikum ❌";
  document.getElementById("jokerAudience").style.background = "#666";
  
  const q = millionaireShuffledQuestions[millionaireCurrentQuestion];
  const correctAnswer = q.correct;
  
  // Publikum ist zu 70-90% richtig
  const correctPercentage = 70 + Math.random() * 20;
  const percentages = [0, 0, 0, 0];
  percentages[correctAnswer] = correctPercentage;
  
  let remaining = 100 - correctPercentage;
  for (let i = 0; i < 4; i++) {
    if (i !== correctAnswer) {
      const share = Math.random() * remaining;
      percentages[i] = share;
      remaining -= share;
    }
  }
  
  let message = "👥 Publikumsmeinung:\n";
  q.answers.forEach((answer, i) => {
    message += `${answer}: ${Math.round(percentages[i])}%\n`;
  });
  
  showNotification(message);
};

/////////////////////////////////////////////////////////////////////////////
// SUDOKU GAME 🧩
/////////////////////////////////////////////////////////////////////////////

let sudokuGrid = [];
let sudokuSolution = [];
let sudokuSelectedCell = null;
let sudokuRunning = false;
let sudokuStartTime = null;
let sudokuTimerInterval = null;

// Sudoku initialisieren
function initSudoku() {
  const gridEl = document.getElementById("sudokuGrid");
  if (!gridEl) return;
  
  gridEl.innerHTML = "";
  for (let i = 0; i < 81; i++) {
    const cell = document.createElement("div");
    cell.className = "sudoku-cell";
    cell.dataset.index = i;
    cell.onclick = () => selectSudokuCell(i);
    gridEl.appendChild(cell);
  }
}

// Sudoku Spiel starten
window.startSudoku = function() {
  const difficulty = document.getElementById("sudokuDifficulty").value;
  const clues = difficulty === "noob" ? 40 : difficulty === "profi" ? 30 : 25; // 40, 30, 25 vorgegebene Zahlen
  
  // Generiere Sudoku
  sudokuSolution = generateSudoku();
  sudokuGrid = JSON.parse(JSON.stringify(sudokuSolution));
  
  // Entferne Zahlen basierend auf Schwierigkeit
  const cellsToRemove = 81 - clues;
  let removed = 0;
  while (removed < cellsToRemove) {
    const idx = Math.floor(Math.random() * 81);
    if (sudokuGrid[idx] !== 0) {
      sudokuGrid[idx] = 0;
      removed++;
    }
  }
  
  // Render Grid
  renderSudokuGrid();
  
  // Timer starten
  sudokuStartTime = Date.now();
  sudokuRunning = true;
  updateSudokuTimer();
  
  document.getElementById("sudokuStatus").textContent = "Viel Erfolg! 🧩";
};

// Sudoku generieren (vollständiges 9x9 Grid)
function generateSudoku() {
  const grid = Array(81).fill(0);
  
  function isValid(grid, row, col, num) {
    // Zeile prüfen
    for (let x = 0; x < 9; x++) {
      if (grid[row * 9 + x] === num) return false;
    }
    
    // Spalte prüfen
    for (let x = 0; x < 9; x++) {
      if (grid[x * 9 + col] === num) return false;
    }
    
    // 3x3 Box prüfen
    const startRow = row - (row % 3);
    const startCol = col - (col % 3);
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (grid[(startRow + i) * 9 + (startCol + j)] === num) return false;
      }
    }
    
    return true;
  }
  
  function solve(grid) {
    for (let i = 0; i < 81; i++) {
      if (grid[i] === 0) {
        const row = Math.floor(i / 9);
        const col = i % 9;
        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);
        
        for (const num of numbers) {
          if (isValid(grid, row, col, num)) {
            grid[i] = num;
            if (solve(grid)) return true;
            grid[i] = 0;
          }
        }
        return false;
      }
    }
    return true;
  }
  
  solve(grid);
  return grid;
}

// Sudoku Grid rendern
function renderSudokuGrid() {
  const gridEl = document.getElementById("sudokuGrid");
  const cells = gridEl.querySelectorAll(".sudoku-cell");
  const isDark = document.body.classList.contains("dark-mode");
  
  cells.forEach((cell, idx) => {
    const value = sudokuGrid[idx];
    const isGiven = sudokuSolution[idx] !== 0 && sudokuGrid[idx] === sudokuSolution[idx] && sudokuGrid[idx] !== 0;
    
    cell.textContent = value === 0 ? "" : value;
    cell.style.background = isDark ? "#2a2a2a" : "#fff";
    cell.style.color = isDark ? "#f2f4f8" : "#111";
    cell.style.fontWeight = isGiven ? "bold" : "normal";
    cell.style.fontSize = "18px";
    cell.style.display = "flex";
    cell.style.alignItems = "center";
    cell.style.justifyContent = "center";
    cell.style.minHeight = "35px";
    cell.style.cursor = "pointer";
    cell.style.border = isDark ? "1px solid #555" : "1px solid #ddd";
    cell.style.borderRadius = "3px";
    
    // 3x3 Box Hervorhebung
    const row = Math.floor(idx / 9);
    const col = idx % 9;
    if ((Math.floor(row / 3) + Math.floor(col / 3)) % 2 === 0) {
      cell.style.background = isDark ? "#333" : "#f0f0f0";
    }
  });
}

// Zelle auswählen
function selectSudokuCell(idx) {
  if (!sudokuRunning) return;
  
  const gridEl = document.getElementById("sudokuGrid");
  const cells = gridEl.querySelectorAll(".sudoku-cell");
  
  // Alle Zellen zurücksetzen
  cells.forEach(c => c.style.outline = "none");
  
  // Ausgewählte Zelle markieren
  cells[idx].style.outline = "3px solid #007bff";
  sudokuSelectedCell = idx;
}

// Zahl setzen
window.setSudokuNumber = function(num) {
  if (!sudokuRunning || sudokuSelectedCell === null) return;
  
  sudokuGrid[sudokuSelectedCell] = num;
  playGameSound('sudoku_place');
  renderSudokuGrid();
};

// Sudoku prüfen
window.checkSudoku = async function() {
  if (!sudokuRunning) return;
  
  // Prüfe ob alle Felder gefüllt sind
  if (sudokuGrid.includes(0)) {
    document.getElementById("sudokuStatus").textContent = "⚠️ Noch nicht alle Felder ausgefüllt!";
    return;
  }
  
  // Prüfe ob Lösung korrekt ist
  const correct = sudokuGrid.every((val, idx) => val === sudokuSolution[idx]);
  
  if (correct) {
    sudokuRunning = false;
    clearInterval(sudokuTimerInterval);
    playGameSound('sudoku_complete');
    
    const difficulty = document.getElementById("sudokuDifficulty").value;
    const coins = difficulty === "noob" ? 20 : difficulty === "profi" ? 50 : 100;
    const timeTaken = Math.floor((Date.now() - sudokuStartTime) / 1000);
    
    // Speichere Sieg
    if (currentUser) {
      await saveSudokuWin(difficulty, timeTaken);
      await addCoins(coins);
      
      document.getElementById("sudokuStatus").textContent = `🎉 Geschafft! +${coins} Münzen!`;
      showNotification("Sudoku", `Gelöst in ${formatTime(timeTaken)}! 🪙 +${coins} Münzen`);
      
      // Quest Progress updaten
      updateBPQuestProgress("sudoku", 1);
      await trackGamePlayed('sudoku');
    }
  } else {
    playGameSound('sudoku_error');
    document.getElementById("sudokuStatus").textContent = "❌ Noch nicht korrekt. Weiter probieren!";
  }
};

// Timer aktualisieren
function updateSudokuTimer() {
  if (!sudokuRunning) return;
  
  const elapsed = Math.floor((Date.now() - sudokuStartTime) / 1000);
  document.getElementById("sudokuTimer").textContent = formatTime(elapsed);
  
  sudokuTimerInterval = setTimeout(updateSudokuTimer, 1000);
}

// Zeit formatieren
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
}

// Sudoku Sieg speichern
async function saveSudokuWin(difficulty, time) {
  if (!currentUser) return;
  
  try {
    const userRef = doc(db, "users", currentUser.uid);
    const userSnap = await getDoc(userRef);
    
    if (userSnap.exists()) {
      const data = userSnap.data();
      const sudokuStats = data.sudokuStats || { noob: 0, profi: 0, champion: 0, total: 0 };
      
      sudokuStats[difficulty] = (sudokuStats[difficulty] || 0) + 1;
      sudokuStats.total = (sudokuStats.total || 0) + 1;
      
      await updateDoc(userRef, { sudokuStats });
    }
  } catch (err) {
    console.error("Fehler beim Speichern des Sudoku Sieges:", err);
  }
}

// Sudoku Rankings Modal
window.switchSudokuRankingTab = function(mode) {
  currentSudokuRankingMode = mode;
  document.getElementById('sudokuRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('sudokuRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('sudokuRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('sudokuRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadSudokuRankings();
};

window.openSudokuRanking = async function() {
  const modal = document.getElementById("sudokuRankingModal");
  if (!modal) return;
  
  await loadSudokuRankings();
  modal.style.display = "flex";
};

window.closeSudokuRanking = function() {
  const modal = document.getElementById("sudokuRankingModal");
  if (modal) modal.style.display = "none";
};

window.loadSudokuRankings = async function() {
  const listEl = document.getElementById("sudokuRankingList");
  const filterEl = document.getElementById("sudokuRankingFilter");
  const filter = filterEl ? filterEl.value : "all";
  
  listEl.innerHTML = "<p>Wird geladen...</p>";
  
  try {
    const usersRef = collection(db, "users");
    const snap = await getDocs(usersRef);
    
    let players = [];
    snap.forEach(d => {
      const data = d.data();
      if (data.sudokuStats) {
        let wins = 0;
        if (filter === "all") {
          wins = data.sudokuStats.total || 0;
        } else {
          wins = data.sudokuStats[filter] || 0;
        }
        
        if (wins > 0) {
          players.push({
            uid: d.id,
            nickname: data.nickname || "guest",
            profilePic: data.profilePic || getDefaultProfilePic(),
            wins: wins,
            noobWins: data.sudokuStats.noob || 0,
            profiWins: data.sudokuStats.profi || 0,
            championWins: data.sudokuStats.champion || 0
          });
        }
      }
    });
    
    players.sort((a, b) => b.wins - a.wins);
    
    // Freunde-Filter anwenden
    if (currentSudokuRankingMode === 'friends') {
      players = filterFriendsOnly(players);
    }
    
    const top10 = players.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = "<p>Noch keine Siege vorhanden.</p>";
      return;
    }
    
    const isDark = document.body.classList.contains("dark-mode");
    const headerBg = "#007bff";
    const headerText = "#fff";
    const rowBg1 = isDark ? "#333" : "#f9f9f9";
    const rowBg2 = isDark ? "#222" : "#fff";
    const textColor = isDark ? "#f2f4f8" : "#111";
    const borderColor = isDark ? "#555" : "#ddd";
    
    const filterNames = { all: "Gesamt", noob: "Noob", profi: "Profi", champion: "Champion" };
    
    let html = `<table style='width:100%; border-collapse:collapse; color:${textColor};'>`;
    html += `<tr style='background:${headerBg}; color:${headerText};'><th style='padding:10px;'>#</th><th style='padding:10px;'>Spieler</th><th style='padding:10px;'>${filterNames[filter]} Siege</th>`;
    
    if (filter === "all") {
      html += `<th style='padding:10px; font-size:11px;'>N/P/C</th>`;
    }
    
    html += `</tr>`;
    
    top10.forEach((player, idx) => {
      const bgColor = idx % 2 === 0 ? rowBg1 : rowBg2;
      const medal = idx === 0 ? "🥇" : idx === 1 ? "🥈" : idx === 2 ? "🥉" : "";
      html += `
        <tr style="background:${bgColor}; border-bottom:1px solid ${borderColor}; color:${textColor};">
          <td style="padding:10px; text-align:center;">${medal} ${idx + 1}</td>
          <td style="padding:10px; cursor:pointer;" onclick="openUserProfile('${player.uid}')">
            <img src="${player.profilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;">
            ${player.nickname}
          </td>
          <td style="padding:10px; font-weight:bold;">${player.wins}</td>`;
      
      if (filter === "all") {
        html += `<td style="padding:10px; font-size:11px;">${player.noobWins}/${player.profiWins}/${player.championWins}</td>`;
      }
      
      html += `</tr>`;
    });
    
    html += "</table>";
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error("Fehler beim Laden der Sudoku Rankings:", err);
    listEl.innerHTML = "<p>Fehler beim Laden der Rankings.</p>";
  }
};

// Sudoku initialisieren nach DOM-Laden
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initSudoku);
} else {
  initSudoku();
}

/////////////////////////////////////////////////////////////////////////////
// ELFMETERSCHIE?EN GAME ⚽
/////////////////////////////////////////////////////////////////////////////

let penaltyGoals = 0;
let penaltyStreak = 0;
let penaltyCoins = 0;
let penaltyRunning = false;
let penaltyDifficulty = 'profi';
let penaltyBestStreak = parseInt(localStorage.getItem('penaltyBestStreak') || '0');
let penaltyCooldown = false;

// Schwierigkeit ändern
window.updatePenaltyDifficulty = function() {
  if (penaltyRunning) {
    showNotification('Spiel läuft', 'Bitte stoppe das Spiel, um die Schwierigkeit zu ändern!');
    return;
  }
  
  penaltyDifficulty = document.getElementById('penaltyDifficulty').value;
  
  // Torwart-Größe anpassen
  const keeper = document.getElementById('penaltyKeeper');
  if (keeper) {
    const sizes = {
      noob: 'width:40px; height:65px;',
      profi: 'width:55px; height:80px;',
      champion: 'width:70px; height:95px;'
    };
    keeper.style.cssText = `position:absolute; bottom:0; left:50%; transform:translateX(-50%); ${sizes[penaltyDifficulty]} background:#e74c3c; border-radius:50% 50% 0 0; transition:all 0.3s;`;
  }
};

// Elfmeterschießen starten
window.startPenalty = function() {
  if (!currentUser) {
    showNotification('Login erforderlich', 'Bitte einloggen um zu spielen!');
    return;
  }
  
  if (penaltyRunning) return;
  
  penaltyGoals = 0;
  penaltyStreak = 0;
  penaltyCoins = 0;
  penaltyRunning = true;
  penaltyDifficulty = document.getElementById('penaltyDifficulty').value;
  
  updatePenaltyDifficulty();
  updatePenaltyDisplay();
  document.getElementById('penaltyStatus').textContent = '⚽ Schieße ins Tor! (Klick auf Torbereich)';
  document.getElementById('penaltyStatus').style.color = '#27ae60';
};

// Elfmeterschießen stoppen
window.stopPenalty = async function() {
  if (!penaltyRunning) return;
  
  await endPenalty();
};

// Elfmeter schießen
window.shootPenalty = async function(zone) {
  if (!penaltyRunning || penaltyCooldown) return;
  
  // Aktiviere Cooldown
  penaltyCooldown = true;
  
  // Torwart bewegt sich zufällig mit unterschiedlicher Intelligenz je nach Schwierigkeit
  const keeperZones = ['topLeft', 'topCenter', 'topRight', 'bottomLeft', 'bottomCenter', 'bottomRight'];
  
  // Erhöhe Torwart-Erfolgswahrscheinlichkeit basierend auf Schwierigkeit
  let keeperZone;
  const catchBonus = {
    noob: 0.15,      // 15% Chance, dass Torwart zur Spieler-Zone springt
    profi: 0.30,     // 30% Chance
    champion: 0.45   // 45% Chance
  };
  
  if (Math.random() < catchBonus[penaltyDifficulty]) {
    // Torwart springt zur gewählten Zone (intelligent)
    keeperZone = zone;
  } else {
    // Torwart springt zufällig
    keeperZone = keeperZones[Math.floor(Math.random() * keeperZones.length)];
  }
  
  // Animiere Torwart
  animateKeeper(keeperZone);
  
  // Animiere Ball
  await animateBall(zone);
  
  // Prüfe ob Tor
  const isGoal = zone !== keeperZone;
  
  playGameSound('penalty_shoot');
  
  if (isGoal) {
    playGameSound('penalty_goal');
    penaltyGoals++;
    penaltyStreak++;
    
    // Münzen basierend auf Schwierigkeit
    const coinRewards = {
      noob: 1,
      profi: 2,
      champion: 3
    };
    const coinReward = coinRewards[penaltyDifficulty];
    
    penaltyCoins += coinReward;
    
    // Sofort Münzen gutschreiben
    if (currentUser) {
      await addCoins(coinReward);
    }
    
    // Best Streak updaten
    if (penaltyStreak > penaltyBestStreak) {
      penaltyBestStreak = penaltyStreak;
      localStorage.setItem('penaltyBestStreak', String(penaltyBestStreak));
    }
    
    document.getElementById('penaltyStatus').textContent = `⚽ TOR! +${coinReward} Münzen! ${penaltyStreak >= 3 ? '🔥 Serie: ' + penaltyStreak : ''}`;
    document.getElementById('penaltyStatus').style.color = '#27ae60';
    
    // Quest Progress
    updateBPQuestProgress('penaltyGoals', 1);
    // Einzigartiges Spiel für "Abwechslung"
    await trackGamePlayed('penalty');
  } else {
    playGameSound('penalty_save');
    penaltyStreak = 0;
    document.getElementById('penaltyStatus').textContent = '❌ Gehalten! Weiter probieren!';
    document.getElementById('penaltyStatus').style.color = '#e74c3c';
  }
  
  updatePenaltyDisplay();
  
  // Cooldown nach 1 Sekunde zurücksetzen
  setTimeout(() => {
    penaltyCooldown = false;
  }, 1000);
};

// Torwart Animation
function animateKeeper(zone) {
  const keeper = document.getElementById('penaltyKeeper');
  if (!keeper) return;
  
  const sizes = {
    noob: 'width:40px; height:65px;',
    profi: 'width:55px; height:80px;',
    champion: 'width:70px; height:95px;'
  };
  
  const positions = {
    topLeft: 'left:10%; bottom:60%;',
    topCenter: 'left:50%; bottom:60%; transform:translateX(-50%);',
    topRight: 'right:10%; bottom:60%;',
    bottomLeft: 'left:10%; bottom:0;',
    bottomCenter: 'left:50%; bottom:0; transform:translateX(-50%);',
    bottomRight: 'right:10%; bottom:0;'
  };
  
  keeper.style.cssText = `position:absolute; ${sizes[penaltyDifficulty]} background:#e74c3c; border-radius:50% 50% 0 0; transition:all 0.3s; ${positions[zone]}`;
}

// Ball Animation
function animateBall(zone) {
  return new Promise(resolve => {
    const ball = document.getElementById('penaltyBall');
    if (!ball) {
      resolve();
      return;
    }
    
    const positions = {
      topLeft: 'left:15%; bottom:160px;',
      topCenter: 'left:50%; bottom:160px; transform:translateX(-50%);',
      topRight: 'right:15%; bottom:160px;',
      bottomLeft: 'left:15%; bottom:80px;',
      bottomCenter: 'left:50%; bottom:80px; transform:translateX(-50%);',
      bottomRight: 'right:15%; bottom:80px;'
    };
    
    ball.style.cssText = `position:absolute; width:20px; height:20px; background:#fff; border-radius:50%; box-shadow:0 2px 5px rgba(0,0,0,0.3); transition:all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); ${positions[zone]}`;
    
    setTimeout(() => {
      // Ball zurück zur Ausgangsposition
      ball.style.cssText = 'position:absolute; bottom:10px; left:50%; transform:translateX(-50%); width:20px; height:20px; background:#fff; border-radius:50%; box-shadow:0 2px 5px rgba(0,0,0,0.3);';
      
      // Torwart zurück zur Mitte
      const keeper = document.getElementById('penaltyKeeper');
      if (keeper) {
        const sizes = {
          noob: 'width:40px; height:65px;',
          profi: 'width:55px; height:80px;',
          champion: 'width:70px; height:95px;'
        };
        const size = sizes[penaltyDifficulty] || 'width:55px; height:80px;';
        keeper.style.cssText = `position:absolute; bottom:0; left:50%; transform:translateX(-50%); ${size} background:#e74c3c; border-radius:50% 50% 0 0; transition:all 0.3s;`;
      }
      
      resolve();
    }, 600);
  });
}

// Display aktualisieren
function updatePenaltyDisplay() {
  document.getElementById('penaltyGoals').textContent = penaltyGoals;
  document.getElementById('penaltyStreak').textContent = penaltyStreak;
  document.getElementById('penaltyCoins').textContent = penaltyCoins;
}

// Spiel beenden
async function endPenalty() {
  penaltyRunning = false;
  
  // Speichere Session in Firebase wenn Tore erzielt wurden
  if (penaltyGoals > 0 && currentUser) {
    try {
      await addDoc(collection(db, "penaltyScores"), {
        uid: currentUser.uid,
        nickname: currentNickname,
        goals: penaltyGoals,
        coins: penaltyCoins,
        difficulty: penaltyDifficulty,
        bestStreak: penaltyBestStreak,
        createdAt: serverTimestamp()
      });
    } catch (err) {
      console.error("Fehler beim Speichern des Penalty Scores:", err);
    }
  }
  
  const difficultyLabels = { noob: 'Noob', profi: 'Profi', champion: 'Champion' };
  document.getElementById('penaltyStatus').textContent = `Session beendet! ${penaltyGoals} Tore (${difficultyLabels[penaltyDifficulty]})`;
  
  if (penaltyCoins > 0) {
    showNotification('Elfmeterschießen', `${penaltyGoals} Tore! 🪙 +${penaltyCoins} Münzen`);
  }
}

// Penalty Rankings Modal
window.switchPenaltyRankingTab = function(mode) {
  currentPenaltyRankingMode = mode;
  document.getElementById('penaltyRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('penaltyRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('penaltyRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('penaltyRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadPenaltyRankings(mode);
};

window.openPenaltyRanking = async function() {
  const modal = document.getElementById('penaltyRankingModal');
  if (!modal) return;
  
  await loadPenaltyRankings();
  modal.style.display = 'flex';
};

window.closePenaltyRanking = function() {
  const modal = document.getElementById('penaltyRankingModal');
  if (modal) modal.style.display = 'none';
};

async function loadPenaltyRankings(mode) {
  const listEl = document.getElementById('penaltyRankingList');
  listEl.innerHTML = '<p>Wird geladen...</p>';
  
  if (mode) currentPenaltyRankingMode = mode;
  
  try {
    const snap = await getDocs(collection(db, 'penaltyScores'));
    
    let scores = [];
    snap.forEach(d => {
      const data = d.data();
      scores.push({
        uid: data.uid || null,
        nickname: data.nickname || 'guest',
        goals: data.goals || 0,
        coins: data.coins || 0,
        difficulty: data.difficulty || 'profi',
        date: data.createdAt?.toDate() || new Date()
      });
    });
    
    scores.sort((a, b) => b.goals - a.goals || b.coins - a.coins);
    
    // Freunde-Filter anwenden
    if (currentPenaltyRankingMode === 'friends') {
      scores = filterFriendsOnly(scores);
    }
    
    const top10 = scores.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = '<p>Noch keine Scores vorhanden.</p>';
      return;
    }
    
    // Profilbilder laden
    const profilePics = {};
    const nameColors = {};
    for (const score of top10) {
      if (score.uid) {
        try {
          const userDoc = await getDoc(doc(db, 'users', score.uid));
          if (userDoc.exists()) {
            const uData = userDoc.data();
            profilePics[score.uid] = uData.profilePic || getDefaultProfilePic();
            nameColors[score.uid] = (uData.inventory || {}).chatNameColor || null;
          } else {
            profilePics[score.uid] = getDefaultProfilePic();
            nameColors[score.uid] = null;
          }
        } catch {
          profilePics[score.uid] = getDefaultProfilePic();
          nameColors[score.uid] = null;
        }
      } else {
        profilePics[score.uid] = getDefaultProfilePic();
        nameColors[score.uid] = null;
      }
    }
    
    const isDark = document.body.classList.contains('dark-mode');
    const headerBg = '#007bff';
    const headerText = '#fff';
    const rowBg1 = isDark ? '#333' : '#f9f9f9';
    const rowBg2 = isDark ? '#222' : '#fff';
    const textColor = isDark ? '#f2f4f8' : '#111';
    const borderColor = isDark ? '#555' : '#ddd';
    
    let html = `<table style='width:100%; border-collapse:collapse; color:${textColor};'>`;
    html += `<tr style='background:${headerBg}; color:${headerText};'><th style='padding:10px;'>#</th><th style='padding:10px;'>Spieler</th><th style='padding:10px;'>Tore</th><th style='padding:10px;'>Level</th><th style='padding:10px;'>Münzen</th></tr>`;
    
    top10.forEach((item, idx) => {
      const bgColor = idx % 2 === 0 ? rowBg1 : rowBg2;
      const medal = idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : '';
      const diffLabels = { noob: 'N', profi: 'P', champion: 'C' };
      const diffLabel = diffLabels[item.difficulty] || 'P';
      const profilePic = profilePics[item.uid];
      html += `
        <tr style="background:${bgColor}; border-bottom:1px solid ${borderColor}; color:${textColor};">
          <td style="padding:10px; text-align:center;">${medal} ${idx + 1}</td>
          <td style="padding:10px; cursor:pointer;" onclick="openUserProfile('${item.uid}')">
            <img src="${profilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;">
            ${(() => {
              const cId = nameColors[item.uid];
              if (cId === 'santa_red') return '<span data-color-id="santa">' + item.nickname + '</span>';
              if (cId === 'holly_green') return '<span data-color-id="holly">' + item.nickname + '</span>';
              if (cId === 'icy_blue') return '<span data-color-id="icy">' + item.nickname + '</span>';
              if (cId === 'advent_snow_white') return '<span data-color-id="advent_snow">' + item.nickname + '</span>';
              if (cId === 'advent_christmas_red') return '<span data-color-id="advent_xmas">' + item.nickname + '</span>';
              if (cId === 'advent_golden_star') return '<span data-color-id="advent_gold_star">' + item.nickname + '</span>';
              if (cId === 'advent_christmas_magic') return '<span data-color-id="advent_magic">' + item.nickname + '</span>';
              if (cId === 'gold') return '<span data-color-id="gold">' + item.nickname + '</span>';
              if (cId === 'ruby_red') return '<span data-color-id="ruby">' + item.nickname + '</span>';
              if (cId === 'emerald') return '<span data-color-id="emerald">' + item.nickname + '</span>';
              if (cId === 'diamond') return '<span data-color-id="diamond">' + item.nickname + '</span>';
              if (cId === 'rainbow') return '<span data-color-id="rainbow">' + item.nickname + '</span>';
              if (cId) {
                const c = CHAT_COLORS.find(x => x.id === cId);
                if (c) return '<span style=\"color:' + c.color + '\">' + item.nickname + '</span>';
              }
              return item.nickname;
            })()}
          </td>
          <td style="padding:10px; font-weight:bold;">${item.goals}</td>
          <td style="padding:10px; font-size:11px;">${diffLabel}</td>
          <td style="padding:10px;">🪙 ${item.coins}</td>
        </tr>
      `;
    });
    
    html += '</table>';
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error('Fehler beim Laden der Penalty Rankings:', err);
    listEl.innerHTML = '<p>Fehler beim Laden der Rankings.</p>';
  }
}

/////////////////////////////////////////////////////////////////////////////
// SCHACH
/////////////////////////////////////////////////////////////////////////////

const chessPieces = {
  wK: '♔', wQ: '♕', wR: '♖', wB: '♗', wN: '♘', wP: '♙',
  bK: '♚', bQ: '♛', bR: '♜', bB: '♝', bN: '♞', bP: '♟'
};

let chessBoard = [];
let chessSelectedSquare = null;
let chessPlayerColor = 'w';
let chessCurrentTurn = 'w';
let chessRunning = false;
let chessDifficulty = 'noob';
let chessGameOver = false;

// Schach Sounds (Web Audio API)
const chessAudioContext = new (window.AudioContext || window.webkitAudioContext)();

function playChessSound(type) {
  const oscillator = chessAudioContext.createOscillator();
  const gainNode = chessAudioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(chessAudioContext.destination);
  
  switch(type) {
    case 'move':
      // Klick-Sound für normale Züge
      oscillator.frequency.value = 400;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.15, chessAudioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, chessAudioContext.currentTime + 0.1);
      oscillator.start(chessAudioContext.currentTime);
      oscillator.stop(chessAudioContext.currentTime + 0.1);
      break;
      
    case 'capture':
      // Tiefer Sound für Schlagzüge
      oscillator.frequency.value = 200;
      oscillator.type = 'square';
      gainNode.gain.setValueAtTime(0.2, chessAudioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, chessAudioContext.currentTime + 0.15);
      oscillator.start(chessAudioContext.currentTime);
      oscillator.stop(chessAudioContext.currentTime + 0.15);
      break;
      
    case 'check':
      // Alarm-Sound für Schach
      oscillator.frequency.value = 800;
      oscillator.type = 'triangle';
      gainNode.gain.setValueAtTime(0.2, chessAudioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, chessAudioContext.currentTime + 0.2);
      oscillator.start(chessAudioContext.currentTime);
      oscillator.stop(chessAudioContext.currentTime + 0.2);
      break;
      
    case 'win':
      // Sieges-Melodie
      const notes = [523, 659, 784, 1047]; // C, E, G, C
      notes.forEach((freq, i) => {
        const osc = chessAudioContext.createOscillator();
        const gain = chessAudioContext.createGain();
        osc.connect(gain);
        gain.connect(chessAudioContext.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.15, chessAudioContext.currentTime + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, chessAudioContext.currentTime + i * 0.15 + 0.2);
        osc.start(chessAudioContext.currentTime + i * 0.15);
        osc.stop(chessAudioContext.currentTime + i * 0.15 + 0.2);
      });
      break;
      
    case 'lose':
      // Niederlagen-Sound
      oscillator.frequency.value = 150;
      oscillator.type = 'sawtooth';
      gainNode.gain.setValueAtTime(0.2, chessAudioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, chessAudioContext.currentTime + 0.5);
      oscillator.start(chessAudioContext.currentTime);
      oscillator.stop(chessAudioContext.currentTime + 0.5);
      break;
  }
}

function initChessBoard() {
  chessBoard = [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR']
  ];
  chessSelectedSquare = null;
  chessCurrentTurn = 'w';
  chessGameOver = false;
  renderChessBoard();
}

function renderChessBoard() {
  const boardDiv = document.getElementById('chessBoard');
  if (!boardDiv) return;
  
  boardDiv.innerHTML = '';
  
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.createElement('div');
      const isLight = (row + col) % 2 === 0;
      square.className = `chess-square ${isLight ? 'light' : 'dark'}`;
      square.dataset.row = row;
      square.dataset.col = col;
      
      const piece = chessBoard[row][col];
      if (piece) {
        square.textContent = chessPieces[piece] || '';
        // Füge Klasse für Figurenfarbe hinzu
        if (piece[0] === 'w') {
          square.classList.add('white-piece');
        } else {
          square.classList.add('black-piece');
        }
      }
      
      if (chessSelectedSquare && chessSelectedSquare.row === row && chessSelectedSquare.col === col) {
        square.classList.add('selected');
      }
      
      square.onclick = () => handleChessSquareClick(row, col);
      boardDiv.appendChild(square);
    }
  }
}

function handleChessSquareClick(row, col) {
  if (!chessRunning || chessGameOver || chessCurrentTurn !== chessPlayerColor) return;
  
  const piece = chessBoard[row][col];
  
  if (!chessSelectedSquare) {
    if (piece && piece[0] === chessPlayerColor) {
      chessSelectedSquare = { row, col };
      highlightPossibleMoves(row, col);
      renderChessBoard();
    }
    return;
  }
  
  const fromRow = chessSelectedSquare.row;
  const fromCol = chessSelectedSquare.col;
  
  if (piece && piece[0] === chessPlayerColor) {
    chessSelectedSquare = { row, col };
    highlightPossibleMoves(row, col);
    renderChessBoard();
    return;
  }
  
  if (isValidMove(fromRow, fromCol, row, col)) {
    makeMove(fromRow, fromCol, row, col);
    chessSelectedSquare = null;
    
    // Prüfe sofort nach Spielerzug ob Spiel vorbei ist
    if (checkGameOver()) {
      renderChessBoard();
      return;
    }
    
    chessCurrentTurn = 'b';
    renderChessBoard();
    
    setTimeout(() => {
      if (chessRunning && !chessGameOver) {
        makeAIMove();
        
        // Prüfe nach KI-Zug ob Spiel vorbei ist
        if (checkGameOver()) {
          renderChessBoard();
          return;
        }
        
        chessCurrentTurn = 'w';
        renderChessBoard();
      }
    }, 500);
  } else {
    chessSelectedSquare = null;
    renderChessBoard();
  }
}

function highlightPossibleMoves(row, col) {
  document.querySelectorAll('.chess-square.possible-move').forEach(el => {
    el.classList.remove('possible-move');
  });
  
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (isValidMove(row, col, r, c)) {
        const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
        if (square) square.classList.add('possible-move');
      }
    }
  }
}

function isValidMove(fromRow, fromCol, toRow, toCol) {
  if (fromRow === toRow && fromCol === toCol) return false;
  
  const piece = chessBoard[fromRow][fromCol];
  if (!piece) return false;
  
  const targetPiece = chessBoard[toRow][toCol];
  if (targetPiece && targetPiece[0] === piece[0]) return false;
  
  const pieceType = piece[1];
  const dx = Math.abs(toCol - fromCol);
  const dy = Math.abs(toRow - fromRow);
  
  switch (pieceType) {
    case 'P':
      const direction = piece[0] === 'w' ? -1 : 1;
      const startRow = piece[0] === 'w' ? 6 : 1;
      
      if (fromCol === toCol && !targetPiece) {
        if (toRow === fromRow + direction) return true;
        if (fromRow === startRow && toRow === fromRow + 2*direction && !chessBoard[fromRow + direction][fromCol]) return true;
      }
      
      if (dx === 1 && toRow === fromRow + direction && targetPiece) return true;
      return false;
      
    case 'R':
      if (fromRow === toRow || fromCol === toCol) {
        return isPathClear(fromRow, fromCol, toRow, toCol);
      }
      return false;
      
    case 'N':
      return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);
      
    case 'B':
      if (dx === dy) {
        return isPathClear(fromRow, fromCol, toRow, toCol);
      }
      return false;
      
    case 'Q':
      if (fromRow === toRow || fromCol === toCol || dx === dy) {
        return isPathClear(fromRow, fromCol, toRow, toCol);
      }
      return false;
      
    case 'K':
      return dx <= 1 && dy <= 1;
      
    default:
      return false;
  }
}

function isPathClear(fromRow, fromCol, toRow, toCol) {
  const rowStep = toRow > fromRow ? 1 : (toRow < fromRow ? -1 : 0);
  const colStep = toCol > fromCol ? 1 : (toCol < fromCol ? -1 : 0);
  
  let r = fromRow + rowStep;
  let c = fromCol + colStep;
  
  while (r !== toRow || c !== toCol) {
    if (chessBoard[r][c]) return false;
    r += rowStep;
    c += colStep;
  }
  
  return true;
}

function makeMove(fromRow, fromCol, toRow, toCol) {
  const isCapture = chessBoard[toRow][toCol] !== '';
  chessBoard[toRow][toCol] = chessBoard[fromRow][fromCol];
  chessBoard[fromRow][fromCol] = '';
  
  // Sound abspielen
  if (isCapture) {
    playChessSound('capture');
  } else {
    playChessSound('move');
  }
}

function makeAIMove() {
  const moves = getAllPossibleMoves('b');
  if (moves.length === 0) {
    chessGameOver = true;
    handleChessGameEnd(true);
    return;
  }
  
  let selectedMove;
  
  if (chessDifficulty === 'noob') {
    selectedMove = moves[Math.floor(Math.random() * moves.length)];
  } else if (chessDifficulty === 'profi') {
    const captureMoves = moves.filter(m => chessBoard[m.toRow][m.toCol] !== '');
    selectedMove = captureMoves.length > 0 && Math.random() > 0.3 
      ? captureMoves[Math.floor(Math.random() * captureMoves.length)]
      : moves[Math.floor(Math.random() * moves.length)];
  } else {
    const scoredMoves = moves.map(m => {
      const target = chessBoard[m.toRow][m.toCol];
      let score = Math.random();
      if (target) {
        const pieceValues = { P: 1, N: 3, B: 3, R: 5, Q: 9, K: 100 };
        score += pieceValues[target[1]] || 0;
      }
      return { move: m, score };
    });
    scoredMoves.sort((a, b) => b.score - a.score);
    selectedMove = scoredMoves[0].move;
  }
  
  makeMove(selectedMove.fromRow, selectedMove.fromCol, selectedMove.toRow, selectedMove.toCol);
}

function getAllPossibleMoves(color) {
  const moves = [];
  for (let fromRow = 0; fromRow < 8; fromRow++) {
    for (let fromCol = 0; fromCol < 8; fromCol++) {
      const piece = chessBoard[fromRow][fromCol];
      if (piece && piece[0] === color) {
        for (let toRow = 0; toRow < 8; toRow++) {
          for (let toCol = 0; toCol < 8; toCol++) {
            if (isValidMove(fromRow, fromCol, toRow, toCol)) {
              moves.push({ fromRow, fromCol, toRow, toCol });
            }
          }
        }
      }
    }
  }
  return moves;
}

function checkGameOver() {
  console.log('🔍 Prüfe Spielende - Turn:', chessCurrentTurn, 'Running:', chessRunning, 'GameOver:', chessGameOver);
  
  // Prüfe ob beide Könige noch existieren
  let whiteKingExists = false;
  let blackKingExists = false;
  
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = chessBoard[row][col];
      if (piece === 'wK') whiteKingExists = true;
      if (piece === 'bK') blackKingExists = true;
    }
  }
  
  console.log('👑 Könige:', { whiteKingExists, blackKingExists });
  
  // Weißer König wurde geschlagen -> Spieler verliert
  if (!whiteKingExists) {
    console.log('❌ Weißer König wurde geschlagen - Spieler verliert');
    chessGameOver = true;
    chessRunning = false;
    handleChessGameEnd(false);
    return true;
  }
  
  // Schwarzer König wurde geschlagen -> Spieler gewinnt
  if (!blackKingExists) {
    console.log('✅ Schwarzer König wurde geschlagen - Spieler gewinnt');
    chessGameOver = true;
    chessRunning = false;
    handleChessGameEnd(true);
    return true;
  }
  
  // Prüfe Patt (keine Züge möglich für aktuellen Spieler)
  if (chessCurrentTurn === 'w') {
    const moves = getAllPossibleMoves('w');
    if (moves.length === 0) {
      console.log('⚠️ Weiß hat keine Züge mehr - Patt');
      chessGameOver = true;
      chessRunning = false;
      handleChessGameEnd(false);
      return true;
    }
  } else if (chessCurrentTurn === 'b') {
    const moves = getAllPossibleMoves('b');
    if (moves.length === 0) {
      console.log('⚠️ Schwarz hat keine Züge mehr - Patt');
      chessGameOver = true;
      chessRunning = false;
      handleChessGameEnd(true);
      return true;
    }
  }
  
  return false;
}

async function handleChessGameEnd(playerWon) {
  console.log('🎮 Schach Spielende:', { playerWon, chessDifficulty, chessRunning, chessGameOver });
  
  chessRunning = false;
  chessGameOver = true;
  
  const rewards = { noob: 20, profi: 50, champion: 100 };
  const consolationPrize = 10;
  const coinsEarned = playerWon ? rewards[chessDifficulty] : consolationPrize;
  
  // Münzen gutschreiben
  if (currentUser) {
    console.log('💰 Münzen gutschreiben:', coinsEarned);
    await addCoins(coinsEarned);
    
    // Nur Siege in Rangliste speichern
    if (playerWon) {
      try {
        await addDoc(collection(db, "chessScores"), {
          uid: currentUser.uid,
          nickname: currentNickname,
          difficulty: chessDifficulty,
          coins: coinsEarned,
          createdAt: serverTimestamp()
        });
        console.log('✅ Score in Firebase gespeichert');
      } catch (err) {
        console.error("Fehler beim Speichern des Schach-Scores:", err);
      }
    }
  }
  
  const difficultyLabels = { noob: 'Noob', profi: 'Profi', champion: 'Champion' };
  
  if (playerWon) {
    playChessSound('win');
    document.getElementById('chessStatus').textContent = `🎉 Du hast gewonnen! +${coinsEarned} Münzen (${difficultyLabels[chessDifficulty]})`;
    document.getElementById('chessStatus').style.color = '#27ae60';
    showNotification('Schach', `Sieg gegen ${difficultyLabels[chessDifficulty]}! 🪙 +${coinsEarned} Münzen`);
    console.log('🎉 Sieg-Nachricht angezeigt');
  } else {
    playChessSound('lose');
    document.getElementById('chessStatus').textContent = `😔 Du hast verloren. +${coinsEarned} Münzen Trostpreis`;
    document.getElementById('chessStatus').style.color = '#e74c3c';
    showNotification('Schach', `Niederlage. Trostpreis: 🪙 +${coinsEarned} Münzen`);
    console.log('😔 Niederlage-Nachricht angezeigt');
  }
}

window.startChess = function() {
  if (!currentUser) {
    showNotification("Bitte einloggen", "Du musst eingeloggt sein, um Schach zu spielen.");
    return;
  }
  
  chessDifficulty = document.getElementById('chessDifficulty').value;
  chessRunning = true;
  initChessBoard();
  document.getElementById('chessStatus').textContent = 'Du bist am Zug! (Weiß)';
  document.getElementById('chessStatus').style.color = '#27ae60';
};

window.resetChess = function() {
  chessRunning = false;
  chessGameOver = false;
  initChessBoard();
  document.getElementById('chessStatus').textContent = 'Wähle Schwierigkeit und klick "Start"!';
  document.getElementById('chessStatus').style.color = '#27ae60';
};

window.openChessRanking = async function() {
  const modal = document.getElementById('chessRankingModal');
  if (!modal) return;
  
  await loadChessRankings();
  modal.style.display = 'flex';
};

window.switchChessRankingTab = function(mode) {
  currentChessRankingMode = mode;
  document.getElementById('chessRankingTabAll').style.fontWeight = mode === 'all' ? 'bold' : 'normal';
  document.getElementById('chessRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('chessRankingTabFriends').style.fontWeight = mode === 'friends' ? 'bold' : 'normal';
  document.getElementById('chessRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  loadChessRankings();
};

window.closeChessRanking = function() {
  const modal = document.getElementById('chessRankingModal');
  if (modal) modal.style.display = 'none';
};

async function loadChessRankings() {
  const filter = document.getElementById('chessRankingFilter')?.value || 'all';
  const listDiv = document.getElementById('chessRankingList');
  if (!listDiv) return;
  
  try {
    let q;
    if (filter === 'all') {
      // Einfacher Index: nur nach createdAt sortieren
      q = query(
        collection(db, "chessScores"),
        orderBy("createdAt", "desc"),
        limit(50)
      );
    } else {
      // Vermeide Composite-Index-Anforderung: filtere per where, sortiere clientseitig
      q = query(
        collection(db, "chessScores"),
        where("difficulty", "==", filter),
        limit(50)
      );
    }
    
    const snapshot = await getDocs(q);
    
    const userBestMap = new Map();
    snapshot.forEach(doc => {
      const data = doc.data();
      if (!userBestMap.has(data.uid)) {
        userBestMap.set(data.uid, data);
      }
    });
    
    let scores = Array.from(userBestMap.values());
    
    // Freunde-Filter anwenden
    if (currentChessRankingMode === 'friends') {
      const friendUIDs = userInventory.friends || [];
      const allowedUIDs = currentUser ? [currentUser.uid, ...friendUIDs] : friendUIDs;
      scores = scores.filter(s => allowedUIDs.includes(s.uid));
    }
    
    const getMs = (ts) => (ts && typeof ts.toMillis === 'function') ? ts.toMillis() : 0;
    if (filter === 'all') {
      scores.sort((a, b) => {
        const diffOrder = { champion: 3, profi: 2, noob: 1 };
        if (diffOrder[b.difficulty] !== diffOrder[a.difficulty]) {
          return diffOrder[b.difficulty] - diffOrder[a.difficulty];
        }
        return getMs(b.createdAt) - getMs(a.createdAt);
      });
    } else {
      // Bei gefilterter Ansicht nur nach Zeit absteigend sortieren
      scores.sort((a, b) => getMs(b.createdAt) - getMs(a.createdAt));
    }
    
    const top10 = scores.slice(0, 10);
    
    if (top10.length === 0) {
      listDiv.innerHTML = '<p style="text-align:center; opacity:0.7;">Noch keine Einträge</p>';
      return;
    }
    
    const difficultyEmoji = { noob: '🟢', profi: '🟡', champion: '🔴' };
    const difficultyLabels = { noob: 'Noob', profi: 'Profi', champion: 'Champion' };
    const isDark = document.body.classList.contains('dark-mode') || document.body.classList.contains('numbers-123-theme') || document.body.classList.contains('numbers123-theme');
    const nameColor = isDark ? '#00d1ff' : '#007bff';
    const rowBg = isDark ? '#2b2b2b' : '#f8f9fa';
    const textColor = isDark ? '#f2f4f8' : '#111';
    
    listDiv.innerHTML = '';
    
    for (const [index, entry] of top10.entries()) {
      const userDoc = await getDoc(doc(db, 'users', entry.uid));
      const profilePic = userDoc.exists() ? (userDoc.data().profilePic || getDefaultProfilePic()) : getDefaultProfilePic();
      const nameColorId = userDoc.exists() ? ((userDoc.data().inventory || {}).chatNameColor || null) : null;
      
      const medal = index === 0 ? '🥇' : (index === 1 ? '🥈' : (index === 2 ? '🥉' : `${index + 1}.`));
      const item = document.createElement('div');
      item.style.cssText = `display:flex; align-items:center; gap:10px; padding:10px; background:${rowBg}; color:${textColor}; border-radius:8px;`;
      item.innerHTML = `
        <img src="${profilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; cursor:pointer;" onclick="openUserProfile('${entry.uid}')">
        <span style="font-weight:bold; min-width:30px;">${medal}</span>
        ${(() => {
          const nn = entry.nickname || 'Unbekannt';
          if (nameColorId === 'santa_red') return `<span data-color-id="santa" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'holly_green') return `<span data-color-id="holly" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'icy_blue') return `<span data-color-id="icy" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'gold') return `<span data-color-id="gold" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'ruby_red') return `<span data-color-id="ruby" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'emerald') return `<span data-color-id="emerald" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'diamond') return `<span data-color-id="diamond" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId === 'rainbow') return `<span data-color-id="rainbow" style="flex:1; cursor:pointer; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          if (nameColorId) {
            const c = CHAT_COLORS.find(x => x.id === nameColorId);
            if (c) return `<span style="flex:1; cursor:pointer; color:${c.color}; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
          }
          return `<span style="flex:1; cursor:pointer; color:${nameColor}; font-weight:600;" onclick="openUserProfile('${entry.uid}')">${nn}</span>`;
        })()}
        <span>${difficultyEmoji[entry.difficulty]} ${difficultyLabels[entry.difficulty]}</span>
        <span style="font-weight:bold; color:#f39c12;">🪙 ${entry.coins}</span>
      `;
      listDiv.appendChild(item);
    }
  } catch (err) {
    console.error("Fehler beim Laden der Schach-Rankings:", err);
    listDiv.innerHTML = '<p style="color:red;">Fehler beim Laden</p>';
  }
}

if (document.getElementById('chessBoard')) {
  initChessBoard();
}

/////////////////////////////////////////////////////////////////////////////
// SHOP SYSTEM 🛍️
/////////////////////////////////////////////////////////////////////////////

// Daily Shop System
let dailyShop = {
  lastRotation: null,
  chatColors: [],
  themes: [],
  badge: null,
  music: [],
  fonts: []
};

// Generiere Daily Shop Items
function generateDailyShop() {
  const now = new Date();
  const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
  
  // Prüfe ob bereits heute rotiert wurde
  if (dailyShop.lastRotation === today) {
    return; // Bereits heute rotiert
  }
  
  // Seed basierend auf Datum für konsistente tägliche Auswahl
  const seed = today.split('-').join('');
  function seededRandom(seed) {
    const x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  }
  
  // 2 zufällige Chat-Farben (exklusive Battle Pass Items)
  const availableColors = CHAT_COLORS.filter(c => !c.exclusive && c.price > 0);
  const colorIndices = [];
  let colorSeed = parseInt(seed);
  while (colorIndices.length < 2 && colorIndices.length < availableColors.length) {
    const idx = Math.floor(seededRandom(colorSeed++) * availableColors.length);
    if (!colorIndices.includes(idx)) colorIndices.push(idx);
  }
  dailyShop.chatColors = colorIndices.map(i => availableColors[i].id);
  
  // 2 zufällige Themes (exklusive Battle Pass Items)
  const availableThemes = WEBSITE_THEMES.filter(t => !t.exclusive && t.price > 0);
  const themeIndices = [];
  let themeSeed = parseInt(seed) + 1000;
  while (themeIndices.length < 2 && themeIndices.length < availableThemes.length) {
    const idx = Math.floor(seededRandom(themeSeed++) * availableThemes.length);
    if (!themeIndices.includes(idx)) themeIndices.push(idx);
  }
  dailyShop.themes = themeIndices.map(i => availableThemes[i].id);
  
  // 1 zufälliges Badge (exklusive Battle Pass Items)
  const availableBadges = AVAILABLE_BADGES.filter(b => !b.exclusive && b.price > 0);
  if (availableBadges.length > 0) {
    const badgeSeed = parseInt(seed) + 2000;
    const badgeIdx = Math.floor(seededRandom(badgeSeed) * availableBadges.length);
    dailyShop.badge = availableBadges[badgeIdx].id;
  }
  
  // 2 zufällige Musik-Tracks
  const musicIds = ['lofi_beats', 'jazz_cafe', 'synthwave', 'chill_hop', 'piano_classics', 'electronic_dreams', 'ambient_waves', 'house_vibes'];
  const musicIndices = [];
  let musicSeed = parseInt(seed) + 3000;
  while (musicIndices.length < 2 && musicIndices.length < musicIds.length) {
    const idx = Math.floor(seededRandom(musicSeed++) * musicIds.length);
    if (!musicIndices.includes(idx)) musicIndices.push(idx);
  }
  dailyShop.music = musicIndices.map(i => musicIds[i]);
  
  // 2 zufällige Schriftarten
  const fontIds = ['modern_sans', 'classic_serif', 'monospace_code', 'elegant_script', 'bold_impact', 'tech_future', 'vintage_times', 'playful_comic'];
  const fontIndices = [];
  let fontSeed = parseInt(seed) + 4000;
  while (fontIndices.length < 2 && fontIndices.length < fontIds.length) {
    const idx = Math.floor(seededRandom(fontSeed++) * fontIds.length);
    if (!fontIndices.includes(idx)) fontIndices.push(idx);
  }
  dailyShop.fonts = fontIndices.map(i => fontIds[i]);
  
  dailyShop.lastRotation = today;
  console.log('Daily Shop rotiert:', dailyShop);
}

// Prüfe Daily Shop Rotation um 9:00 Uhr
function checkDailyShopRotation() {
  const now = new Date();
  const hour = now.getHours();
  const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
  
  // Wenn noch nicht heute rotiert und es ist 9 Uhr oder später
  if (dailyShop.lastRotation !== today && hour >= 9) {
    generateDailyShop();
  }
  // Beim ersten Laden auch generieren falls noch nie gemacht
  if (!dailyShop.lastRotation) {
    generateDailyShop();
  }
}

// Zeit bis zur nächsten Rotation
function getTimeUntilNextRotation() {
  const now = new Date();
  // Bestimme die nächste Rotation um 9:00 Uhr lokaler Zeit
  const next = new Date(now);
  const todayNine = new Date(now);
  todayNine.setHours(9, 0, 0, 0);
  // Wenn es vor 9:00 ist, rotiert heute um 9:00, sonst morgen um 9:00
  if (now < todayNine) {
    next.setHours(9, 0, 0, 0);
  } else {
    next.setDate(next.getDate() + 1);
    next.setHours(9, 0, 0, 0);
  }
  
  const diff = next - now;
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  
  return `${hours}h ${minutes}m`;
}

let userInventory = {
  snakeSkins: [],
  chatNameColor: null,
  chatColorsOwned: [],            // Dauerhaft gespeicherte Chat-Farben
  websiteTheme: "default",
  themesOwned: ["default", "dark"], // Dauerhaft gespeicherte Themes (kostenlose vorinstalliert)
  gifUnlocked: false              // GIF-Feature freigeschaltet
};

// Shop Items
const SNAKE_SKINS = [
  { id: "green", name: "Standard Grün", color: "#00FF00", price: 50 },
  { id: "red", name: "Rot", color: "#FF0000", price: 75 },
  { id: "blue", name: "Blau", color: "#0099FF", price: 75 },
  { id: "purple", name: "Violett", color: "#9933FF", price: 100 },
  { id: "gold", name: "Gold", color: "#FFD700", price: 150 },
  { id: "rainbow", name: "Regenbogen", color: "rainbow", price: 200 }
];

const CHAT_COLORS = [
  { id: "default", name: "Standard", color: "var(--name-default-color)", price: 0 },
  { id: "red", name: "Rot", color: "#FF0000", price: 100 },
  { id: "blue", name: "Blau", color: "#0099FF", price: 100 },
  { id: "green", name: "Grün", color: "#00AA00", price: 100 },
  { id: "purple", name: "Violett", color: "#9933FF", price: 100 },
  { id: "pink", name: "Pink", color: "#FF1493", price: 100 },
  { id: "gold", name: "Gold", color: "#FFD700", price: 300 },
  { id: "cyan", name: "Cyan", color: "#00FFFF", price: 100 },
  { id: "orange", name: "Orange", color: "#FF8800", price: 100 },
  { id: "silver", name: "Silber", color: "#C0C0C0", price: 150 },
  { id: "lime", name: "Lime", color: "#00FF00", price: 100 },
  { id: "crimson", name: "Crimson", color: "#DC143C", price: 150 },
  { id: "turquoise", name: "Türkis", color: "#40E0D0", price: 150 },
  { id: "violet", name: "Violet", color: "#EE82EE", price: 150 },
  { id: "rainbow", name: "Rainbow", color: "linear-gradient(90deg, red, orange, yellow, lime, cyan, blue, magenta)", price: 1000 },
  // Battle Pass Exclusive Colors
  { id: "ruby_red", name: "Ruby Red", color: "#E0115F", price: 0, exclusive: true },
  { id: "emerald", name: "Emerald", color: "#50C878", price: 0, exclusive: true },
  { id: "diamond", name: "Diamond", color: "#B9F2FF", price: 0, exclusive: true },
  // December Exclusives
  { id: "santa_red", name: "Santa Red", color: "#D32F2F", price: 0, exclusive: true },
  { id: "holly_green", name: "Holly Green", color: "#1B5E20", price: 0, exclusive: true },
  { id: "icy_blue", name: "Icy Blue", color: "#B3E5FC", price: 0, exclusive: true }
];

const WEBSITE_THEMES = [
  { 
    id: "default", 
    name: "Standard", 
    price: 0,
    bg: "#d4dce5",
    accent: "#007bff",
    preview: "linear-gradient(135deg, #d4dce5, #c0c8d0)"
  },
  { 
    id: "dark", 
    name: "Darkmode", 
    price: 0,
    bg: "#111",
    accent: "#0099ff",
    preview: "linear-gradient(135deg, #111, #222)"
  },
  { 
    id: "sunset", 
    name: "Sonnenuntergang", 
    price: 150,
    bg: "#e6d4bf",
    accent: "#ff6b35",
    preview: "linear-gradient(135deg, #ff6b35, #ffa500)"
  },
  { 
    id: "ocean", 
    name: "Ozean", 
    price: 150,
    bg: "#c5dbe8",
    accent: "#0066cc",
    preview: "linear-gradient(135deg, #006994, #0099cc)"
  },
  { 
    id: "forest", 
    name: "Wald", 
    price: 150,
    bg: "#d0e4d1",
    accent: "#2e7d32",
    preview: "linear-gradient(135deg, #2e7d32, #66bb6a)"
  },
  { 
    id: "candy", 
    name: "Bonbons", 
    price: 200,
    bg: "#e8cdd9",
    accent: "#e91e63",
    preview: "linear-gradient(135deg, #e91e63, #ff69b4)"
  },
  { 
    id: "cyberpunk", 
    name: "Cyberpunk", 
    price: 250,
    bg: "#0a0e27",
    accent: "#00ff88",
    preview: "linear-gradient(135deg, #00ff88, #0088ff)"
  },
  { 
    id: "numbers123", 
    name: "123 Glow", 
    price: 123,
    bg: "#000000",
    accent: "#ffffff",
    preview: "#000",
    hasNumbers: true
  },
  // Battle Pass Exclusive Themes
  {
    id: "midnight_purple",
    name: "Midnight Purple",
    price: 0,
    bg: "#1a0033",
    accent: "#9333ea",
    preview: "linear-gradient(135deg, #4c1d95, #7c3aed)",
    exclusive: true
  },
  {
    id: "aurora_borealis",
    name: "Aurora Borealis",
    price: 0,
    bg: "#0a1628",
    accent: "#00ff88",
    preview: "linear-gradient(135deg, #059669, #06b6d4, #8b5cf6, #ec4899)",
    exclusive: true
  },
  // December Exclusive Themes
  {
    id: "winter_wonderland",
    name: "Winter Wonderland",
    price: 0,
    bg: "#cfe0f5",
    accent: "#1565C0",
    preview: "linear-gradient(135deg, #e9f4ff, #cfe8ff)",
    exclusive: true
  },
  {
    id: "candy_cane",
    name: "Candy Cane",
    price: 0,
    bg: "#f4d9d9",
    accent: "#C62828",
    preview: "linear-gradient(135deg, #ffebee, #ffcdd2)",
    exclusive: true
  },
  {
    id: "frosty_night",
    name: "Frosty Night",
    price: 0,
    bg: "#0d1b2a",
    accent: "#00d4ff",
    preview: "linear-gradient(135deg, #1b263b, #415a77, #778da9)",
    exclusive: true
  }
];

// Merge Advent items into catalogs now that arrays exist
try { mergeAdventRewardsIntoCatalogs(); } catch(_) {}

// Verfügbare Badges im Shop
const AVAILABLE_BADGES = [
  { id: "admin", name: "Admin", icon: "⚡", price: 0, exclusive: true },
  { id: "coin_master", name: "Coin Master", icon: "💰", price: 10000 },
  { id: "pro_gamer", name: "Pro Gamer", icon: "🎮", price: 500 },
  { id: "speedrunner", name: "Speedrunner", icon: "⚡", price: 750 },
  { id: "champion", name: "Champion", icon: "🏆", price: 1000 },
  { id: "legend", name: "Legend", icon: "👑", price: 1500 },
  { id: "fire", name: "Fire", icon: "🔥", price: 300 },
  { id: "star", name: "Star", icon: "⭐", price: 400 },
  { id: "diamond_badge", name: "Diamond", icon: "💎", price: 2000 },
  { id: "rocket", name: "Rocket", icon: "🚀", price: 600 },
  // Battle Pass Exclusive Badges
  { id: "november_bronze", name: "November Bronze", icon: "🥉", price: 0, exclusive: true },
  { id: "november_silver", name: "November Silver", icon: "🥈", price: 0, exclusive: true },
  { id: "november_gold", name: "November Gold", icon: "🥇", price: 0, exclusive: true },
  { id: "november_legend", name: "November Legend", icon: "👑", price: 0, exclusive: true },
  // December Exclusive Badges
  { id: "december_bronze", name: "Dezember Bronze", icon: "❄️", price: 0, exclusive: true },
  { id: "december_silver", name: "Dezember Silber", icon: "🎄", price: 0, exclusive: true },
  { id: "december_gold", name: "Dezember Gold", icon: "⭐", price: 0, exclusive: true },
  { id: "december_legend", name: "Dezember Legende", icon: "🎅", price: 0, exclusive: true }
];

// Lade Benutzer-Inventar
async function loadUserInventory() {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, "users", currentUser.uid));
    if (userDoc.exists()) {
      const inv = userDoc.data().inventory || {};
      userInventory = {
        snakeSkins: inv.snakeSkins || [],
        chatNameColor: inv.chatNameColor || null,
        chatColorsOwned: inv.chatColorsOwned || ["default"],
        websiteTheme: inv.websiteTheme || "default",
        themesOwned: inv.themesOwned || ["default", "dark"],
        badges: inv.badges || [],
        activeBadge: inv.activeBadge || null,
        gifUnlocked: inv.gifUnlocked || false
      };
      
      // Migration: Konvertiere alte Farb-Namen zu IDs
      const colorNameToId = {
        'Ruby Red': 'ruby_red',
        'Emerald': 'emerald',
        'Diamond': 'diamond'
      };
      
      let needsSave = false;
      userInventory.chatColorsOwned = userInventory.chatColorsOwned.map(colorIdOrName => {
        if (colorNameToId[colorIdOrName]) {
          console.log(`🔄 Migration: "${colorIdOrName}" -> "${colorNameToId[colorIdOrName]}"`);
          needsSave = true;
          return colorNameToId[colorIdOrName];
        }
        return colorIdOrName;
      });
      
      // Stelle sicher, dass jeder die Standard-Farbe hat
      if (!userInventory.chatColorsOwned.includes("default")) {
        userInventory.chatColorsOwned.push("default");
        needsSave = true;
      }
      
      if (needsSave) {
        await saveInventory();
        console.log("💾 Inventar nach Migration gespeichert");
      }
      
      console.log("✅ Inventar geladen:", {
        chatNameColor: userInventory.chatNameColor,
        chatColorsOwned: userInventory.chatColorsOwned,
        badges: userInventory.badges,
        activeBadge: userInventory.activeBadge
      });
      
      applyUserTheme();
    }

    // Admin: automatisch alle Badges, Farben und Themes besitzen
    if (auth.currentUser && auth.currentUser.email === ADMIN_EMAIL) {
      const allColorIds = CHAT_COLORS.map(c => c.id);
      const allThemeIds = WEBSITE_THEMES.map(t => t.id);
      const allBadges = AVAILABLE_BADGES.map(b => ({ id: b.id, name: b.name, icon: b.icon }));
      userInventory.chatColorsOwned = allColorIds;
      userInventory.themesOwned = allThemeIds;
      userInventory.badges = allBadges;
      if (!userInventory.activeBadge) userInventory.activeBadge = 'admin';
      // Standard: stelle sicher, dass default/dark vorhanden sind
      if (!userInventory.themesOwned.includes('default')) userInventory.themesOwned.push('default');
      if (!userInventory.themesOwned.includes('dark')) userInventory.themesOwned.push('dark');
      await saveInventory();
      console.log('👑 Admin-Inventar gewährt: alle Farben, Themes und Badges.');
    }
    displayShop();
  } catch (err) {
    console.error("Fehler beim Laden des Inventars:", err);
  }
}

// Speichere Inventar
async function saveInventory() {
  if (!currentUser) return;
  
  try {
    await setDoc(doc(db, "users", currentUser.uid), {
      inventory: userInventory
    }, { merge: true });
  } catch (err) {
    console.error("Fehler beim Speichern des Inventars:", err);
  }
}

// Website Themes anwenden
function applyUserTheme() {
  const theme = WEBSITE_THEMES.find(t => t.id === userInventory.websiteTheme);
  if (!theme) return;

  // Akzent immer setzen
  document.documentElement.style.setProperty("--theme-accent", theme.accent);
  
  // Entferne vorherige Theme-Klassen
  document.body.classList.remove("numbers-123-theme");
  document.body.classList.remove("dark-mode");
  document.body.classList.remove("aurora-borealis-theme");
  document.body.classList.remove("midnight-purple-theme");
  document.body.classList.remove("frosty-night-theme");
  document.body.classList.remove("advent-crystal-palace-theme");
  document.body.classList.remove("advent-northern-lights-theme");
  document.body.classList.remove("advent-holy-night-theme");
  
  // Entferne alte Zahlen
  document.querySelectorAll('.number-floating').forEach(el => el.remove());
  
  // Entferne inline Styles
  document.body.style.background = "";
  document.body.style.color = "";

  // Spezialbehandlung für "123 Theme"
  if (theme.id === "numbers123") {
    document.body.classList.add("numbers-123-theme");
    document.body.style.background = "#000000";
    document.body.style.color = "#ffffff";
    
    // Generiere schwebende Zahlen
    createFloatingNumbers();
    
    // Setze Theme-Variablen für Karten etc.
    document.documentElement.style.setProperty("--theme-bg", "#000");
    document.documentElement.style.setProperty("--theme-card-bg", "#1a1a1a");
    document.documentElement.style.setProperty("--theme-chat-msg", "#2a2a2a");
    document.documentElement.style.setProperty("--theme-text", "#ffffff");
    
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Darkmode";
    disableSnowfall();
  }
  // Spezialbehandlung für "Midnight Purple" Theme
  else if (theme.id === "midnight_purple") {
    document.body.classList.add("midnight-purple-theme");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    disableSnowfall();
  }
  // Spezialbehandlung für "Aurora Borealis" Theme
  else if (theme.id === "aurora_borealis") {
    document.body.classList.add("aurora-borealis-theme");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    disableSnowfall();
  }
  // Spezialbehandlung für "Frosty Night" Theme
  else if (theme.id === "frosty_night") {
    document.body.classList.add("frosty-night-theme");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    enableSnowfall();
  }
  // Spezialbehandlung für "Kristallpalast" Advent Theme
  else if (theme.id === "advent_crystal_palace") {
    document.body.classList.add("advent-crystal-palace-theme");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    disableSnowfall();
  }
  // Spezialbehandlung für "Nordlichter" Advent Theme
  else if (theme.id === "advent_northern_lights") {
    document.body.classList.add("advent-northern-lights-theme");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    disableSnowfall();
  }
  // Spezialbehandlung für "Heilige Nacht" Advent Theme
  else if (theme.id === "advent_holy_night") {
    document.body.classList.add("advent-holy-night-theme");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    disableSnowfall();
  }
  // Dezember-Themes: Snowfall aktivieren
  else if (theme.id === "winter_wonderland" || theme.id === "candy_cane") {
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Standard";
    // Lightmode Variablen setzen
    document.documentElement.style.setProperty("--theme-bg", theme.bg);
    document.documentElement.style.setProperty("--theme-card-bg", "#ffffff");
    document.documentElement.style.setProperty("--theme-chat-msg", "#e9ecef");
    document.documentElement.style.setProperty("--theme-text", "#111");
    enableSnowfall();
  }
  // Spezialbehandlung für "dark" Theme
  else if (theme.id === "dark") {
    document.body.classList.add("dark-mode");
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Whitemode";
    disableSnowfall();
  } else {
    if (typeof themeToggle !== 'undefined' && themeToggle) themeToggle.textContent = "Darkmode";
    
    // Lightmode: kompletter Theme-Look
    document.documentElement.style.setProperty("--theme-bg", theme.bg);
    document.documentElement.style.setProperty("--theme-card-bg", "#ffffff");
    document.documentElement.style.setProperty("--theme-chat-msg", "#e9ecef");
    document.documentElement.style.setProperty("--theme-text", "#111");
    disableSnowfall();
  }

  // Synchronisiere aktives Theme mit DOM-Zustand, damit die Shop-Badges korrekt sind
  if (document.body.classList.contains("dark-mode")) {
    userInventory.websiteTheme = "dark";
  } else if (document.body.classList.contains("numbers-123-theme")) {
    userInventory.websiteTheme = "numbers123";
  } else {
    // Falls ein anderes Light-Theme aktiv ist, bleibt dessen ID erhalten
    if (userInventory.websiteTheme === "dark") {
      userInventory.websiteTheme = "default";
    }
  }
}

// Erstelle schwebende Zahlen für 123 Theme
function createFloatingNumbers() {
  const numbers = ['1', '2', '3'];
  const positions = [
    { top: '10%', left: '15%' },
    { top: '25%', left: '70%' },
    { top: '45%', left: '25%' },
    { top: '60%', left: '80%' },
    { top: '75%', left: '10%' },
    { top: '15%', left: '85%' },
    { top: '55%', left: '50%' },
    { top: '85%', left: '60%' },
    { top: '35%', left: '45%' },
    { top: '70%', left: '35%' }
  ];
  
  positions.forEach((pos, index) => {
    const numberEl = document.createElement('div');
    numberEl.className = 'number-floating';
    numberEl.textContent = numbers[index % 3];
    numberEl.style.top = pos.top;
    numberEl.style.left = pos.left;
    numberEl.style.animationDelay = `${index * 0.5}s`;
    document.body.appendChild(numberEl);
  });
}

/////////////////////////////////////////////////////////////////////////////
// Snowfall Effect for December Themes
/////////////////////////////////////////////////////////////////////////////

let __snowIntervalId = null;
let __snowContainer = null;
let __snowStyleInjected = false;

function ensureSnowCSS() {
  if (__snowStyleInjected) return;
  const style = document.createElement('style');
  style.id = 'snowfall-style';
  style.textContent = `
    .snowfall-container { position: fixed; inset: 0; pointer-events: none; z-index: 999; overflow: hidden; }
    .snowflake { position: fixed; top: -10px; color: #ffffff; opacity: 0.9; will-change: transform; text-shadow: 0 0 4px rgba(255,255,255,0.8); }
    @keyframes snow-fall { to { transform: translateY(110vh); } }
  `;
  document.head.appendChild(style);
  __snowStyleInjected = true;
}

function enableSnowfall() {
  ensureSnowCSS();
  if (!__snowContainer) {
    __snowContainer = document.createElement('div');
    __snowContainer.className = 'snowfall-container';
    __snowContainer.id = 'snowfallContainer';
    document.body.appendChild(__snowContainer);
  }
  if (__snowIntervalId) return; // already running

  __snowIntervalId = setInterval(() => {
    // Create a snowflake
    const flake = document.createElement('div');
    // Use glyph for better performance and visibility
    flake.className = 'snowflake';
    flake.textContent = '❄';
    const startLeft = Math.random() * window.innerWidth;
    const size = 8 + Math.random() * 14; // 8px - 22px
    const duration = 6 + Math.random() * 6; // 6s - 12s
    const delay = Math.random() * 2; // 0 - 2s
    const drift = (Math.random() - 0.5) * 80; // -40px to 40px horizontal drift

    flake.style.left = `${startLeft}px`;
    flake.style.fontSize = `${size}px`;
    flake.style.animation = `snow-fall ${duration}s linear ${delay}s forwards`;

    // Add a subtle horizontal drift via transition
    flake.animate(
      [ { transform: 'translateY(-10px) translateX(0px)' }, { transform: `translateY(110vh) translateX(${drift}px)` } ],
      { duration: (duration + delay) * 1000, iterations: 1, easing: 'linear', fill: 'forwards' }
    );

    __snowContainer.appendChild(flake);
    setTimeout(() => { if (flake && flake.parentNode) flake.parentNode.removeChild(flake); }, (duration + delay) * 1000 + 100);
  }, 160);
}

function disableSnowfall() {
  if (__snowIntervalId) {
    clearInterval(__snowIntervalId);
    __snowIntervalId = null;
  }
  if (__snowContainer) {
    __snowContainer.querySelectorAll('.snowflake').forEach(el => el.remove());
  }
}

// Kaufe Item
window.buyShopItem = async function(type, itemId) {
  if (!currentUser) {
    showNotification("Fehler", "Bitte einloggen!");
    return;
  }

  let item = null;
  let price = 0;

  if (type === "chatColor") {
    item = CHAT_COLORS.find(c => c.id === itemId);
    if (!item) return;
    // Bereits gekauft? Kostenlos aktivieren
    if (userInventory.chatColorsOwned && userInventory.chatColorsOwned.includes(itemId)) {
      userInventory.chatNameColor = itemId;
      await saveInventory();
      showNotification("Aktiviert", `Farbe "${item.name}" ist jetzt aktiv!`);
      displayShop();
      displayInventory();
      return;
    }
    price = item.price;
  } else if (type === "websiteTheme") {
    item = WEBSITE_THEMES.find(t => t.id === itemId);
    if (!item) return;
    price = item.price;
    // Bereits gekauft oder kostenlos? Kostenlos aktivieren
    const ownsTheme = (userInventory.themesOwned && userInventory.themesOwned.includes(itemId)) || item.price === 0;
    if (ownsTheme) {
      userInventory.websiteTheme = itemId;
      await saveInventory();
      applyUserTheme();
      showNotification("Theme aktiviert", `Theme "${item.name}" ist jetzt aktiv!`);
      updateSlotBalance();
      displayShop();
      displayInventory();
      return;
    }
  }

  if (userCoins < price) {
    showNotification("Nicht genug Münzen", `Du brauchst ${price} Münzen!`);
    return;
  }

  await addCoins(-price);
  
  if (type === "chatColor") {
    if (!userInventory.chatColorsOwned) userInventory.chatColorsOwned = [];
    if (!userInventory.chatColorsOwned.includes(itemId)) userInventory.chatColorsOwned.push(itemId);
    userInventory.chatNameColor = itemId;
    showNotification("Gekauft! 🎨", `Farbe "${item.name}" gehört dir für immer!`);
  } else if (type === "websiteTheme") {
    if (!userInventory.themesOwned) userInventory.themesOwned = ["default", "dark"];
    if (!userInventory.themesOwned.includes(itemId)) userInventory.themesOwned.push(itemId);
    userInventory.websiteTheme = itemId;
    applyUserTheme();
    showNotification("Gekauft! 🌈", `Theme "${item.name}" gehört dir für immer!`);
  } else if (type === 'gifUnlock') {
    // GIF-Feature freischalten
    if (userInventory.gifUnlocked) {
      showNotification("Bereits freigeschaltet", "Du kannst bereits GIFs senden!");
      return;
    }
    
    const price = 1000;
    if (slotBalance < price) {
      showNotification("Nicht genug Münzen", `Du brauchst ${price} Münzen!`);
      return;
    }
    
    await addCoins(-price);
    userInventory.gifUnlocked = true;
    showNotification("GIF-Feature freigeschaltet! 🎬", "Du kannst jetzt GIFs im Chat senden!");
  } else if (type === 'badge') {
    // Badge kaufen
    const badge = AVAILABLE_BADGES.find(b => b.id === itemId);
    if (!badge) return;
    
    // Bereits gekauft?
    const owned = userInventory.badges.find(b => b.id === itemId);
    if (owned) {
      showNotification("Bereits gekauft", "Du besitzt dieses Badge bereits!");
      return;
    }
    
    const badgePrice = badge.price;
    if (slotBalance < badgePrice) {
      showNotification("Nicht genug Münzen", `Du brauchst ${badgePrice} Münzen!`);
      return;
    }
    
    await addCoins(-badgePrice);
    
    if (!userInventory.badges) userInventory.badges = [];
    userInventory.badges.push({ id: badge.id, name: badge.name, icon: badge.icon });
    
    showNotification("Badge gekauft! 🎖️", `${badge.icon} ${badge.name} gehört dir jetzt!`);
  }

  await saveInventory();
  updateSlotBalance();
  loadUserInventory();
  displayInventory();
};

// Musik kaufen
window.buyShopMusic = async function(musicId, price) {
  if (!currentUser) {
    showNotification("Fehler", "Bitte einloggen!");
    return;
  }
  
  if (userCoins < price) {
    showNotification("Nicht genug Münzen", `Du brauchst ${price} Münzen!`);
    return;
  }
  
  await addCoins(-price);
  const musicRef = doc(db, 'inventory', currentUser.uid, 'music', musicId);
  await setDoc(musicRef, { ts: Date.now() });
  
  showNotification("Musik gekauft! 🎵", "Die Musik wurde deinem Inventar hinzugefügt!");
  displayShop();
  displayInventory();
};

// Schriftart kaufen
window.buyShopFont = async function(fontId, price) {
  if (!currentUser) {
    showNotification("Fehler", "Bitte einloggen!");
    return;
  }
  
  if (userCoins < price) {
    showNotification("Nicht genug Münzen", `Du brauchst ${price} Münzen!`);
    return;
  }
  
  await addCoins(-price);
  const fontRef = doc(db, 'inventory', currentUser.uid, 'fonts', fontId);
  await setDoc(fontRef, { ts: Date.now() });
  
  showNotification("Schriftart gekauft! 🖋️", "Die Schriftart wurde deinem Inventar hinzugefügt!");
  displayShop();
  displayInventory();
};

// Musik Preview
window.previewMusic = function(musicId) {
  const musicMap = {
    lofi_beats: [{ f: 440, d: 300 }, { f: 554, d: 300 }, { f: 659, d: 600 }],
    jazz_cafe: [{ f: 523, d: 250 }, { f: 659, d: 250 }, { f: 783, d: 500 }],
    synthwave: [{ f: 330, d: 200 }, { f: 440, d: 200 }, { f: 554, d: 400 }],
    chill_hop: [{ f: 392, d: 350 }, { f: 494, d: 350 }, { f: 587, d: 700 }],
    piano_classics: [{ f: 523, d: 400 }, { f: 587, d: 400 }, { f: 659, d: 800 }],
    electronic_dreams: [{ f: 880, d: 150 }, { f: 1046, d: 150 }, { f: 1318, d: 300 }],
    ambient_waves: [{ f: 220, d: 500 }, { f: 277, d: 500 }, { f: 330, d: 1000 }],
    house_vibes: [{ f: 440, d: 200 }, { f: 554, d: 200 }, { f: 659, d: 200 }, { f: 880, d: 400 }]
  };
  const seq = musicMap[musicId] || [{ f: 440, d: 400 }];
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const gain = ctx.createGain();
    gain.gain.value = 0.3;
    gain.connect(ctx.destination);
    let t = ctx.currentTime;
    seq.forEach(n => {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(n.f, t);
      const g = ctx.createGain();
      g.gain.value = 0.0001;
      g.gain.linearRampToValueAtTime(0.4, t + 0.02);
      g.gain.linearRampToValueAtTime(0.0001, t + n.d/1000);
      osc.connect(g);
      g.connect(gain);
      osc.start(t);
      osc.stop(t + n.d/1000);
      t += (n.d + 50)/1000;
    });
    setTimeout(() => { ctx.close(); }, (t - ctx.currentTime + 0.5) * 1000);
  } catch(e) { console.error('Audio preview error:', e); }
};

// Toggle GIF Input
window.toggleGifInput = function() {
  const gifUrl = document.getElementById('gifUrl');
  if (gifUrl.style.display === 'none' || !gifUrl.style.display) {
    gifUrl.style.display = 'block';
    gifUrl.focus();
  } else {
    gifUrl.style.display = 'none';
  }
};

// Aktiviere Chat-Farbe aus Inventar
window.activateChatColor = async function(colorId) {
  if (!currentUser) return;
  
  if (!userInventory.chatColorsOwned.includes(colorId)) {
    showNotification("Fehler", "Du besitzt diese Farbe nicht!");
    return;
  }
  
  console.log("🎨 Aktiviere Farbe:", colorId);
  userInventory.chatNameColor = colorId;
  await saveInventory();
  console.log("💾 Gespeichert - jetzt reload...");
  await loadUserInventory(); // Inventar neu laden
  console.log("✅ Nach Reload - chatNameColor:", userInventory.chatNameColor);
  
  const color = CHAT_COLORS.find(c => c.id === colorId);
  showNotification("Aktiviert! 🎨", `Farbe "${color?.name || colorId}" ist jetzt aktiv!`);
  displayInventory();
};

// Zeige Shop
function displayShop() {
  // Prüfe Daily Shop Rotation
  checkDailyShopRotation();
  
  // Vor dem Rendern: stelle sicher, dass der aktive Theme-Status zur DOM passt
  if (document.body.classList.contains("dark-mode")) {
    userInventory.websiteTheme = "dark";
  }
  // Defensive Defaults, falls Inventar aus älteren Strukturen kommt
  userInventory.chatColorsOwned = Array.isArray(userInventory.chatColorsOwned) ? userInventory.chatColorsOwned : [];
  userInventory.themesOwned = Array.isArray(userInventory.themesOwned) ? userInventory.themesOwned : ["default", "dark"];

  // Daily Shop Header
  const timeUntilNext = getTimeUntilNextRotation();
  const t = (translations[currentLanguage] || translations['de'] || {});
  const dailyShopHeaderHtml = `
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px; border-radius: 8px; margin-bottom: 15px; color: white; text-align: center;">
      <h3 style="margin: 0 0 5px 0;">${t.daily_shop_title || '🌟 Daily Shop'}</h3>
      <p style="margin: 0; font-size: 13px; opacity: 0.9;">${t.daily_shop_subtitle || 'Täglich um 9:00 Uhr neue Angebote!'}</p>
      <p style="margin: 5px 0 0 0; font-size: 12px; opacity: 0.8;">${t.daily_shop_next_rotation || '⏰ Nächste Rotation in:'} ${timeUntilNext}</p>
    </div>
  `;
  
  const shopHeaderEl = document.getElementById("shopHeader");
  if (shopHeaderEl) shopHeaderEl.innerHTML = dailyShopHeaderHtml;

  // Chat Farben - Zeige nur Daily Shop Items + Standard
  let colorHtml = "";
  const dailyColors = CHAT_COLORS.filter(c => dailyShop.chatColors.includes(c.id) || c.id === 'default');
  dailyColors.forEach(color => {
    const owned = userInventory.chatColorsOwned.includes(color.id);
    const isDailyItem = dailyShop.chatColors.includes(color.id);
    colorHtml += `
      <div class="shop-item ${owned ? 'owned' : ''}" style="${isDailyItem ? 'border: 2px solid #667eea;' : ''}">
        <div class="shop-item-info">
          <div style="display:flex; align-items:center;">
            <div class="color-preview" style="background: ${color.color};"></div>
            <strong>${color.name} ${isDailyItem ? '⭐' : ''}</strong>
          </div>
        </div>
        ${owned
          ? `<div class="shop-item-owned-badge">${t.purchased || '✓ Gekauft'}</div>`
          : `<div><span class="shop-item-price">🪙 ${color.price}</span> <button onclick="buyShopItem('chatColor', '${color.id}')" style="padding:5px 10px; font-size:12px;">${t.buy || 'Kaufen'}</button></div>`}
      </div>
    `;
  });
  const colorListEl = document.getElementById("chatColorList");
  if (colorListEl) colorListEl.innerHTML = colorHtml;

  // Website Themes – zeige nur Daily-Auswahl (+ Quick Toggles)
  let themeHtml = "";
  // Schnellumschalter für Standard/Darkmode
  themeHtml += `
    <div style="display:flex; gap:8px; margin-bottom:10px;">
      <button onclick="buyShopItem('websiteTheme','default')" style="padding:6px 10px; font-size:12px;">${t.activate_default || 'Standard aktivieren'}</button>
      <button onclick="buyShopItem('websiteTheme','dark')" style="padding:6px 10px; font-size:12px;">${t.activate_dark || 'Darkmode aktivieren'}</button>
    </div>
  `;
  const dailyThemes = WEBSITE_THEMES.filter(theme => dailyShop.themes.includes(theme.id));
  dailyThemes.forEach(theme => {
    const owned = userInventory.themesOwned.includes(theme.id) || theme.price === 0;
    themeHtml += `
      <div class="shop-item ${owned ? 'owned' : ''}" style="border: 2px solid #667eea;">
        <div class="shop-item-info">
          <div style="display:flex; align-items:center;">
            <div class="theme-preview" style="background: ${theme.preview}; ${theme.id === 'numbers123' ? 'position: relative; display: flex; align-items: center; justify-content: center; font-family: Courier New, monospace; font-size: 14px; font-weight: bold; color: #00ff41; text-shadow: 0 0 5px #00ff41;' : ''}">
              ${theme.id === 'numbers123' ? '123' : ''}
            </div>
            <strong>${theme.name} ⭐</strong>
          </div>
        </div>
        ${owned
          ? `<div class="shop-item-owned-badge">${t.purchased || '✓ Gekauft'}</div>`
          : `<div><span class="shop-item-price">🪙 ${theme.price}</span> <button onclick="buyShopItem('websiteTheme', '${theme.id}')" style="padding:5px 10px; font-size:12px;">${t.buy || 'Kaufen'}</button></div>`}
      </div>
    `;
  });
  const themesListEl = document.getElementById("themesList");
  if (themesListEl) themesListEl.innerHTML = themeHtml;
  
  // Badges - Zeige nur Daily Shop Badge
  let badgeHtml = "";
  const dailyBadge = AVAILABLE_BADGES.find(b => b.id === dailyShop.badge);
  if (dailyBadge) {
    const owned = userInventory.badges.find(b => b.id === dailyBadge.id);
    badgeHtml += `
      <div class="shop-item ${owned ? 'owned' : ''}" style="border: 2px solid #667eea;">
        <div class="shop-item-info">
          <strong>${dailyBadge.icon} ${dailyBadge.name} ⭐</strong>
        </div>
        ${owned
          ? `<div class="shop-item-owned-badge">${t.purchased || '✓ Gekauft'}</div>`
          : `<div><span class="shop-item-price">🪙 ${dailyBadge.price}</span> <button onclick="buyShopItem('badge', '${dailyBadge.id}')" style="padding:5px 10px; font-size:12px;">${t.buy || 'Kaufen'}</button></div>`}
      </div>
    `;
  }
  const badgesListEl = document.getElementById("badgesList");
  if (badgesListEl) badgesListEl.innerHTML = badgeHtml;

  // Musik - Zeige nur 2 zufällige Daily Tracks
  let musicHtml = "";
  const SHOP_MUSIC = [
    { id: 'lofi_beats', name: 'Lofi Beats', demo: '🎧', price: 200 },
    { id: 'jazz_cafe', name: 'Jazz Café', demo: '☕', price: 200 },
    { id: 'synthwave', name: 'Synthwave', demo: '🌆', price: 200 },
    { id: 'chill_hop', name: 'Chill Hop', demo: '🎵', price: 200 },
    { id: 'piano_classics', name: 'Piano Classics', demo: '🎹', price: 250 },
    { id: 'electronic_dreams', name: 'Electronic Dreams', demo: '⚡', price: 250 },
    { id: 'ambient_waves', name: 'Ambient Waves', demo: '🌊', price: 300 },
    { id: 'house_vibes', name: 'House Vibes', demo: '🏠', price: 300 }
  ];
  const dailyMusic = dailyShop.music || [];
  const selectedMusic = SHOP_MUSIC.filter(m => dailyMusic.includes(m.id));
  
  // Async check für gekaufte Musik
  (async () => {
    for (const music of selectedMusic) {
      let owned = false;
      if (currentUser) {
        try {
          const musicRef = doc(db, 'inventory', currentUser.uid, 'music', music.id);
          const snap = await getDoc(musicRef);
          owned = snap.exists();
        } catch(e) {}
      }
      
      musicHtml += `
        <div class="shop-item ${owned ? 'owned' : ''}" style="border: 2px solid #667eea;">
          <div class="shop-item-info">
            <div style="display:flex; align-items:center; gap:8px;">
              <strong>🎵 ${music.name} ⭐</strong>
              <button onclick="previewMusic('${music.id}')" style="background:#555;color:#fff;padding:4px 8px;border-radius:4px;border:none;cursor:pointer;font-size:11px;">${music.demo} Demo</button>
            </div>
          </div>
          ${owned 
            ? '<div class="shop-item-owned-badge">✓ Gekauft</div>' 
            : `<div><span class="shop-item-price">🪙 ${music.price}</span> <button onclick="buyShopMusic('${music.id}', ${music.price})" style="padding:5px 10px; font-size:12px;">${t.buy || 'Kaufen'}</button></div>`}
        </div>
      `;
    }
    const musicListEl = document.getElementById("musicList");
    if (musicListEl) musicListEl.innerHTML = musicHtml;
  })();

  // Schriftarten - Zeige nur 2 zufällige Daily Fonts
  let fontsHtml = "";
  const SHOP_FONTS = [
    { id: 'modern_sans', name: 'Modern Sans', css: 'font-family: "Segoe UI", sans-serif; letter-spacing: 0.5px;', price: 200 },
    { id: 'classic_serif', name: 'Classic Serif', css: 'font-family: Georgia, serif; letter-spacing: 0.3px;', price: 200 },
    { id: 'monospace_code', name: 'Monospace Code', css: 'font-family: "Courier New", monospace; letter-spacing: 1px;', price: 200 },
    { id: 'elegant_script', name: 'Elegant Script', css: 'font-family: "Trebuchet MS", cursive; font-style: italic;', price: 200 },
    { id: 'bold_impact', name: 'Bold Impact', css: 'font-family: Impact, sans-serif; font-weight: bold; letter-spacing: 1px;', price: 250 },
    { id: 'tech_future', name: 'Tech Future', css: 'font-family: "Arial Black", sans-serif; letter-spacing: 2px;', price: 250 },
    { id: 'vintage_times', name: 'Vintage Times', css: 'font-family: "Times New Roman", serif; letter-spacing: 0.8px;', price: 300 },
    { id: 'playful_comic', name: 'Playful Comic', css: 'font-family: "Comic Sans MS", cursive; letter-spacing: 0.5px;', price: 300 }
  ];
  const dailyFonts = dailyShop.fonts || [];
  const selectedFonts = SHOP_FONTS.filter(f => dailyFonts.includes(f.id));
  
  // Async check für gekaufte Fonts
  (async () => {
    for (const font of selectedFonts) {
      let owned = false;
      if (currentUser) {
        try {
          const fontRef = doc(db, 'inventory', currentUser.uid, 'fonts', font.id);
          const snap = await getDoc(fontRef);
          owned = snap.exists();
        } catch(e) {}
      }
      
      fontsHtml += `
        <div class="shop-item ${owned ? 'owned' : ''}" style="border: 2px solid #667eea;">
          <div class="shop-item-info">
            <div style="display:flex; flex-direction:column; gap:8px;">
              <strong>🖋️ ${font.name} ⭐</strong>
              <div style="${font.css} background:#f8f8f8;padding:8px 12px;border-radius:4px;color:#000;font-size:16px;">The quick brown fox jumps over the lazy dog</div>
            </div>
          </div>
          ${owned 
            ? '<div class="shop-item-owned-badge">✓ Gekauft</div>' 
            : `<div><span class="shop-item-price">🪙 ${font.price}</span> <button onclick="buyShopFont('${font.id}', ${font.price})" style="padding:5px 10px; font-size:12px;">${t.buy || 'Kaufen'}</button></div>`}
        </div>
      `;
    }
    const fontsListEl = document.getElementById("fontsList");
    if (fontsListEl) fontsListEl.innerHTML = fontsHtml;
  })();
}

// Inventar anzeigen
function displayInventory() {
  console.log('🚀 displayInventory() AUFGERUFEN');
  // Globale Steuerung
  if (typeof window.inventoryCategory === 'undefined') window.inventoryCategory = 'all';
  if (typeof window.inventoryCompactMode === 'undefined') window.inventoryCompactMode = false;
  if (!window.inventoryFavorites) {
    try { window.inventoryFavorites = new Set(JSON.parse(localStorage.getItem('inventoryFavorites')||'[]')); } catch(e){ window.inventoryFavorites = new Set(); }
  }
  // Lokale Referenz erstellen (Bugfix: vorher wurde inventoryFavorites direkt genutzt ohne Deklaration -> ReferenceError)
  const inventoryFavorites = window.inventoryFavorites;
  const searchInput = document.getElementById('inventorySearch');
  const searchTerm = (searchInput ? searchInput.value.trim().toLowerCase() : '');
  const favsOnly = document.getElementById('inventoryFavsOnly')?.checked || false;

  console.log('🔍 Inventar Filter:', { searchTerm, favsOnly, category: window.inventoryCategory });
  console.log('📦 Input Element:', searchInput);
  console.log('📝 Input Value:', searchInput?.value);

  if (!userInventory.chatColorsOwned) userInventory.chatColorsOwned = [];
  if (!userInventory.themesOwned) userInventory.themesOwned = ["default", "dark"];
  if (!userInventory.badges) userInventory.badges = [];

  console.log("🎨 DisplayInventory aufgerufen:");
  console.log("  chatColorsOwned:", userInventory.chatColorsOwned);
  console.log("  CHAT_COLORS IDs:", CHAT_COLORS.map(c => c.id));

  // Chat Colors
  let colorsHtml = "";
  if (userInventory.chatColorsOwned.length === 0) {
    colorsHtml = "<p style='opacity:0.6;'>Noch keine Farben gekauft</p>";
  } else {
    let matchedCount = 0;
    userInventory.chatColorsOwned.forEach(colorId => {
      const color = CHAT_COLORS.find(c => c.id === colorId);
      if (!color) {
        console.warn(`⚠️ Farbe "${colorId}" im Inventar aber nicht in CHAT_COLORS gefunden!`);
        return;
      }
      const active = userInventory.chatNameColor === colorId;
      const favKey = `color:${color.id}`;
      const isFav = inventoryFavorites.has(favKey);
      
      // Debug: Zeige jeden Filter-Schritt
      const passedFavFilter = !favsOnly || isFav;
      const passedSearchFilter = !searchTerm || color.name.toLowerCase().includes(searchTerm);
      console.log(`🎨 ${color.name}: favFilter=${passedFavFilter}, searchFilter=${passedSearchFilter}`);
      
      if (favsOnly && !isFav) return;
      if (searchTerm && !color.name.toLowerCase().includes(searchTerm)) return;
      
      matchedCount++;
      const compact = window.inventoryCompactMode;
      colorsHtml += `
        <div class="shop-item ${active ? 'active' : 'owned'}" style="${compact ? 'width:110px; padding:6px; display:inline-block; vertical-align:top;' : ''}">
          <div class="shop-item-info" style="${compact ? 'display:flex; flex-direction:column; align-items:center; gap:4px;' : ''}">
            <div style="display:flex; ${compact ? 'flex-direction:column; align-items:center;' : 'align-items:center;'}">
              <div class="color-preview" style="background: ${color.color}; ${compact ? 'margin-bottom:4px;' : ''}"></div>
              <strong style="${compact ? 'font-size:12px;' : ''}">${color.name}</strong>
              ${!active && !compact ? `<span style=\"margin-left:8px; color:#4CAF50; font-size:12px;\">✓ Gekauft</span>` : ''}
            </div>
            <div style="display:flex; gap:4px; ${compact ? 'flex-wrap:wrap; justify-content:center;' : ''}">
              ${active 
                ? `<div class=\"shop-item-active-badge\" style=\"${compact ? 'position:static; font-size:11px; padding:2px 4px;' : ''}\">⭐ Aktiv</div>` 
                : `<button onclick=\"activateChatColor('${colorId}')\" style=\"padding:${compact ? '3px 6px' : '5px 10px'}; font-size:${compact ? '11px' : '12px'};\">Aktivieren</button>`}
              <button onclick="toggleInventoryFavorite('${favKey}')" title="Favorit" style="padding:${compact ? '3px 6px' : '5px 10px'}; font-size:${compact ? '11px' : '12px'}; background:${isFav ? '#ffca28' : '#6c757d'};">★</button>
            </div>
          </div>
        </div>
      `;
    });
    console.log(`✅ Farben: ${matchedCount} von ${userInventory.chatColorsOwned.length} angezeigt`);
    if (colorsHtml === "" && (searchTerm || favsOnly)) {
      colorsHtml = "<p style='opacity:0.6;'>🔍 Keine Farben gefunden</p>";
    }
  }
  const colorsEl = document.getElementById("inventoryChatColors");
  if (colorsEl) colorsEl.innerHTML = colorsHtml;

  // Themes
  let themesHtml = "";
  if (userInventory.themesOwned.length === 0) {
    themesHtml = "<p style='opacity:0.6;'>Noch keine Themes gekauft</p>";
  } else {
    let matchedCount = 0;
    userInventory.themesOwned.forEach(themeId => {
      const theme = WEBSITE_THEMES.find(t => t.id === themeId);
      if (!theme) return;
      const active = userInventory.websiteTheme === themeId;
      const favKey = `theme:${theme.id}`;
      const isFav = inventoryFavorites.has(favKey);
      
      const passedFavFilter = !favsOnly || isFav;
      const passedSearchFilter = !searchTerm || theme.name.toLowerCase().includes(searchTerm);
      console.log(`🌈 ${theme.name}: favFilter=${passedFavFilter}, searchFilter=${passedSearchFilter}`);
      
      if (favsOnly && !isFav) return;
      if (searchTerm && !theme.name.toLowerCase().includes(searchTerm)) return;
      
      matchedCount++;
      const compact = window.inventoryCompactMode;
      themesHtml += `
        <div class="shop-item ${active ? 'active' : 'owned'}" style="${compact ? 'width:150px; padding:6px; display:inline-block; vertical-align:top;' : ''}">
          <div class="shop-item-info" style="${compact ? 'display:flex; flex-direction:column; align-items:center; gap:4px;' : ''}">
            <div style="display:flex; ${compact ? 'flex-direction:column; align-items:center;' : 'align-items:center;'}">
              <div class="theme-preview" style="background: ${theme.preview}; ${theme.id === 'numbers123' ? 'position: relative; display:flex; align-items:center; justify-content:center; font-family: Courier New, monospace; font-size: 12px; font-weight:bold; color:#00ff41; text-shadow:0 0 5px #00ff41;' : ''}; ${compact ? 'margin-bottom:4px; width:60px; height:40px;' : ''}">
                ${theme.id === 'numbers123' ? '123' : ''}
              </div>
              <strong style="${compact ? 'font-size:12px;' : ''}">${theme.name}</strong>
            </div>
            <div style="display:flex; gap:4px; ${compact ? 'flex-wrap:wrap; justify-content:center;' : ''}">
              ${active 
                ? `<div class=\"shop-item-active-badge\" style=\"${compact ? 'position:static; font-size:11px; padding:2px 4px;' : ''}\">⭐ Aktiv</div>` 
                : `<button onclick=\"buyShopItem('websiteTheme','${themeId}')\" style=\"padding:${compact ? '3px 6px' : '5px 10px'}; font-size:${compact ? '11px' : '12px'};\">Aktivieren</button>`}
              <button onclick="toggleInventoryFavorite('${favKey}')" title="Favorit" style="padding:${compact ? '3px 6px' : '5px 10px'}; font-size:${compact ? '11px' : '12px'}; background:${isFav ? '#ffca28' : '#6c757d'};">★</button>
            </div>
          </div>
        </div>
      `;
    });
    console.log(`✅ Themes: ${matchedCount} von ${userInventory.themesOwned.length} angezeigt`);
    if (themesHtml === "" && (searchTerm || favsOnly)) {
      themesHtml = "<p style='opacity:0.6;'>🔍 Keine Themes gefunden</p>";
    }
  }
  const themesEl = document.getElementById("inventoryThemes");
  if (themesEl) themesEl.innerHTML = themesHtml;

  // Badges
  let badgesHtml = "";
  if (userInventory.badges.length === 0) {
    badgesHtml = "<p style='opacity:0.6;'>Noch keine Badges gewonnen</p>";
  } else {
    let matchedCount = 0;
    userInventory.badges.forEach(badge => {
      const active = userInventory.activeBadge === badge.id;
      const favKey = `badge:${badge.id}`;
      const isFav = inventoryFavorites.has(favKey);
      
      const passedFavFilter = !favsOnly || isFav;
      const passedSearchFilter = !searchTerm || badge.name.toLowerCase().includes(searchTerm);
      console.log(`🏅 ${badge.name}: favFilter=${passedFavFilter}, searchFilter=${passedSearchFilter}`);
      
      if (favsOnly && !isFav) return;
      if (searchTerm && !badge.name.toLowerCase().includes(searchTerm)) return;
      
      matchedCount++;
      const compact = window.inventoryCompactMode;
      badgesHtml += `
        <div class="shop-item ${active ? 'active' : 'owned'}" style="${compact ? 'width:120px; padding:6px; display:inline-block; vertical-align:top;' : ''}">
          <div class="shop-item-info" style="${compact ? 'display:flex; flex-direction:column; align-items:center; gap:4px;' : ''}">
            <strong style="${compact ? 'font-size:12px;' : ''}">${badge.icon} ${badge.name}</strong>
            <div style="display:flex; gap:4px; ${compact ? 'flex-wrap:wrap; justify-content:center;' : ''}">
              ${active 
                ? `<div class='shop-item-active-badge' style='${compact ? 'position:static; font-size:11px; padding:2px 4px;' : ''}'>⭐ Aktiv</div>` 
                : `<button onclick='activateBadge("${badge.id}")' style='padding:${compact ? '3px 6px' : '5px 10px'}; font-size:${compact ? '11px' : '12px'};'>Aktivieren</button>`}
              <button onclick="toggleInventoryFavorite('${favKey}')" title="Favorit" style="padding:${compact ? '3px 6px' : '5px 10px'}; font-size:${compact ? '11px' : '12px'}; background:${isFav ? '#ffca28' : '#6c757d'};">★</button>
            </div>
          </div>
        </div>
      `;
    });
    console.log(`✅ Badges: ${matchedCount} von ${userInventory.badges.length} angezeigt`);
    if (badgesHtml === "" && (searchTerm || favsOnly)) {
      badgesHtml = "<p style='opacity:0.6;'>🔍 Keine Badges gefunden</p>";
    }
  }
  const badgesEl = document.getElementById("inventoryBadges");
  if (badgesEl) badgesEl.innerHTML = badgesHtml;

  // Musik Inventar
  loadMusicInventory();
  
  // Schriftarten Inventar
  loadFontsInventory();

  // Aktualisiere Favoriten-Styling nach Render
  updateInventoryFavoriteStyles();
  
  // GIF-Feature Shop Item anzeigen/verstecken
  const gifShop = document.getElementById("gifFeatureShop");
  const gifButton = document.getElementById("gifButton");
  
  if (userInventory.gifUnlocked) {
    if (gifShop) gifShop.innerHTML = '<p style="color:#28a745;">✅ GIF-Feature freigeschaltet!</p>';
    if (gifButton) gifButton.style.display = 'block';
  } else {
    if (gifButton) gifButton.style.display = 'none';
  }
}

// Hilfsfunktion: Styling der Favoriten-Buttons aktualisieren
function updateInventoryFavoriteStyles() {
  try {
    const favSet = window.inventoryFavorites || new Set();
    document.querySelectorAll('#inventar [data-fav-btn]')?.forEach(btn => {
      const onclickAttr = btn.getAttribute('onclick') || '';
      const match = onclickAttr.match(/toggleInventoryFavorite\('(.*?)'\)/);
      if (!match) return;
      const key = match[1];
      const isFav = favSet.has(key);
      btn.style.background = isFav ? '#ffca28' : '#6c757d';
      btn.style.color = isFav ? '#000' : '#fff';
      btn.setAttribute('aria-pressed', isFav ? 'true' : 'false');
    });
  } catch(e) {
    console.warn('updateInventoryFavoriteStyles Fehler:', e);
  }
}

// Kategorie wechseln
window.setInventoryCategory = function(cat) {
  window.inventoryCategory = cat;
  const tabs = document.querySelectorAll('.inv-tab');
  tabs.forEach(btn => {
    const isActive = btn.getAttribute('data-cat') === cat;
    btn.style.background = isActive ? '#007bff' : '#6c757d';
    btn.style.color = '#fff';
  });
  const cards = document.querySelectorAll('#inventoryGrid .inv-cat');
  cards.forEach(card => {
    if (cat === 'all') { card.style.display = ''; }
    else { card.style.display = card.getAttribute('data-cat') === cat ? '' : 'none'; }
  });
  displayInventory();
};

// Kompakt-Toggle
window.toggleInventoryCompact = function() {
  window.inventoryCompactMode = document.getElementById('inventoryCompactToggle')?.checked || false;
  displayInventory();
};

// Favorit toggeln
window.toggleInventoryFavorite = function(key) {
  if (!window.inventoryFavorites) window.inventoryFavorites = new Set();
  const had = window.inventoryFavorites.has(key);
  if (had) {
    window.inventoryFavorites.delete(key);
    console.log('★ Entfernt aus Favoriten:', key);
  } else {
    window.inventoryFavorites.add(key);
    console.log('★ Hinzugefügt zu Favoriten:', key);
  }
  try { localStorage.setItem('inventoryFavorites', JSON.stringify(Array.from(window.inventoryFavorites))); } catch(e){ console.warn('Favoriten speichern fehlgeschlagen', e); }
  displayInventory();
  // Sicherheits-Netz falls Re-Render fehlschlägt
  updateInventoryFavoriteStyles();
};

// Musik Inventar laden und anzeigen
async function loadMusicInventory() {
  if (!currentUser) return;
  const musicEl = document.getElementById('inventoryMusic');
  if (!musicEl) return;
  
  try {
    const musicSnap = await getDocs(collection(db, 'inventory', currentUser.uid, 'music'));
    
    const MUSIC_NAMES = {
      standard: 'Standard (Keine Musik)',
      lofi_beats: 'Lofi Beats',
      jazz_cafe: 'Jazz Café',
      synthwave: 'Synthwave',
      chill_hop: 'Chill Hop',
      piano_classics: 'Piano Classics',
      electronic_dreams: 'Electronic Dreams',
      ambient_waves: 'Ambient Waves',
      house_vibes: 'House Vibes'
    };
    
    const equippedMusic = localStorage.getItem('equippedMusic') || 'standard';
    
    let html = '';
    
    // Immer Standard-Option anzeigen
    const isStandardEquipped = equippedMusic === 'standard';
    html += `
      <div class="shop-item ${isStandardEquipped ? 'active' : 'owned'}">
        <div class="shop-item-info">
          <strong>🔇 Standard (Keine Musik)</strong>
          <div style="margin-top:8px;">
            ${isStandardEquipped 
              ? '<div class="shop-item-active-badge">⭐ Aktiv</div>' 
              : `<button onclick="equipMusic('standard')" style="padding:5px 10px; font-size:12px;">Ausrüsten</button>`}
          </div>
        </div>
      </div>
    `;
    
    // Gekaufte Musik anzeigen
    musicSnap.forEach(doc => {
      const musicId = doc.id;
      const name = MUSIC_NAMES[musicId] || musicId;
      const isEquipped = equippedMusic === musicId;
      
      html += `
        <div class="shop-item ${isEquipped ? 'active' : 'owned'}">
          <div class="shop-item-info">
            <strong>🎵 ${name}</strong>
            <div style="margin-top:8px;">
              ${isEquipped 
                ? '<div class="shop-item-active-badge">⭐ Aktiv</div>' 
                : `<button onclick="equipMusic('${musicId}')" style="padding:5px 10px; font-size:12px;">Ausrüsten</button>`}
            </div>
          </div>
        </div>
      `;
    });
    musicEl.innerHTML = html;
  } catch (e) {
    console.error('Fehler beim Laden des Musik-Inventars:', e);
    musicEl.innerHTML = "<p style='color:#e74c3c;'>Fehler beim Laden</p>";
  }
}

// Schriftarten Inventar laden und anzeigen
async function loadFontsInventory() {
  if (!currentUser) return;
  const fontsEl = document.getElementById('inventoryFonts');
  if (!fontsEl) return;
  
  try {
    const fontsSnap = await getDocs(collection(db, 'inventory', currentUser.uid, 'fonts'));
    
    const FONT_NAMES = {
      standard: { name: 'Standard', css: '' },
      modern_sans: { name: 'Modern Sans', css: 'font-family: "Segoe UI", sans-serif; letter-spacing: 0.5px;' },
      classic_serif: { name: 'Classic Serif', css: 'font-family: Georgia, serif; letter-spacing: 0.3px;' },
      monospace_code: { name: 'Monospace Code', css: 'font-family: "Courier New", monospace; letter-spacing: 1px;' },
      elegant_script: { name: 'Elegant Script', css: 'font-family: "Trebuchet MS", cursive; font-style: italic;' },
      bold_impact: { name: 'Bold Impact', css: 'font-family: Impact, sans-serif; font-weight: bold; letter-spacing: 1px;' },
      playful_comic: { name: 'Playful Comic', css: 'font-family: "Comic Sans MS", cursive; letter-spacing: 0.5px;' },
      retro_typewriter: { name: 'Retro Typewriter', css: 'font-family: "Courier New", monospace; font-weight: bold;' },
      sleek_future: { name: 'Sleek Future', css: 'font-family: "Arial Black", sans-serif; letter-spacing: 2px;' }
    };
    
    const equippedFont = localStorage.getItem('equippedFont') || 'standard';
    
    let html = '';
    
    // Immer Standard-Option anzeigen
    const isStandardEquipped = equippedFont === 'standard';
    html += `
      <div class="shop-item ${isStandardEquipped ? 'active' : 'owned'}">
        <div class="shop-item-info">
          <div style="font-size:18px; margin-bottom:8px;">🖋️ Standard</div>
          <div style="margin-top:8px;">
            ${isStandardEquipped 
              ? '<div class="shop-item-active-badge">⭐ Aktiv</div>' 
              : `<button onclick="equipFont('standard')" style="padding:5px 10px; font-size:12px;">Ausrüsten</button>`}
          </div>
        </div>
      </div>
    `;
    
    // Gekaufte Schriftarten anzeigen
    fontsSnap.forEach(doc => {
      const fontId = doc.id;
      const fontData = FONT_NAMES[fontId] || { name: fontId, css: '' };
      const isEquipped = equippedFont === fontId;
      
      html += `
        <div class="shop-item ${isEquipped ? 'active' : 'owned'}">
          <div class="shop-item-info">
            <div style="${fontData.css} font-size:18px; margin-bottom:8px;">🖋️ ${fontData.name}</div>
            <div style="margin-top:8px;">
              ${isEquipped 
                ? '<div class="shop-item-active-badge">⭐ Aktiv</div>' 
                : `<button onclick="equipFont('${fontId}')" style="padding:5px 10px; font-size:12px;">Ausrüsten</button>`}
            </div>
          </div>
        </div>
      `;
    });
    fontsEl.innerHTML = html;
  } catch (e) {
    console.error('Fehler beim Laden des Schriftarten-Inventars:', e);
    fontsEl.innerHTML = "<p style='color:#e74c3c;'>Fehler beim Laden</p>";
  }
}

// Badge aktivieren
window.activateBadge = async function(badgeId) {
  if (!currentUser) return;
  userInventory.activeBadge = badgeId;
  await saveInventory();
  displayInventory();
  showNotification("Badge aktiviert", "Dein Badge ist jetzt aktiv!");
};

// Musik ausrüsten und in Dauerschleife abspielen
window.equipMusic = function(musicId) {
  localStorage.setItem('equippedMusic', musicId);
  
  if (musicId === 'standard') {
    // Musik stoppen
    if (currentMusicContext) {
      try {
        currentMusicContext.close();
        currentMusicContext = null;
        globalMasterGain = null;
      } catch(e) {}
    }
    displayInventory();
    showNotification("Musik deaktiviert 🔇", "Die Hintergrundmusik wurde ausgeschaltet.");
  } else {
    playBackgroundMusicLoop(musicId);
    displayInventory();
    showNotification("Musik aktiviert! 🎵", "Die Musik läuft jetzt im Hintergrund.");
  }
};

// Schriftart ausrüsten
window.equipFont = function(fontId) {
  localStorage.setItem('equippedFont', fontId);
  applyFontToBody(fontId);
  displayInventory();
  showNotification("Schriftart aktiviert! 🖋️", "Die Schriftart wurde angewendet.");
};

// Schriftart auf body anwenden
function applyFontToBody(fontId) {
  const FONT_STYLES = {
    standard: '',
    modern_sans: 'font-family: "Segoe UI", sans-serif; letter-spacing: 0.5px;',
    classic_serif: 'font-family: Georgia, serif; letter-spacing: 0.3px;',
    monospace_code: 'font-family: "Courier New", monospace; letter-spacing: 1px;',
    elegant_script: 'font-family: "Trebuchet MS", cursive; font-style: italic;',
    bold_impact: 'font-family: Impact, sans-serif; font-weight: bold; letter-spacing: 1px;',
    playful_comic: 'font-family: "Comic Sans MS", cursive; letter-spacing: 0.5px;',
    retro_typewriter: 'font-family: "Courier New", monospace; font-weight: bold;',
    sleek_future: 'font-family: "Arial Black", sans-serif; letter-spacing: 2px;'
  };
  
  const style = FONT_STYLES[fontId];
  if (style !== undefined) {
    if (style === '') {
      // Standard: Style entfernen
      document.body.removeAttribute('style');
    } else {
      document.body.setAttribute('style', style);
    }
  }
}

// Hintergrundmusik in Dauerschleife abspielen
let currentMusicContext = null;
let currentMusicSource = null;

function playBackgroundMusicLoop(musicId) {
  // Stop previous music
  if (currentMusicContext) {
    try {
      currentMusicContext.close();
    } catch(e) {}
  }
  
  const MUSIC_PATTERNS = {
    lofi_beats: [
      // Part 1 - Main theme (30s)
      { f: 440, d: 500 }, { f: 554, d: 500 }, { f: 659, d: 1000 },
      { f: 587, d: 500 }, { f: 523, d: 500 }, { f: 440, d: 1000 },
      { f: 494, d: 500 }, { f: 523, d: 500 }, { f: 587, d: 1500 },
      { f: 523, d: 500 }, { f: 494, d: 500 }, { f: 440, d: 1000 },
      { f: 392, d: 500 }, { f: 440, d: 500 }, { f: 494, d: 1500 },
      { f: 440, d: 500 }, { f: 392, d: 500 }, { f: 349, d: 2000 },
      // Part 2 - Variation (30s)
      { f: 523, d: 500 }, { f: 587, d: 500 }, { f: 659, d: 1000 },
      { f: 698, d: 500 }, { f: 659, d: 500 }, { f: 587, d: 1000 },
      { f: 523, d: 500 }, { f: 494, d: 500 }, { f: 523, d: 1500 },
      { f: 494, d: 500 }, { f: 440, d: 500 }, { f: 392, d: 1000 },
      { f: 440, d: 500 }, { f: 494, d: 500 }, { f: 523, d: 1500 },
      { f: 494, d: 500 }, { f: 440, d: 500 }, { f: 392, d: 2000 },
      // Part 3 - Bridge (30s)
      { f: 659, d: 500 }, { f: 698, d: 500 }, { f: 783, d: 1000 },
      { f: 698, d: 500 }, { f: 659, d: 500 }, { f: 587, d: 1000 },
      { f: 523, d: 500 }, { f: 587, d: 500 }, { f: 659, d: 1500 },
      { f: 587, d: 500 }, { f: 523, d: 500 }, { f: 494, d: 1000 },
      { f: 440, d: 500 }, { f: 494, d: 500 }, { f: 523, d: 1500 },
      { f: 494, d: 500 }, { f: 440, d: 500 }, { f: 392, d: 2000 },
      // Part 4 - Finale (30s)
      { f: 440, d: 500 }, { f: 523, d: 500 }, { f: 587, d: 1000 },
      { f: 659, d: 1000 }, { f: 587, d: 500 }, { f: 523, d: 500 },
      { f: 494, d: 500 }, { f: 523, d: 500 }, { f: 587, d: 1500 },
      { f: 523, d: 500 }, { f: 494, d: 500 }, { f: 440, d: 1000 },
      { f: 392, d: 500 }, { f: 440, d: 500 }, { f: 494, d: 2000 },
      { f: 440, d: 1000 }, { f: 392, d: 3000 }
    ],
    jazz_cafe: [
      // Jazz progression mit Swing (2min)
      { f: 523, d: 400 }, { f: 587, d: 400 }, { f: 659, d: 800 },
      { f: 698, d: 400 }, { f: 783, d: 400 }, { f: 698, d: 400 },
      { f: 659, d: 800 }, { f: 587, d: 400 }, { f: 523, d: 1200 },
      { f: 587, d: 400 }, { f: 659, d: 400 }, { f: 698, d: 800 },
      { f: 783, d: 400 }, { f: 880, d: 800 }, { f: 783, d: 400 },
      { f: 698, d: 1200 }, { f: 659, d: 400 }, { f: 587, d: 1600 },
      { f: 493, d: 400 }, { f: 523, d: 400 }, { f: 587, d: 800 },
      { f: 659, d: 400 }, { f: 698, d: 400 }, { f: 659, d: 400 },
      { f: 587, d: 800 }, { f: 523, d: 400 }, { f: 493, d: 1200 },
      { f: 440, d: 400 }, { f: 493, d: 400 }, { f: 523, d: 800 },
      { f: 587, d: 400 }, { f: 659, d: 800 }, { f: 587, d: 400 },
      { f: 523, d: 1200 }, { f: 493, d: 400 }, { f: 440, d: 1600 },
      { f: 659, d: 400 }, { f: 698, d: 400 }, { f: 783, d: 800 },
      { f: 880, d: 400 }, { f: 987, d: 400 }, { f: 880, d: 400 },
      { f: 783, d: 800 }, { f: 698, d: 400 }, { f: 659, d: 1200 },
      { f: 698, d: 400 }, { f: 783, d: 400 }, { f: 880, d: 800 },
      { f: 783, d: 400 }, { f: 698, d: 800 }, { f: 659, d: 400 },
      { f: 587, d: 1200 }, { f: 523, d: 2000 }
    ],
    synthwave: [
      // Synthwave mit Bass und Lead (2min)
      { f: 220, d: 600 }, { f: 220, d: 600 }, { f: 330, d: 600 },
      { f: 440, d: 600 }, { f: 554, d: 1200 }, { f: 440, d: 600 },
      { f: 330, d: 600 }, { f: 220, d: 1200 }, { f: 247, d: 600 },
      { f: 330, d: 600 }, { f: 392, d: 600 }, { f: 494, d: 1200 },
      { f: 392, d: 600 }, { f: 330, d: 600 }, { f: 247, d: 1200 },
      { f: 220, d: 600 }, { f: 330, d: 600 }, { f: 440, d: 600 },
      { f: 554, d: 600 }, { f: 659, d: 1200 }, { f: 554, d: 600 },
      { f: 440, d: 600 }, { f: 330, d: 1200 }, { f: 294, d: 600 },
      { f: 392, d: 600 }, { f: 494, d: 600 }, { f: 587, d: 1200 },
      { f: 494, d: 600 }, { f: 392, d: 600 }, { f: 294, d: 1200 },
      { f: 330, d: 600 }, { f: 440, d: 600 }, { f: 554, d: 600 },
      { f: 659, d: 600 }, { f: 880, d: 1200 }, { f: 659, d: 600 },
      { f: 554, d: 600 }, { f: 440, d: 1200 }, { f: 392, d: 600 },
      { f: 494, d: 600 }, { f: 587, d: 600 }, { f: 698, d: 1200 },
      { f: 587, d: 600 }, { f: 494, d: 600 }, { f: 392, d: 1200 },
      { f: 330, d: 600 }, { f: 440, d: 600 }, { f: 554, d: 2400 }
    ],
    chill_hop: [
      // Chill Hop Beat (2min)
      { f: 392, d: 500 }, { f: 440, d: 500 }, { f: 494, d: 1000 },
      { f: 523, d: 500 }, { f: 587, d: 1000 }, { f: 523, d: 500 },
      { f: 494, d: 1000 }, { f: 440, d: 500 }, { f: 392, d: 1500 },
      { f: 349, d: 500 }, { f: 392, d: 500 }, { f: 440, d: 1000 },
      { f: 494, d: 1000 }, { f: 440, d: 500 }, { f: 392, d: 1500 },
      { f: 440, d: 500 }, { f: 494, d: 500 }, { f: 523, d: 1000 },
      { f: 587, d: 500 }, { f: 659, d: 1000 }, { f: 587, d: 500 },
      { f: 523, d: 1000 }, { f: 494, d: 500 }, { f: 440, d: 1500 },
      { f: 392, d: 500 }, { f: 440, d: 500 }, { f: 494, d: 1000 },
      { f: 523, d: 500 }, { f: 587, d: 1000 }, { f: 523, d: 500 },
      { f: 494, d: 1000 }, { f: 440, d: 500 }, { f: 392, d: 1500 },
      { f: 523, d: 500 }, { f: 587, d: 500 }, { f: 659, d: 1000 },
      { f: 698, d: 500 }, { f: 783, d: 1000 }, { f: 698, d: 500 },
      { f: 659, d: 1000 }, { f: 587, d: 500 }, { f: 523, d: 1500 },
      { f: 494, d: 500 }, { f: 523, d: 500 }, { f: 587, d: 1000 },
      { f: 523, d: 500 }, { f: 494, d: 1000 }, { f: 440, d: 500 },
      { f: 392, d: 2000 }
    ],
    piano_classics: [
      // Klassische Piano Melodie (2min)
      { f: 523, d: 600 }, { f: 587, d: 600 }, { f: 659, d: 1200 },
      { f: 698, d: 600 }, { f: 783, d: 600 }, { f: 880, d: 1200 },
      { f: 987, d: 600 }, { f: 880, d: 600 }, { f: 783, d: 1200 },
      { f: 698, d: 600 }, { f: 659, d: 600 }, { f: 587, d: 1800 },
      { f: 659, d: 600 }, { f: 698, d: 600 }, { f: 783, d: 1200 },
      { f: 880, d: 600 }, { f: 987, d: 600 }, { f: 1046, d: 1200 },
      { f: 987, d: 600 }, { f: 880, d: 600 }, { f: 783, d: 1800 },
      { f: 698, d: 600 }, { f: 659, d: 600 }, { f: 587, d: 1200 },
      { f: 523, d: 600 }, { f: 587, d: 600 }, { f: 659, d: 1200 },
      { f: 698, d: 600 }, { f: 783, d: 600 }, { f: 698, d: 1200 },
      { f: 659, d: 600 }, { f: 587, d: 600 }, { f: 523, d: 1800 },
      { f: 587, d: 600 }, { f: 659, d: 600 }, { f: 698, d: 1200 },
      { f: 783, d: 600 }, { f: 880, d: 600 }, { f: 987, d: 1200 },
      { f: 1046, d: 600 }, { f: 987, d: 600 }, { f: 880, d: 1800 },
      { f: 783, d: 600 }, { f: 698, d: 600 }, { f: 659, d: 1200 },
      { f: 587, d: 600 }, { f: 523, d: 2400 }
    ],
    electronic_dreams: [
      // Electronic schnellere Sequenz (2min)
      { f: 440, d: 300 }, { f: 554, d: 300 }, { f: 659, d: 600 },
      { f: 784, d: 300 }, { f: 880, d: 300 }, { f: 1046, d: 600 },
      { f: 880, d: 300 }, { f: 784, d: 300 }, { f: 659, d: 900 },
      { f: 554, d: 300 }, { f: 659, d: 300 }, { f: 784, d: 600 },
      { f: 880, d: 300 }, { f: 1046, d: 600 }, { f: 880, d: 300 },
      { f: 784, d: 900 }, { f: 659, d: 300 }, { f: 554, d: 1200 },
      { f: 392, d: 300 }, { f: 494, d: 300 }, { f: 587, d: 600 },
      { f: 698, d: 300 }, { f: 784, d: 300 }, { f: 880, d: 600 },
      { f: 784, d: 300 }, { f: 698, d: 300 }, { f: 587, d: 900 },
      { f: 494, d: 300 }, { f: 587, d: 300 }, { f: 698, d: 600 },
      { f: 784, d: 300 }, { f: 880, d: 600 }, { f: 784, d: 300 },
      { f: 698, d: 900 }, { f: 587, d: 300 }, { f: 494, d: 1200 },
      { f: 554, d: 300 }, { f: 659, d: 300 }, { f: 784, d: 600 },
      { f: 880, d: 300 }, { f: 1046, d: 300 }, { f: 1174, d: 600 },
      { f: 1046, d: 300 }, { f: 880, d: 300 }, { f: 784, d: 900 },
      { f: 659, d: 300 }, { f: 784, d: 300 }, { f: 880, d: 600 },
      { f: 1046, d: 300 }, { f: 1174, d: 600 }, { f: 1046, d: 300 },
      { f: 880, d: 900 }, { f: 784, d: 300 }, { f: 659, d: 1200 },
      { f: 554, d: 300 }, { f: 659, d: 300 }, { f: 784, d: 2400 }
    ],
    ambient_waves: [
      // Langsame Ambient Wellen (2min)
      { f: 261, d: 800 }, { f: 293, d: 800 }, { f: 329, d: 1600 },
      { f: 349, d: 800 }, { f: 392, d: 800 }, { f: 440, d: 1600 },
      { f: 392, d: 800 }, { f: 349, d: 800 }, { f: 329, d: 2400 },
      { f: 293, d: 800 }, { f: 329, d: 800 }, { f: 349, d: 1600 },
      { f: 392, d: 800 }, { f: 440, d: 1600 }, { f: 392, d: 800 },
      { f: 349, d: 2400 }, { f: 329, d: 800 }, { f: 293, d: 1600 },
      { f: 329, d: 800 }, { f: 349, d: 800 }, { f: 392, d: 1600 },
      { f: 440, d: 800 }, { f: 493, d: 800 }, { f: 523, d: 1600 },
      { f: 493, d: 800 }, { f: 440, d: 800 }, { f: 392, d: 2400 },
      { f: 349, d: 800 }, { f: 392, d: 800 }, { f: 440, d: 1600 },
      { f: 493, d: 800 }, { f: 523, d: 1600 }, { f: 493, d: 800 },
      { f: 440, d: 2400 }, { f: 392, d: 800 }, { f: 349, d: 1600 },
      { f: 329, d: 800 }, { f: 293, d: 800 }, { f: 261, d: 3200 }
    ],
    house_vibes: [
      // House Beat mit 4/4 (2min)
      { f: 392, d: 250 }, { f: 392, d: 250 }, { f: 440, d: 250 },
      { f: 440, d: 250 }, { f: 494, d: 500 }, { f: 523, d: 250 },
      { f: 587, d: 250 }, { f: 659, d: 500 }, { f: 587, d: 250 },
      { f: 523, d: 250 }, { f: 494, d: 750 }, { f: 440, d: 250 },
      { f: 392, d: 250 }, { f: 440, d: 250 }, { f: 494, d: 500 },
      { f: 523, d: 250 }, { f: 587, d: 250 }, { f: 659, d: 500 },
      { f: 698, d: 250 }, { f: 659, d: 250 }, { f: 587, d: 750 },
      { f: 523, d: 250 }, { f: 494, d: 250 }, { f: 440, d: 250 },
      { f: 392, d: 500 }, { f: 440, d: 250 }, { f: 494, d: 250 },
      { f: 523, d: 500 }, { f: 587, d: 250 }, { f: 659, d: 250 },
      { f: 698, d: 500 }, { f: 783, d: 250 }, { f: 698, d: 250 },
      { f: 659, d: 750 }, { f: 587, d: 250 }, { f: 523, d: 250 },
      { f: 494, d: 250 }, { f: 440, d: 500 }, { f: 392, d: 250 },
      { f: 440, d: 250 }, { f: 494, d: 500 }, { f: 523, d: 250 },
      { f: 587, d: 250 }, { f: 659, d: 500 }, { f: 587, d: 250 },
      { f: 523, d: 250 }, { f: 494, d: 750 }, { f: 440, d: 250 },
      { f: 392, d: 250 }, { f: 440, d: 250 }, { f: 494, d: 500 },
      { f: 523, d: 250 }, { f: 587, d: 250 }, { f: 659, d: 500 },
      { f: 698, d: 250 }, { f: 783, d: 250 }, { f: 880, d: 750 },
      { f: 783, d: 250 }, { f: 698, d: 250 }, { f: 659, d: 250 },
      { f: 587, d: 500 }, { f: 523, d: 250 }, { f: 494, d: 250 },
      { f: 440, d: 500 }, { f: 392, d: 1500 }
    ]
  };
  
  const pattern = MUSIC_PATTERNS[musicId];
  if (!pattern) return;
  
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  currentMusicContext = ctx;
  
  const masterGain = ctx.createGain();
  masterGain.gain.value = musicVolume; // Verwende gespeicherte Lautstärke
  globalMasterGain = masterGain; // Global speichern für Lautstärkeregler
  masterGain.connect(ctx.destination);
  
  function playLoop() {
    if (!currentMusicContext || currentMusicContext !== ctx) return;
    
    let time = ctx.currentTime;
    pattern.forEach(note => {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(note.f, time);
      
      const noteGain = ctx.createGain();
      noteGain.gain.setValueAtTime(0, time);
      noteGain.gain.linearRampToValueAtTime(0.3, time + 0.02);
      noteGain.gain.linearRampToValueAtTime(0, time + note.d/1000);
      
      osc.connect(noteGain);
      noteGain.connect(masterGain);
      
      osc.start(time);
      osc.stop(time + note.d/1000);
      
      time += note.d/1000;
    });
    
    const loopDuration = pattern.reduce((sum, n) => sum + n.d, 0);
    setTimeout(playLoop, loopDuration);
  }
  
  playLoop();
}

// Beim Seitenstart ausgerüstete Items laden
window.addEventListener('DOMContentLoaded', function() {
  const equippedMusic = localStorage.getItem('equippedMusic');
  if (equippedMusic && equippedMusic !== 'standard') {
    setTimeout(() => playBackgroundMusicLoop(equippedMusic), 500);
  }
  
  const equippedFont = localStorage.getItem('equippedFont');
  if (equippedFont && equippedFont !== 'standard') {
    applyFontToBody(equippedFont);
  }
});

// Stelle sicher, dass der Shop und Inventar direkt sichtbar sind, auch ohne Login
try { displayShop(); } catch (e) { console.warn("displayShop initial render fehlgeschlagen", e); }
try { displayInventory(); } catch (e) { console.warn("displayInventory initial render fehlgeschlagen", e); }

// Inventory: Programmatic event listeners for search, favorites-only, and compact mode
function setupInventoryListeners() {
  const searchInput = document.getElementById('inventorySearch');
  const favsOnlyCheckbox = document.getElementById('inventoryFavsOnly');
  const compactCheckbox = document.getElementById('inventoryCompact');

  if (searchInput && !searchInput.__inventoryBound) {
    searchInput.addEventListener('input', () => {
      try { displayInventory(); } catch (e) { console.warn('displayInventory on search input failed', e); }
    });
    searchInput.__inventoryBound = true;
  }

  if (favsOnlyCheckbox && !favsOnlyCheckbox.__inventoryBound) {
    favsOnlyCheckbox.addEventListener('change', () => {
      try { displayInventory(); } catch (e) { console.warn('displayInventory on favorites-only change failed', e); }
    });
    favsOnlyCheckbox.__inventoryBound = true;
  }

  if (compactCheckbox && !compactCheckbox.__inventoryBound) {
    compactCheckbox.addEventListener('change', () => {
      try { displayInventory(); } catch (e) { console.warn('displayInventory on compact change failed', e); }
    });
    compactCheckbox.__inventoryBound = true;
  }
}

// Bind immediately if DOM is ready, and on DOMContentLoaded as fallback
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupInventoryListeners);
} else {
  setupInventoryListeners();
}

// Ensure inventory sections are grouped into a single grid row
function ensureInventoryGridWrapper() {
  const inventarSection = document.getElementById('inventar');
  const colors = document.getElementById('inventoryChatColors');
  const themes = document.getElementById('inventoryThemes');
  const badges = document.getElementById('inventoryBadges');
  if (!inventarSection || !colors || !themes || !badges) return;

  // Prefer wrapping the card containers, not just inner content
  const colorsCard = colors.closest('.card') || colors;
  const themesCard = themes.closest('.card') || themes;
  const badgesCard = badges.closest('.card') || badges;

  // If already wrapped, skip
  let wrapper = document.getElementById('inventar-sections');
  if (!wrapper) {
    wrapper = document.createElement('div');
    wrapper.id = 'inventar-sections';
    // Insert wrapper at the end; controls will be above
    inventarSection.appendChild(wrapper);
    // Move cards into the wrapper
    wrapper.appendChild(colorsCard);
    wrapper.appendChild(themesCard);
    wrapper.appendChild(badgesCard);
  } else {
    // Ensure all three sections are inside the wrapper
    if (colorsCard.parentElement !== wrapper) wrapper.appendChild(colorsCard);
    if (themesCard.parentElement !== wrapper) wrapper.appendChild(themesCard);
    if (badgesCard.parentElement !== wrapper) wrapper.appendChild(badgesCard);
  }
}

// Move inventory controls above the sections
function ensureInventoryControlsAbove() {
  const inventarSection = document.getElementById('inventar');
  if (!inventarSection) return;

  const tabsContainer = document.getElementById('inventoryTabs'); // optional tabs block
  const searchInput = document.getElementById('inventorySearch');
  const favsOnlyCheckbox = document.getElementById('inventoryFavsOnly');
  const compactCheckbox = document.getElementById('inventoryCompact');
  const findLabelFor = (id) => document.querySelector(id ? `label[for="${id}"]` : null);
  const favsLabel = findLabelFor('inventoryFavsOnly');
  const compactLabel = findLabelFor('inventoryCompact');

  // If nothing found, skip
  if (!tabsContainer && !searchInput && !favsOnlyCheckbox && !compactCheckbox) return;

  let controlsBar = document.getElementById('inventar-controls');
  if (!controlsBar) {
    controlsBar = document.createElement('div');
    controlsBar.id = 'inventar-controls';
    // Insert at the top of the inventar section
    inventarSection.insertBefore(controlsBar, inventarSection.firstElementChild);
  }

  // Append tabs (if present)
  if (tabsContainer && tabsContainer.parentElement !== controlsBar) {
    controlsBar.appendChild(tabsContainer);
  }

  // Group inputs inline
  let inputsGroup = document.getElementById('inventar-inputs-group');
  if (!inputsGroup) {
    inputsGroup = document.createElement('div');
    inputsGroup.id = 'inventar-inputs-group';
    inputsGroup.style.display = 'flex';
    inputsGroup.style.flexWrap = 'wrap';
    inputsGroup.style.alignItems = 'center';
    inputsGroup.style.gap = '8px';
    inputsGroup.style.marginTop = '8px';
  }

  // Order: search | spacer | compact [label]
  if (searchInput && searchInput.parentElement !== inputsGroup) inputsGroup.appendChild(searchInput);
  // spacer to push checkboxes to the right
  let spacer = inputsGroup.querySelector('.spacer');
  if (!spacer) {
    spacer = document.createElement('div');
    spacer.className = 'spacer';
  }
  if (spacer.parentElement !== inputsGroup) inputsGroup.appendChild(spacer);
  
  // compact checkbox with label
  if (compactCheckbox) {
    // Ensure label exists; if not, create one
    let labelEl = compactLabel;
    if (!labelEl) {
      labelEl = document.createElement('label');
      labelEl.setAttribute('for', 'inventoryCompact');
      labelEl.textContent = 'Kompakt';
    }
    const compactWrap = document.createElement('div');
    compactWrap.style.display = 'inline-flex';
    compactWrap.style.alignItems = 'center';
    compactWrap.style.gap = '6px';
    compactWrap.appendChild(compactCheckbox);
    compactWrap.appendChild(labelEl);
    inputsGroup.appendChild(compactWrap);
  }
  // Do NOT move Favorites checkbox to the top bar. Keep the lower one.
  // If any Favorites control accidentally exists in the top controls, remove it.
  try {
    const topFavs = controlsBar.querySelector('#inventoryFavsOnly');
    if (topFavs) {
      const topFavsLabel = controlsBar.querySelector('label[for="inventoryFavsOnly"]');
      if (topFavsLabel) topFavsLabel.remove();
      // Move checkbox back to its original container if known, else remove duplicate
      const originalControls = inventarSection.querySelector('.inventory-controls');
      if (originalControls && !originalControls.querySelector('#inventoryFavsOnly')) {
        // Recreate the label if needed in original area
        const wrap = document.createElement('label');
        wrap.style.fontSize = '12px';
        wrap.style.display = 'flex';
        wrap.style.alignItems = 'center';
        wrap.style.gap = '4px';
        topFavs.remove();
        const favsCb = favsOnlyCheckbox || document.getElementById('inventoryFavsOnly');
        if (favsCb) {
          wrap.appendChild(favsCb);
          wrap.appendChild(document.createTextNode(' Favoriten'));
          originalControls.appendChild(wrap);
        }
      } else {
        topFavs.remove();
      }
    }
  } catch (e) {
    console.warn('Favoriten-Checkbox cleanup skipped:', e);
  }

  // Only add group if it has children
  if (inputsGroup.children.length && inputsGroup.parentElement !== controlsBar) {
    controlsBar.appendChild(inputsGroup);
  }
}

// Run wrapper setup on DOM ready and after initial inventory render
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', ensureInventoryGridWrapper);
  document.addEventListener('DOMContentLoaded', ensureInventoryControlsAbove);
} else {
  ensureInventoryGridWrapper();
  ensureInventoryControlsAbove();
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CHAT - verwende gekaufte Farbe

// Fallback-Profilbild (eingebettetes SVG)
function getDefaultProfilePic() {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
    <rect width="64" height="64" rx="32" fill="#666"/>
    <circle cx="32" cy="24" r="12" fill="#fff"/>
    <path d="M12 54c0-11 10-18 20-18s20 7 20 18" fill="#fff"/>
  </svg>`;
  return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
}

// Profilbild eines Users laden (mit Cache + Fallback)
const __profilePicCache = new Map();
async function getUserProfilePic(uid) {
  try {
    if (!uid) return getDefaultProfilePic();
    if (__profilePicCache.has(uid)) return __profilePicCache.get(uid);
    const u = await getDoc(doc(db, 'users', uid));
    const url = u.exists() ? (u.data().profilePic || getDefaultProfilePic()) : getDefaultProfilePic();
    __profilePicCache.set(uid, url);
    return url;
  } catch (e) {
    console.warn('Profilbild Fallback für', uid, e);
    return getDefaultProfilePic();
  }
}
/////////////////////////////////////////////////////////////////////////////

// Ersetze die loadChat-Funktion - füge Farbe ein:
function loadChatWithColor() {
  const qChat = query(collection(db, "chat"), orderBy("createdAt", "asc"));
  const msgBox = document.getElementById("chatMessages");

  onSnapshot(qChat, async snap => {
    try {
      let html = "";

      // Profilbilder und Badges laden – robust bei fehlender uid
      const promises = [];
      snap.forEach(docu => {
        const m = docu.data();
        if (!m.uid) {
          promises.push(Promise.resolve({ m, profilePic: getDefaultProfilePic(), badgeHtml: '' }));
        } else {
          promises.push(
            getDoc(doc(db, 'users', m.uid))
              .then(userDoc => {
                const userData = userDoc.exists() ? userDoc.data() : {};
                const profilePic = userData.profilePic || getDefaultProfilePic();
                const inventory = userData.inventory || {};
                const activeBadge = inventory.activeBadge;
                let badgeHtml = '';
                if (activeBadge && inventory.badges) {
                  const badge = inventory.badges.find(b => b.id === activeBadge);
                  if (badge) badgeHtml = `${badge.icon} ${badge.name}`;
                }
                return { m, profilePic, badgeHtml };
              })
              .catch(() => ({ m, profilePic: getDefaultProfilePic(), badgeHtml: '' }))
          );
        }
      });

      let messages = [];
      try {
        messages = await Promise.all(promises);
      } catch (e) {
        console.error('Chat-Rendering: Profil-Laden fehlgeschlagen, nutze Fallback.', e);
        messages = snap.docs.map(d => ({ m: d.data(), profilePic: getDefaultProfilePic(), badgeHtml: '' }));
      }

      messages.forEach(({ m, profilePic, badgeHtml }) => {
        let nameClass = "";
        let nameStyle = "";

        if (m.nameColor === "linear-gradient(90deg, red, orange, yellow, lime, cyan, blue, magenta)") {
          nameClass = "rainbow-text";
        } else if (m.nameColor === "#FFD700") {
          nameClass = "gold-text";
        } else if (m.nameColor === "#E0115F") {
          nameClass = "ruby-text";
        } else if (m.nameColor === "#50C878") {
          nameClass = "emerald-text";
        } else if (m.nameColor === "#B9F2FF") {
          nameClass = "diamond-text";
        } else if (m.nameColor) {
          nameStyle = `color: ${m.nameColor};`;
        }

        html += `
  <div class="message" style="display: flex; align-items: flex-start; gap: 10px;">
    <img src="${profilePic}" style="width:30px; height:30px; border-radius:50%; object-fit:cover; flex-shrink: 0; cursor:pointer;" onclick="${m.uid ? `openUserProfile('${m.uid}')` : ''}">
    <div style="flex: 1;">
      <strong class="${nameClass}" style="${nameStyle} cursor:pointer;" onclick="${m.uid ? `openUserProfile('${m.uid}')` : ''}">${m.nickname || "Unbekannt"}</strong>
      ${badgeHtml ? `<span style="margin-left:4px; font-size:14px;">${badgeHtml}</span>` : ''}
      <span style="float:right; font-size:12px; opacity:0.7;">
        ${m.createdAt?.toDate?.().toLocaleDateString("de-DE")} 
        ${m.createdAt?.toDate?.().toLocaleTimeString("de-DE", { hour: "2-digit", minute: "2-digit" })}
      </span>
      <br>
      ${m.text ? m.text : ''}
      ${m.gifUrl ? `
        <br>
        <img src="${m.gifUrl}" style="max-width:300px; max-height:300px; border-radius:8px; margin-top:8px;" onerror="this.style.display='none';">
        <div style="margin-top:4px; font-size:12px; opacity:0.8;">
          <a href="${m.gifUrl}" target="_blank" rel="noopener" style="color:#9ecbff; text-decoration:underline;">GIF öffnen</a>
        </div>
      ` : ''}
    </div>
  </div>
`;
      });

      if (!html) {
        msgBox.innerHTML = '<p style="opacity:0.7;">Noch keine Nachrichten</p>';
      } else {
        msgBox.innerHTML = html;
        msgBox.scrollTop = msgBox.scrollHeight;
      }
    } catch (err) {
      console.error('Chat-Rendering Fehler:', err);
      msgBox.innerHTML = '<p style="color:#e74c3c;">Fehler beim Laden des Chats</p>';
    }
  });
}

// Ersetze die alte loadChat() mit loadChatWithColor()
loadChatWithColor();

// Enter-Taste Handler für Chat
document.addEventListener('DOMContentLoaded', function() {
  const chatText = document.getElementById('chatText');
  if (chatText) {
    chatText.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  }
  
  // Sprache laden
  loadLanguage();
});

// Ersetze sendMessage - speichere Farbe
window.sendMessage = async function() {
  const text = document.getElementById("chatText").value.trim();
  const gifUrl = document.getElementById("gifUrl").value.trim();
  
  console.log("📤 SendMessage aufgerufen:", { text, gifUrl, gifUnlocked: userInventory.gifUnlocked });
  
  if (!text && !gifUrl) return showNotification("Bitte eine Nachricht eingeben.");
  if (!currentUser || !currentNickname) {
    showNotification("Bitte zuerst einloggen. Der Chat nutzt deinen Nickname.");
    return;
  }

  // GIF Cooldown Check (1 Stunde)
  if (gifUrl) {
    const now = Date.now();
    const lastGifTime = userInventory.lastGifSent || 0;
    const oneHour = 60 * 60 * 1000;
    const timeLeft = (lastGifTime + oneHour) - now;
    
    if (timeLeft > 0) {
      const minutesLeft = Math.ceil(timeLeft / 60000);
      showNotification(`⏰ Du kannst erst in ${minutesLeft} Minute(n) wieder ein GIF senden.`);
      return;
    }
  }

  // Hole gekaufte Farbe
  const colorItem = CHAT_COLORS.find(c => c.id === userInventory.chatNameColor);
  const nameColor = colorItem ? colorItem.color : null;
  
  console.log("Chat Color Debug:", {
    chatNameColor: userInventory.chatNameColor,
    colorItem: colorItem,
    nameColor: nameColor,
    gifUrl: gifUrl,
    gifUnlocked: userInventory.gifUnlocked
  });

  const messageData = {
    uid: currentUser.uid,
    nickname: currentNickname,
    text: text || "",
    nameColor: nameColor,  // Speichere Farbe
    createdAt: serverTimestamp()
  };

  // GIF URL hinzufügen wenn vorhanden und freigeschaltet
  if (gifUrl && userInventory.gifUnlocked) {
    messageData.gifUrl = gifUrl;
    console.log("✅ GIF wird zur Nachricht hinzugefügt:", gifUrl);
    
    // Update lastGifSent timestamp in Firebase
    const userDocRef = doc(db, 'users', currentUser.uid);
    await updateDoc(userDocRef, {
      'inventory.lastGifSent': Date.now()
    });
    userInventory.lastGifSent = Date.now();
  } else if (gifUrl && !userInventory.gifUnlocked) {
    console.warn("⚠️ GIF-URL vorhanden aber Feature nicht freigeschaltet!");
  }

  console.log("📨 Nachricht wird gesendet:", messageData);

  await addDoc(collection(db, "chat"), messageData);

  document.getElementById("chatText").value = "";
  document.getElementById("gifUrl").value = "";
  document.getElementById("gifUrl").style.display = "none";
  
  // Track Chat Message für Battle Pass
  await updateBPQuestProgress('chatMessages', 1);

  // Limit auf 100 Nachrichten prüfen
  await cleanupOldMessages();
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// SLOT MACHINE 🎰
/////////////////////////////////////////////////////////////////////////////

const SYMBOLS = ["🍒", "🍋", "🍉", "7️⃣"];
let slotReels = ["🍒", "🍋", "🍉", "7️⃣", "🍒", "🍋", "🍉", "7️⃣", "🍒"];
let isSlotSpinning = false;

// Audio Context für Sounds
let audioContext;

function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
}

// Sound: Spin
function playSpinSound() {
  initAudio();
  const now = audioContext.currentTime;
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  
  osc.connect(gain);
  gain.connect(audioContext.destination);
  
  osc.frequency.setValueAtTime(200, now);
  osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
  osc.type = "triangle";
  
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
  
  osc.start(now);
  osc.stop(now + 0.5);
}

// Sound: Gewinn
function playWinSound() {
  initAudio();
  const now = audioContext.currentTime;
  
  // Drei steigende Töne
  for (let i = 0; i < 3; i++) {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.frequency.value = 400 + i * 200;
    osc.type = "sine";
    
    gain.gain.setValueAtTime(0.1, now + i * 0.15);
    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
    
    osc.start(now + i * 0.15);
    osc.stop(now + i * 0.15 + 0.2);
  }
}

// Sound: Verlust
function playLoseSound() {
  initAudio();
  const now = audioContext.currentTime;
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  
  osc.connect(gain);
  gain.connect(audioContext.destination);
  
  osc.frequency.setValueAtTime(200, now);
  osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
  osc.type = "sawtooth";
  
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
  
  osc.start(now);
  osc.stop(now + 0.3);
}

// Expose sound functions globally for XXL Slot
window.playSpinSound = playSpinSound;
window.playWinSound = playWinSound;
window.playLoseSound = playLoseSound;

// Update Balance Anzeige
function updateSlotBalance() {
  document.getElementById("slotBalance").textContent = userCoins;
}

// Gewinn-Prüfung
function checkWin(reels) {
  let winLines = 0;
  let hasSevenLine = false;

  const line = (a,b,c) => {
    const ok = reels[a] === reels[b] && reels[b] === reels[c];
    if (ok) {
      winLines++;
      if (reels[a] === "7️⃣") hasSevenLine = true;
    }
  };

  // Horizontal
  line(0,1,2); line(3,4,5); line(6,7,8);
  // Vertikal
  line(0,3,6); line(1,4,7); line(2,5,8);
  // Diagonal
  line(0,4,8); line(2,4,6);

  // Alle 9 gleich
  if (reels.every(r => r === reels[0])) {
    if (reels[0] === "7️⃣") {
      return { type: "full-seven", multiplier: 10, winLines: 8 };
    } else {
      return { type: "full-field", multiplier: 10, winLines: 8 };
    }
  }

  // 4 oder mehr Linien -> 5-fach (mit 7er-Bonus = ×10)
  if (winLines >= 4) {
    let multiplier = 5;
    if (hasSevenLine) multiplier = 10;
    return { type: "quad", multiplier, winLines };
  }

  // 3 Linien -> 3-fach (mit 7er-Bonus = ×6)
  if (winLines === 3) {
    let multiplier = 3;
    if (hasSevenLine) multiplier = 6;
    return { type: "triple", multiplier, winLines };
  }

  // 2 Linien -> 3-fach (7er-Bonus = ×6)
  if (winLines === 2) {
    let multiplier = 3;
    if (hasSevenLine) multiplier = 6;
    return { type: "double", multiplier, winLines };
  }

  // 1 Linie -> 2-fach (7er-Bonus = ×4)
  if (winLines === 1) {
    let multiplier = 2;
    if (hasSevenLine) multiplier = 4;
    return { type: "single", multiplier, winLines };
  }

  return { type: "lose", multiplier: 0, winLines: 0 };
}

// Spin animieren
async function animateSlotSpin() {
  return new Promise(resolve => {
    let spinCount = 0;
    const maxSpins = 20;
    
    const spinInterval = setInterval(() => {
      // Zufällige Symbole
      for (let i = 0; i < 9; i++) {
        slotReels[i] = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
        document.getElementById(`slot${i}`).textContent = slotReels[i];
        document.getElementById(`slot${i}`).classList.add("spinning");
      }
      
      spinCount++;
      if (spinCount >= maxSpins) {
        clearInterval(spinInterval);
        
        // Spinning-Klasse entfernen
        for (let i = 0; i < 9; i++) {
          document.getElementById(`slot${i}`).classList.remove("spinning"); 
        }
        
        resolve();
      }
    }, 100);
  });
}

// Haupt-Spin Funktion (nur Gewinntext ergänzen für triple)
window.spinSlots = async function() {
  if (isSlotSpinning) return;
  if (!currentUser) {
    showNotification("Fehler", "Bitte einloggen zum Spielen!");
    return;
  }
  
  const bet = parseInt(document.getElementById("slotBet").value) || 0;
  
  if (bet <= 0) {
    showNotification("Fehler", "Einsatz muss > 0 sein!");
    return;
  }
  
  if (bet > userCoins) {
    showNotification("Fehler", "Du hast nicht genug Münzen!");
    return;
  }
  
  isSlotSpinning = true;
  document.getElementById("slotSpinBtn").disabled = true;
  document.getElementById("slotResult").textContent = "";
  
  // Einsatz abziehen
  await addCoins(-bet);
  updateSlotBalance();
  
  // Spin Sound
  playSpinSound();
  
  // Animiere
  await animateSlotSpin();
  
  // Prüfe Gewinn
const result = checkWin(slotReels);
  let winAmount = 0;
  let resultText = "";

  if (result.type === "seven-jackpot") {
    winAmount = bet * 10;
    resultText = `🎰🔟 SIEBEN-JACKPOT! 🔟🎰 +${winAmount} Münzen!`;
    playWinSound();
  } else if (result.type === "jackpot") {
    winAmount = bet * 5;
    resultText = `🎉 JACKPOT! 🎉 +${winAmount} Münzen!`;
    playWinSound();
  } else if (result.type === "triple") {
    winAmount = bet * result.multiplier;
    const bonus = result.multiplier === 6 ? " (7er Bonus!)" : "";
    resultText = `💥 ${result.winLines} Gewinn-Linien! +${winAmount} Münzen!${bonus}`;
    playWinSound();
  } else if (result.type === "double") {
    winAmount = bet * result.multiplier;
    const bonus = result.multiplier === 6 ? " (7er Bonus!)" : "";
    resultText = `🌟 2 Linien! +${winAmount} Münzen!${bonus}`;
    playWinSound();
  } else if (result.type === "single") {
    winAmount = bet * result.multiplier;
    const bonus = result.multiplier === 4 ? " (7er Bonus!)" : "";
    resultText = `✨ 1 Linie! +${winAmount} Münzen!${bonus}`;
    playWinSound();
  } else {
    resultText = "❌ Verloren! Versuch es nochmal!";
    playLoseSound();
  }

  if (winAmount > 0) {
    await addCoins(winAmount);
    
    // Speichere höchsten Slot-Gewinn
    if (currentUser) {
      const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
      const currentHighWin = userDoc.exists() ? (userDoc.data().slotHighWin || 0) : 0;
      
      if (winAmount > currentHighWin) {
        await updateDoc(doc(db, 'users', currentUser.uid), { 
          slotHighWin: winAmount 
        });
      }
    }
    
    // Track Slot Winnings für Battle Pass
    await updateBPQuestProgress('slotWins', winAmount);
    
    // Track Jackpot für Battle Pass
    if (result.type === 'jackpot' || result.type === 'seven-jackpot') {
      await updateBPQuestProgress('jackpot', 1);
    }
  }

  updateSlotBalance();
  document.getElementById("slotResult").textContent = resultText;

  isSlotSpinning = false;
  document.getElementById("slotSpinBtn").disabled = false;
};

window.resetSlots = function() {
  document.getElementById("slotResult").textContent = "";
  document.getElementById("slotBet").value = "10";
  updateSlotBalance();
};

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

// Init beim Start
updateSlotBalance();

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Notification Modal (ersetzt alert)
/////////////////////////////////////////////////////////////////////////////
window.showNotification = function(title, message) {
  document.getElementById("notifTitle").textContent = title;
  document.getElementById("notifMessage").textContent = message;
  const nm = document.getElementById("notificationModal");
  nm.style.display = "flex";
  nm.style.zIndex = "5000"; // Sicherheit falls CSS überschrieben wurde
  // Fokus für Accessibility
  const firstBtn = nm.querySelector('button');
  if (firstBtn) {
    setTimeout(()=> firstBtn.focus(), 10);
  }
};

window.closeNotification = function() {
  document.getElementById("notificationModal").style.display = "none";
};

// Quest Completion Popup
window.showQuestPopup = function(questName, points, isWeekly = false) {
  const container = document.getElementById('questPopupContainer');
  if (!container) return;
  
  // Spiele Sound
  playGameSound('quest_complete');
  
  // Erstelle Popup
  const popup = document.createElement('div');
  popup.className = 'quest-popup';
  popup.innerHTML = `
    <div class="quest-popup-header">
      <span class="quest-popup-icon">${isWeekly ? '⭐' : '📋'}</span>
      <span>Quest abgeschlossen!</span>
    </div>
    <div class="quest-popup-body">
      <strong>${questName}</strong>
    </div>
    <div class="quest-popup-points">
      🎉 +${points} Battle Pass Punkte
    </div>
  `;
  
  container.appendChild(popup);
  
  // Nach 4 Sekunden ausblenden
  setTimeout(() => {
    popup.classList.add('slide-out');
    setTimeout(() => {
      popup.remove();
    }, 500);
  }, 4000);
};

// Private Chat Notification
window.showPrivateChatNotification = function(nickname, messagePreview) {
  const container = document.getElementById('questPopupContainer');
  if (!container) return;
  
  // Spiele Sound
  playGameSound('message');
  
  // Erstelle Popup
  const popup = document.createElement('div');
  popup.className = 'quest-popup';
  popup.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
  popup.innerHTML = `
    <div class="quest-popup-header">
      <span class="quest-popup-icon">💬</span>
      <span>Neue Nachricht</span>
    </div>
    <div class="quest-popup-body">
      <strong>${nickname}</strong>
    </div>
    <div class="quest-popup-points" style="font-size:13px; opacity:0.9;">
      ${messagePreview.length > 40 ? messagePreview.substring(0, 40) + '...' : messagePreview}
    </div>
  `;
  
  container.appendChild(popup);
  
  // Nach 3 Sekunden ausblenden
  setTimeout(() => {
    popup.classList.add('slide-out');
    setTimeout(() => {
      popup.remove();
    }, 500);
  }, 3000);
};

// Klick auf Hintergrund schließt auch das Notification-Modal
const notificationModalEl = document.getElementById("notificationModal");
if (notificationModalEl) {
  notificationModalEl.addEventListener("click", (e) => {
    if (e.target === notificationModalEl) {
      window.closeNotification();
    }
  });
}

/////////////////////////////////////////////////////////////////////////////

// Global state for ranking tabs
let currentSnakeRankingMode = 'all';
let currentFlappyRankingMode = 'all';
let currentTTTRankingMode = 'all';
let currentTowerRankingMode = 'all';
let currentSudokuRankingMode = 'all';
let currentPenaltyRankingMode = 'all';
let currentChessRankingMode = 'all';
let currentDinoRankingMode = 'all';
let currentFlagsRankingMode = 'all';
let currentClubsRankingMode = 'all';

// Helper: Filter scores to only include current user and their friends
function filterFriendsOnly(scores) {
  try {
    if (!currentUser) return [];
    const friends = (typeof userInventory !== 'undefined' && userInventory && Array.isArray(userInventory.friends))
      ? userInventory.friends
      : [];
    const allowedUIDs = [currentUser.uid, ...friends];
    return scores.filter(s => allowedUIDs.includes(s.uid));
  } catch (e) {
    console.warn('Freundes-Filter Fallback aktiv:', e);
    return scores; // notfalls keine Filterung
  }
}

async function loadSnakeRankings(mode) {
  const listEl = document.getElementById("snakeRankingList");
  listEl.innerHTML = "<p>Wird geladen...</p>";
  
  if (mode) currentSnakeRankingMode = mode;
  
  try {
    const snap = await getDocs(collection(db, "snakeScores"));
    
    // Sortiere nach Score (absteigend)
    let scores = [];
    snap.forEach(d => {
      scores.push({
        uid: d.data().uid || null,
        nickname: d.data().nickname || "guest",
        score: d.data().score || 0,
        date: d.data().createdAt?.toDate?.() || new Date()
      });
    });
    
    scores.sort((a, b) => b.score - a.score);
    
    // Freunde-Filter anwenden
    if (currentSnakeRankingMode === 'friends') {
      scores = filterFriendsOnly(scores);
    }
    
    const top10 = scores.slice(0, 10);
    
    if (top10.length === 0) {
      listEl.innerHTML = "<p>Noch keine Scores vorhanden.</p>";
      return;
    }
    
    // Profilbilder laden
    const profilePics = {};
    const nameColors = {};
    for (const score of top10) {
      if (score.uid) {
        try {
          const userDoc = await getDoc(doc(db, 'users', score.uid));
          if (userDoc.exists()) {
            const uData = userDoc.data();
            profilePics[score.uid] = uData.profilePic || getDefaultProfilePic();
            nameColors[score.uid] = (uData.inventory || {}).chatNameColor || null;
          } else {
            profilePics[score.uid] = getDefaultProfilePic();
            nameColors[score.uid] = null;
          }
        } catch {
          profilePics[score.uid] = getDefaultProfilePic();
          nameColors[score.uid] = null;
        }
      } else {
        profilePics[score.uid] = getDefaultProfilePic();
        nameColors[score.uid] = null;
      }
    }
    
    // Dark-Mode Check
    const isDark = document.body.classList.contains("dark-mode");
    const headerBg = "#007bff";
    const headerText = "#fff";
    const rowBg1 = isDark ? "#333" : "#f9f9f9";
    const rowBg2 = isDark ? "#222" : "#fff";
    const textColor = isDark ? "#f2f4f8" : "#111";
    const borderColor = isDark ? "#555" : "#ddd";
    
    let html = `<table style='width:100%; border-collapse:collapse; color:${textColor};'>`;
    html += `<tr style='background:${headerBg}; color:${headerText};'><th style='padding:10px;'>#</th><th style='padding:10px;'>Spieler</th><th style='padding:10px;'>Score</th><th style='padding:10px;'>Datum</th></tr>`;
    
    top10.forEach((item, idx) => {
      const bgColor = idx % 2 === 0 ? rowBg1 : rowBg2;
      const medal = idx === 0 ? "🥇" : idx === 1 ? "🥈" : idx === 2 ? "🥉" : "";
      const profilePic = profilePics[item.uid];
      html += `
        <tr style="background:${bgColor}; border-bottom:1px solid ${borderColor}; color:${textColor};">
          <td style="padding:10px; text-align:center;">${medal} ${idx + 1}</td>
          <td style="padding:10px; cursor:pointer;" onclick="openUserProfile('${item.uid}')">
            <img src="${profilePic}" style="width:25px; height:25px; border-radius:50%; object-fit:cover; vertical-align:middle; margin-right:8px;">
            ${(() => {
              const cId = nameColors[item.uid];
              if (cId === 'santa_red') return '<span data-color-id="santa">' + item.nickname + '</span>';
              if (cId === 'holly_green') return '<span data-color-id="holly">' + item.nickname + '</span>';
              if (cId === 'icy_blue') return '<span data-color-id="icy">' + item.nickname + '</span>';
              if (cId === 'advent_snow_white') return '<span data-color-id="advent_snow">' + item.nickname + '</span>';
              if (cId === 'advent_christmas_red') return '<span data-color-id="advent_xmas">' + item.nickname + '</span>';
              if (cId === 'advent_golden_star') return '<span data-color-id="advent_gold_star">' + item.nickname + '</span>';
              if (cId === 'advent_christmas_magic') return '<span data-color-id="advent_magic">' + item.nickname + '</span>';
              if (cId === 'gold') return '<span data-color-id="gold">' + item.nickname + '</span>';
              if (cId === 'ruby_red') return '<span data-color-id="ruby">' + item.nickname + '</span>';
              if (cId === 'emerald') return '<span data-color-id="emerald">' + item.nickname + '</span>';
              if (cId === 'diamond') return '<span data-color-id="diamond">' + item.nickname + '</span>';
              if (cId === 'rainbow') return '<span data-color-id="rainbow">' + item.nickname + '</span>';
              if (cId) {
                const c = CHAT_COLORS.find(x => x.id === cId);
                if (c) return '<span style="color:' + c.color + '">' + item.nickname + '</span>';
              }
              return item.nickname;
            })()}
          </td>
          <td style="padding:10px; font-weight:bold;">${item.score}</td>
          <td style="padding:10px; font-size:12px;">${item.date.toLocaleDateString("de-DE")}</td>
        </tr>
      `;
    });
    
    html += "</table>";
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error("Fehler beim Laden der Rankings:", err);
    listEl.innerHTML = "<p>Fehler beim Laden der Rankings.</p>";
  }
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// BATTLE PASS SYSTEM - 10 TIERS, DAILY QUESTS, FREE/PAID TRACKS
/////////////////////////////////////////////////////////////////////////////
// (Basketball Spiel entfernt)
// MEMORY GAME 🧠 - Single Player
/////////////////////////////////////////////////////////////////////////////
const memoryEmojisBase = ['🍎','🍌','🍒','🍇','🍉','🥝','🍑','🍍','🥥','🍋','🍈','🍏'];
const memoryPairsByDifficulty = { noob:6, profi:8, champion:10 };
let memoryDifficulty = 'noob';
let memoryEmojis = [];
let memoryDeck = [];
let memoryFlipped = [];
let memoryMatched = new Set();
let memoryMoves = 0;
let memoryBest = parseInt(localStorage.getItem('memoryBestMoves') || '0', 10) || 0;
let memoryRankingMode = 'all';
let memoryBusy = false;
let memoryCompletedFlag = false;

function buildMemoryDeck() {
  const pairs = memoryPairsByDifficulty[memoryDifficulty] || 6;
  memoryEmojis = memoryEmojisBase.slice(0, pairs);
  memoryDeck = [...memoryEmojis, ...memoryEmojis]
    .map((val, idx) => ({ id: idx + '-' + Math.random().toString(36).slice(2), val }))
    .sort(() => Math.random() - 0.5);
  const grid = document.getElementById('memoryGrid');
  if (grid) {
    const cols = memoryDifficulty === 'champion' ? 5 : 4;
    grid.style.gridTemplateColumns = `repeat(${cols},1fr)`;
  }
}

function renderMemoryGrid() {
  const grid = document.getElementById('memoryGrid');
  if (!grid) return;
  grid.innerHTML = '';
  memoryDeck.forEach(card => {
    const div = document.createElement('div');
    div.className = 'memory-card';
    div.style.cssText = 'background:#fff; border:2px solid #ccc; border-radius:8px; padding:14px 0; font-size:26px; text-align:center; cursor:pointer; user-select:none; transition:background .3s, transform .2s;';
    const isMatched = memoryMatched.has(card.id);
    const isFlipped = memoryFlipped.includes(card.id);
    div.textContent = (isMatched || isFlipped) ? card.val : '❓';
    if (isMatched) div.style.background = '#c8e6c9';
    div.onclick = () => flipMemoryCard(card.id);
    grid.appendChild(div);
  });
  updateMemoryStats();
}

function updateMemoryStats() {
  const movesEl = document.getElementById('memoryMoves');
  const bestEl = document.getElementById('memoryBest');
  if (movesEl) movesEl.textContent = memoryMoves;
  if (bestEl) bestEl.textContent = memoryBest > 0 ? memoryBest : '-';
}

function startMemory() {
  memoryMoves = 0;
  memoryFlipped = [];
  memoryMatched.clear();
  memoryCompletedFlag = false;
  buildMemoryDeck();
  renderMemoryGrid();
}

function resetMemory() { startMemory(); }

function flipMemoryCard(cardId) {
  if (memoryBusy) return;
  if (memoryMatched.has(cardId)) return;
  if (memoryFlipped.includes(cardId)) return;
  memoryFlipped.push(cardId);
  try { playGameSound('memory_flip','memory'); } catch(e){}
  renderMemoryGrid();
  if (memoryFlipped.length === 2) {
    memoryBusy = true;
    memoryMoves++;
    const [a, b] = memoryFlipped.map(id => memoryDeck.find(c => c.id === id));
    if (a && b && a.val === b.val) {
      memoryMatched.add(a.id);
      memoryMatched.add(b.id);
      memoryFlipped = [];
      memoryBusy = false;
      try { playGameSound('memory_match','memory'); } catch(e){}
      renderMemoryGrid();
      if (memoryMatched.size === memoryDeck.length) {
        handleMemoryCompletion();
      }
    } else {
      try { playGameSound('memory_mismatch','memory'); } catch(e){}
      setTimeout(() => {
        memoryFlipped = [];
        memoryBusy = false;
        renderMemoryGrid();
      }, 800);
    }
  }
  updateMemoryStats();
}

function handleMemoryCompletion() {
  if (memoryCompletedFlag) return;
  memoryCompletedFlag = true;
  if (memoryBest === 0 || memoryMoves < memoryBest) {
    memoryBest = memoryMoves;
    localStorage.setItem('memoryBestMoves', memoryBest.toString());
    updateMemoryStats();
    saveMemoryHighscore(memoryBest).catch(e=>console.warn('Memory highscore save fail', e));
  }
  const rewardMap = { noob:10, profi:20, champion:30 };
  const reward = rewardMap[memoryDifficulty] || 10;
  addCoins(reward).catch(()=>{});
  trackGamePlayed('memory').catch(()=>{});
  showNotification('Memory', `Gewonnen! Schwierigkeit: ${memoryDifficulty} | Züge: ${memoryMoves} | +${reward} Münzen`);
  try { playGameSound('memory_win','memory'); } catch(e){}
}

function setMemoryDifficulty(diff) {
  if (!['noob','profi','champion'].includes(diff)) return;
  memoryDifficulty = diff;
  startMemory();
}
window.setMemoryDifficulty = setMemoryDifficulty;

async function saveMemoryHighscore(moves) {
  if (!currentUser) return;
  try {
    await addDoc(collection(db, 'memoryHighscores'), {
      uid: currentUser.uid,
      nickname: currentNickname || 'Unbekannt',
      moves: moves,
      ts: Date.now()
    });
  } catch(e){ console.error('Memory Highscore Fehler', e); }
}

async function loadMemoryRankings(mode) {
  try {
    const snapshot = await getDocs(query(collection(db,'memoryHighscores'), orderBy('moves','asc'), limit(50)));
    let entries = [];
    snapshot.forEach(docSnap => {
      const d = docSnap.data();
      if (typeof d.moves === 'number') entries.push({ nickname: d.nickname || 'Unbekannt', moves: d.moves, uid: d.uid });
    });
    if (mode === 'friends') entries = filterFriendsOnly(entries);
    entries = entries.slice(0,10);
    const listEl = document.getElementById('memoryRankingList');
    if (!listEl) return;
    if (entries.length === 0) { listEl.innerHTML = '<p style="opacity:0.6;">Keine Einträge</p>'; return; }
    let html = '<table style="width:100%; border-collapse:collapse;">';
    html += '<tr style="background:#007bff; color:#fff;"><th style="text-align:left; padding:6px;">#</th><th style="text-align:left; padding:6px;">Spieler</th><th style="text-align:right; padding:6px;">Züge</th></tr>';
    entries.forEach((s,i)=>{
      html += `<tr style=\"border-bottom:1px solid #ddd;\"><td style=\"padding:5px;\">${i+1}</td><td style=\"padding:5px;\">${s.nickname}</td><td style=\"padding:5px; text-align:right; font-weight:bold;\">${s.moves}</td></tr>`;
    });
    html += '</table>';
    listEl.innerHTML = html;
  } catch(e){ console.error('Fehler Memory Rankings', e); }
}

window.openMemoryRanking = async function() {
  const modal = document.getElementById('memoryRankingModal');
  if (modal) modal.style.display = 'flex';
  memoryRankingMode = 'all';
  await loadMemoryRankings(memoryRankingMode);
};
window.closeMemoryRanking = function() {
  const modal = document.getElementById('memoryRankingModal');
  if (modal) modal.style.display = 'none';
};
window.switchMemoryRankingTab = async function(mode) {
  memoryRankingMode = mode;
  const allBtn = document.getElementById('memoryRankingTabAll');
  const frBtn = document.getElementById('memoryRankingTabFriends');
  if (allBtn && frBtn) {
    if (mode === 'all') { allBtn.style.background = '#007bff'; frBtn.style.background = '#6c757d'; }
    else { allBtn.style.background = '#6c757d'; frBtn.style.background = '#007bff'; }
  }
  await loadMemoryRankings(mode);
};

window.startMemory = startMemory;
window.resetMemory = resetMemory;

if (document.getElementById('memoryGrid')) { startMemory(); }

/////////////////////////////////////////////////////////////////////////////
// FLAGS QUIZ GAME 🌍
/////////////////////////////////////////////////////////////////////////////

// All world countries with their flag emoji
const WORLD_FLAGS = [
  { flag: '🇦🇫', country: 'Afghanistan', alt: ['afghanistan'] },
  { flag: '🇦🇱', country: 'Albanien', alt: ['albania', 'albanien'] },
  { flag: '🇩🇿', country: 'Algerien', alt: ['algeria', 'algerien'] },
  { flag: '🇦🇩', country: 'Andorra', alt: ['andorra'] },
  { flag: '🇦🇴', country: 'Angola', alt: ['angola'] },
  { flag: '🇦🇬', country: 'Antigua und Barbuda', alt: ['antigua', 'barbuda', 'antigua und barbuda'] },
  { flag: '🇦🇷', country: 'Argentinien', alt: ['argentina', 'argentinien'] },
  { flag: '🇦🇲', country: 'Armenien', alt: ['armenia', 'armenien'] },
  { flag: '🇦🇺', country: 'Australien', alt: ['australia', 'australien'] },
  { flag: '🇦🇹', country: 'Österreich', alt: ['austria', 'oesterreich', 'österreich'] },
  { flag: '🇦🇿', country: 'Aserbaidschan', alt: ['azerbaijan', 'aserbaidschan'] },
  { flag: '🇧🇸', country: 'Bahamas', alt: ['bahamas'] },
  { flag: '🇧🇭', country: 'Bahrain', alt: ['bahrain'] },
  { flag: '🇧🇩', country: 'Bangladesch', alt: ['bangladesh', 'bangladesch'] },
  { flag: '🇧🇧', country: 'Barbados', alt: ['barbados'] },
  { flag: '🇧🇾', country: 'Belarus', alt: ['belarus', 'weissrussland', 'weißrussland'] },
  { flag: '🇧🇪', country: 'Belgien', alt: ['belgium', 'belgien'] },
  { flag: '🇧🇿', country: 'Belize', alt: ['belize'] },
  { flag: '🇧🇯', country: 'Benin', alt: ['benin'] },
  { flag: '🇧🇹', country: 'Bhutan', alt: ['bhutan'] },
  { flag: '🇧🇴', country: 'Bolivien', alt: ['bolivia', 'bolivien'] },
  { flag: '🇧🇦', country: 'Bosnien und Herzegowina', alt: ['bosnia', 'bosnien', 'herzegowina'] },
  { flag: '🇧🇼', country: 'Botswana', alt: ['botswana'] },
  { flag: '🇧🇷', country: 'Brasilien', alt: ['brazil', 'brasilien'] },
  { flag: '🇧🇳', country: 'Brunei', alt: ['brunei'] },
  { flag: '🇧🇬', country: 'Bulgarien', alt: ['bulgaria', 'bulgarien'] },
  { flag: '🇧🇫', country: 'Burkina Faso', alt: ['burkina', 'faso'] },
  { flag: '🇧🇮', country: 'Burundi', alt: ['burundi'] },
  { flag: '🇰🇭', country: 'Kambodscha', alt: ['cambodia', 'kambodscha'] },
  { flag: '🇨🇲', country: 'Kamerun', alt: ['cameroon', 'kamerun'] },
  { flag: '🇨🇦', country: 'Kanada', alt: ['canada', 'kanada'] },
  { flag: '🇨🇻', country: 'Kap Verde', alt: ['cape verde', 'kap verde'] },
  { flag: '🇨🇫', country: 'Zentralafrikanische Republik', alt: ['central african', 'zentralafrika'] },
  { flag: '🇹🇩', country: 'Tschad', alt: ['chad', 'tschad'] },
  { flag: '🇨🇱', country: 'Chile', alt: ['chile'] },
  { flag: '🇨🇳', country: 'China', alt: ['china'] },
  { flag: '🇨🇴', country: 'Kolumbien', alt: ['colombia', 'kolumbien'] },
  { flag: '🇰🇲', country: 'Komoren', alt: ['comoros', 'komoren'] },
  { flag: '🇨🇬', country: 'Kongo', alt: ['congo', 'kongo'] },
  { flag: '🇨🇩', country: 'Demokratische Republik Kongo', alt: ['congo', 'dr kongo', 'demokratische republik kongo'] },
  { flag: '🇨🇷', country: 'Costa Rica', alt: ['costa rica'] },
  { flag: '🇭🇷', country: 'Kroatien', alt: ['croatia', 'kroatien'] },
  { flag: '🇨🇺', country: 'Kuba', alt: ['cuba', 'kuba'] },
  { flag: '🇨🇾', country: 'Zypern', alt: ['cyprus', 'zypern'] },
  { flag: '🇨🇿', country: 'Tschechien', alt: ['czech', 'tschechien', 'tschechische republik'] },
  { flag: '🇩🇰', country: 'Dänemark', alt: ['denmark', 'daenemark', 'dänemark'] },
  { flag: '🇩🇯', country: 'Dschibuti', alt: ['djibouti', 'dschibuti'] },
  { flag: '🇩🇲', country: 'Dominica', alt: ['dominica'] },
  { flag: '🇩🇴', country: 'Dominikanische Republik', alt: ['dominican', 'dominikanische republik'] },
  { flag: '🇪🇨', country: 'Ecuador', alt: ['ecuador'] },
  { flag: '🇪🇬', country: 'Ägypten', alt: ['egypt', 'aegypten', 'ägypten'] },
  { flag: '🇸🇻', country: 'El Salvador', alt: ['el salvador', 'salvador'] },
  { flag: '🇬🇶', country: 'Äquatorialguinea', alt: ['equatorial guinea', 'aequatorialguinea', 'äquatorialguinea'] },
  { flag: '🇪🇷', country: 'Eritrea', alt: ['eritrea'] },
  { flag: '🇪🇪', country: 'Estland', alt: ['estonia', 'estland'] },
  { flag: '🇸🇿', country: 'Eswatini', alt: ['eswatini', 'swaziland'] },
  { flag: '🇪🇹', country: 'Äthiopien', alt: ['ethiopia', 'aethiopien', 'äthiopien'] },
  { flag: '🇫🇯', country: 'Fidschi', alt: ['fiji', 'fidschi'] },
  { flag: '🇫🇮', country: 'Finnland', alt: ['finland', 'finnland'] },
  { flag: '🇫🇷', country: 'Frankreich', alt: ['france', 'frankreich'] },
  { flag: '🇬🇦', country: 'Gabun', alt: ['gabon', 'gabun'] },
  { flag: '🇬🇲', country: 'Gambia', alt: ['gambia'] },
  { flag: '🇬🇪', country: 'Georgien', alt: ['georgia', 'georgien'] },
  { flag: '🇩🇪', country: 'Deutschland', alt: ['germany', 'deutschland'] },
  { flag: '🇬🇭', country: 'Ghana', alt: ['ghana'] },
  { flag: '🇬🇷', country: 'Griechenland', alt: ['greece', 'griechenland'] },
  { flag: '🇬🇩', country: 'Grenada', alt: ['grenada'] },
  { flag: '🇬🇹', country: 'Guatemala', alt: ['guatemala'] },
  { flag: '🇬🇳', country: 'Guinea', alt: ['guinea'] },
  { flag: '🇬🇼', country: 'Guinea-Bissau', alt: ['guinea-bissau', 'guinea bissau'] },
  { flag: '🇬🇾', country: 'Guyana', alt: ['guyana'] },
  { flag: '🇭🇹', country: 'Haiti', alt: ['haiti'] },
  { flag: '🇭🇳', country: 'Honduras', alt: ['honduras'] },
  { flag: '🇭🇺', country: 'Ungarn', alt: ['hungary', 'ungarn'] },
  { flag: '🇮🇸', country: 'Island', alt: ['iceland', 'island'] },
  { flag: '🇮🇳', country: 'Indien', alt: ['india', 'indien'] },
  { flag: '🇮🇩', country: 'Indonesien', alt: ['indonesia', 'indonesien'] },
  { flag: '🇮🇷', country: 'Iran', alt: ['iran'] },
  { flag: '🇮🇶', country: 'Irak', alt: ['iraq', 'irak'] },
  { flag: '🇮🇪', country: 'Irland', alt: ['ireland', 'irland'] },
  { flag: '🇮🇱', country: 'Israel', alt: ['israel'] },
  { flag: '🇮🇹', country: 'Italien', alt: ['italy', 'italien'] },
  { flag: '🇯🇲', country: 'Jamaika', alt: ['jamaica', 'jamaika'] },
  { flag: '🇯🇵', country: 'Japan', alt: ['japan'] },
  { flag: '🇯🇴', country: 'Jordanien', alt: ['jordan', 'jordanien'] },
  { flag: '🇰🇿', country: 'Kasachstan', alt: ['kazakhstan', 'kasachstan'] },
  { flag: '🇰🇪', country: 'Kenia', alt: ['kenya', 'kenia'] },
  { flag: '🇰🇮', country: 'Kiribati', alt: ['kiribati'] },
  { flag: '🇰🇵', country: 'Nordkorea', alt: ['north korea', 'nordkorea'] },
  { flag: '🇰🇷', country: 'Südkorea', alt: ['south korea', 'suedkorea', 'südkorea'] },
  { flag: '🇰🇼', country: 'Kuwait', alt: ['kuwait'] },
  { flag: '🇰🇬', country: 'Kirgisistan', alt: ['kyrgyzstan', 'kirgisistan'] },
  { flag: '🇱🇦', country: 'Laos', alt: ['laos'] },
  { flag: '🇱🇻', country: 'Lettland', alt: ['latvia', 'lettland'] },
  { flag: '🇱🇧', country: 'Libanon', alt: ['lebanon', 'libanon'] },
  { flag: '🇱🇸', country: 'Lesotho', alt: ['lesotho'] },
  { flag: '🇱🇷', country: 'Liberia', alt: ['liberia'] },
  { flag: '🇱🇾', country: 'Libyen', alt: ['libya', 'libyen'] },
  { flag: '🇱🇮', country: 'Liechtenstein', alt: ['liechtenstein'] },
  { flag: '🇱🇹', country: 'Litauen', alt: ['lithuania', 'litauen'] },
  { flag: '🇱🇺', country: 'Luxemburg', alt: ['luxembourg', 'luxemburg'] },
  { flag: '🇲🇬', country: 'Madagaskar', alt: ['madagascar', 'madagaskar'] },
  { flag: '🇲🇼', country: 'Malawi', alt: ['malawi'] },
  { flag: '🇲🇾', country: 'Malaysia', alt: ['malaysia'] },
  { flag: '🇲🇻', country: 'Malediven', alt: ['maldives', 'malediven'] },
  { flag: '🇲🇱', country: 'Mali', alt: ['mali'] },
  { flag: '🇲🇹', country: 'Malta', alt: ['malta'] },
  { flag: '🇲🇭', country: 'Marshallinseln', alt: ['marshall', 'marshallinseln'] },
  { flag: '🇲🇷', country: 'Mauretanien', alt: ['mauritania', 'mauretanien'] },
  { flag: '🇲🇺', country: 'Mauritius', alt: ['mauritius'] },
  { flag: '🇲🇽', country: 'Mexiko', alt: ['mexico', 'mexiko'] },
  { flag: '🇫🇲', country: 'Mikronesien', alt: ['micronesia', 'mikronesien'] },
  { flag: '🇲🇩', country: 'Moldau', alt: ['moldova', 'moldau'] },
  { flag: '🇲🇨', country: 'Monaco', alt: ['monaco'] },
  { flag: '🇲🇳', country: 'Mongolei', alt: ['mongolia', 'mongolei'] },
  { flag: '🇲🇪', country: 'Montenegro', alt: ['montenegro'] },
  { flag: '🇲🇦', country: 'Marokko', alt: ['morocco', 'marokko'] },
  { flag: '🇲🇿', country: 'Mosambik', alt: ['mozambique', 'mosambik'] },
  { flag: '🇲🇲', country: 'Myanmar', alt: ['myanmar', 'burma'] },
  { flag: '🇳🇦', country: 'Namibia', alt: ['namibia'] },
  { flag: '🇳🇷', country: 'Nauru', alt: ['nauru'] },
  { flag: '🇳🇵', country: 'Nepal', alt: ['nepal'] },
  { flag: '🇳🇱', country: 'Niederlande', alt: ['netherlands', 'niederlande', 'holland'] },
  { flag: '🇳🇿', country: 'Neuseeland', alt: ['new zealand', 'neuseeland'] },
  { flag: '🇳🇮', country: 'Nicaragua', alt: ['nicaragua'] },
  { flag: '🇳🇪', country: 'Niger', alt: ['niger'] },
  { flag: '🇳🇬', country: 'Nigeria', alt: ['nigeria'] },
  { flag: '🇲🇰', country: 'Nordmazedonien', alt: ['north macedonia', 'nordmazedonien', 'mazedonien'] },
  { flag: '🇳🇴', country: 'Norwegen', alt: ['norway', 'norwegen'] },
  { flag: '🇴🇲', country: 'Oman', alt: ['oman'] },
  { flag: '🇵🇰', country: 'Pakistan', alt: ['pakistan'] },
  { flag: '🇵🇼', country: 'Palau', alt: ['palau'] },
  { flag: '🇵🇸', country: 'Palästina', alt: ['palestine', 'palaestina', 'palästina'] },
  { flag: '🇵🇦', country: 'Panama', alt: ['panama'] },
  { flag: '🇵🇬', country: 'Papua-Neuguinea', alt: ['papua', 'new guinea', 'papua neuguinea'] },
  { flag: '🇵🇾', country: 'Paraguay', alt: ['paraguay'] },
  { flag: '🇵🇪', country: 'Peru', alt: ['peru'] },
  { flag: '🇵🇭', country: 'Philippinen', alt: ['philippines', 'philippinen'] },
  { flag: '🇵🇱', country: 'Polen', alt: ['poland', 'polen'] },
  { flag: '🇵🇹', country: 'Portugal', alt: ['portugal'] },
  { flag: '🇶🇦', country: 'Katar', alt: ['qatar', 'katar'] },
  { flag: '🇷🇴', country: 'Rumänien', alt: ['romania', 'rumaenien', 'rumänien'] },
  { flag: '🇷🇺', country: 'Russland', alt: ['russia', 'russland'] },
  { flag: '🇷🇼', country: 'Ruanda', alt: ['rwanda', 'ruanda'] },
  { flag: '🇰🇳', country: 'St. Kitts und Nevis', alt: ['saint kitts', 'nevis', 'kitts'] },
  { flag: '🇱🇨', country: 'St. Lucia', alt: ['saint lucia', 'lucia'] },
  { flag: '🇻🇨', country: 'St. Vincent', alt: ['saint vincent', 'vincent'] },
  { flag: '🇼🇸', country: 'Samoa', alt: ['samoa'] },
  { flag: '🇸🇲', country: 'San Marino', alt: ['san marino'] },
  { flag: '🇸🇹', country: 'São Tomé und Príncipe', alt: ['sao tome', 'principe'] },
  { flag: '🇸🇦', country: 'Saudi-Arabien', alt: ['saudi arabia', 'saudi-arabien'] },
  { flag: '🇸🇳', country: 'Senegal', alt: ['senegal'] },
  { flag: '🇷🇸', country: 'Serbien', alt: ['serbia', 'serbien'] },
  { flag: '🇸🇨', country: 'Seychellen', alt: ['seychelles', 'seychellen'] },
  { flag: '🇸🇱', country: 'Sierra Leone', alt: ['sierra leone'] },
  { flag: '🇸🇬', country: 'Singapur', alt: ['singapore', 'singapur'] },
  { flag: '🇸🇰', country: 'Slowakei', alt: ['slovakia', 'slowakei'] },
  { flag: '🇸🇮', country: 'Slowenien', alt: ['slovenia', 'slowenien'] },
  { flag: '🇸🇧', country: 'Salomonen', alt: ['solomon', 'salomonen'] },
  { flag: '🇸🇴', country: 'Somalia', alt: ['somalia'] },
  { flag: '🇿🇦', country: 'Südafrika', alt: ['south africa', 'suedafrika', 'südafrika'] },
  { flag: '🇸🇸', country: 'Südsudan', alt: ['south sudan', 'suedsudan', 'südsudan'] },
  { flag: '🇪🇸', country: 'Spanien', alt: ['spain', 'spanien'] },
  { flag: '🇱🇰', country: 'Sri Lanka', alt: ['sri lanka'] },
  { flag: '🇸🇩', country: 'Sudan', alt: ['sudan'] },
  { flag: '🇸🇷', country: 'Suriname', alt: ['suriname'] },
  { flag: '🇸🇪', country: 'Schweden', alt: ['sweden', 'schweden'] },
  { flag: '🇨🇭', country: 'Schweiz', alt: ['switzerland', 'schweiz'] },
  { flag: '🇸🇾', country: 'Syrien', alt: ['syria', 'syrien'] },
  { flag: '🇹🇼', country: 'Taiwan', alt: ['taiwan'] },
  { flag: '🇹🇯', country: 'Tadschikistan', alt: ['tajikistan', 'tadschikistan'] },
  { flag: '🇹🇿', country: 'Tansania', alt: ['tanzania', 'tansania'] },
  { flag: '🇹🇭', country: 'Thailand', alt: ['thailand'] },
  { flag: '🇹🇱', country: 'Timor-Leste', alt: ['timor', 'east timor', 'osttimor'] },
  { flag: '🇹🇬', country: 'Togo', alt: ['togo'] },
  { flag: '🇹🇴', country: 'Tonga', alt: ['tonga'] },
  { flag: '🇹🇹', country: 'Trinidad und Tobago', alt: ['trinidad', 'tobago'] },
  { flag: '🇹🇳', country: 'Tunesien', alt: ['tunisia', 'tunesien'] },
  { flag: '🇹🇷', country: 'Türkei', alt: ['turkey', 'tuerkei', 'türkei'] },
  { flag: '🇹🇲', country: 'Turkmenistan', alt: ['turkmenistan'] },
  { flag: '🇹🇻', country: 'Tuvalu', alt: ['tuvalu'] },
  { flag: '🇺🇬', country: 'Uganda', alt: ['uganda'] },
  { flag: '🇺🇦', country: 'Ukraine', alt: ['ukraine'] },
  { flag: '🇦🇪', country: 'Vereinigte Arabische Emirate', alt: ['uae', 'emirates', 'arabische emirate'] },
  { flag: '🇬🇧', country: 'Vereinigtes Königreich', alt: ['uk', 'united kingdom', 'great britain', 'england', 'großbritannien', 'grossbritannien'] },
  { flag: '🇺🇸', country: 'USA', alt: ['usa', 'united states', 'america', 'amerika'] },
  { flag: '🇺🇾', country: 'Uruguay', alt: ['uruguay'] },
  { flag: '🇺🇿', country: 'Usbekistan', alt: ['uzbekistan', 'usbekistan'] },
  { flag: '🇻🇺', country: 'Vanuatu', alt: ['vanuatu'] },
  { flag: '🇻🇦', country: 'Vatikanstadt', alt: ['vatican', 'vatikan'] },
  { flag: '🇻🇪', country: 'Venezuela', alt: ['venezuela'] },
  { flag: '🇻🇳', country: 'Vietnam', alt: ['vietnam'] },
  { flag: '🇾🇪', country: 'Jemen', alt: ['yemen', 'jemen'] },
  { flag: '🇿🇲', country: 'Sambia', alt: ['zambia', 'sambia'] },
  { flag: '🇿🇼', country: 'Simbabwe', alt: ['zimbabwe', 'simbabwe'] }
];

let flagsCurrentIndex = 0;
let flagsShuffledCountries = [];
let flagsScore = 0;
let flagsTotalCoins = 0;
let flagsGameActive = false;

function startFlagsQuiz() {
  flagsShuffledCountries = [...WORLD_FLAGS].sort(() => Math.random() - 0.5);
  flagsCurrentIndex = 0;
  flagsScore = 0;
  flagsTotalCoins = 0;
  flagsGameActive = true;
  
  document.getElementById('flagsInput').disabled = false;
  document.getElementById('flagsSubmitBtn').disabled = false;
  document.getElementById('flagsSkipBtn').disabled = false;
  document.getElementById('flagsFeedback').textContent = '';
  
  updateFlagsDisplay();
  showNextFlag();
}
window.startFlagsQuiz = startFlagsQuiz;

function showNextFlag() {
  if (flagsCurrentIndex >= flagsShuffledCountries.length) {
    endFlagsQuiz();
    return;
  }
  
  const current = flagsShuffledCountries[flagsCurrentIndex];
  document.getElementById('flagDisplay').textContent = current.flag;
  document.getElementById('flagsInput').value = '';
  document.getElementById('flagsFeedback').textContent = '';
  document.getElementById('flagsInput').focus();
  
  updateFlagsDisplay();
}

function submitFlagsAnswer() {
  if (!flagsGameActive) return;
  
  const userAnswer = document.getElementById('flagsInput').value.trim().toLowerCase();
  if (!userAnswer) {
    document.getElementById('flagsFeedback').innerHTML = '<span style=\"color:#e74c3c;\">⚠️ Bitte ein Land eingeben!</span>';
    return;
  }
  
  const current = flagsShuffledCountries[flagsCurrentIndex];
  const isCorrect = current.alt.some(alt => alt.toLowerCase() === userAnswer);
  
  const feedbackEl = document.getElementById('flagsFeedback');
  
  if (isCorrect) {
    flagsScore++;
    const coinReward = Math.floor(Math.random() * 3) + 3; // Random 3-5 coins
    flagsTotalCoins += coinReward;
    feedbackEl.innerHTML = `<span style=\"color:#28a745;\">✅ Richtig! +${coinReward} 🪙</span>`;
    playGameSound('success', 'flags');
    
    setTimeout(() => {
      flagsCurrentIndex++;
      showNextFlag();
    }, 800);
  } else {
    feedbackEl.innerHTML = `<span style=\"color:#e74c3c;\">❌ Falsch! Das war ${current.country}</span>`;
    playGameSound('fail', 'flags');
    
    setTimeout(() => {
      flagsCurrentIndex++;
      showNextFlag();
    }, 1500);
  }
  
  updateFlagsDisplay();
}
window.submitFlagsAnswer = submitFlagsAnswer;

function skipFlag() {
  if (!flagsGameActive) return;
  
  const current = flagsShuffledCountries[flagsCurrentIndex];
  document.getElementById('flagsFeedback').innerHTML = `<span style=\"color:#ffc107;\">⏭️ Übersprungen: ${current.country}</span>`;
  
  setTimeout(() => {
    flagsCurrentIndex++;
    showNextFlag();
  }, 1000);
}
window.skipFlag = skipFlag;

function updateFlagsDisplay() {
  document.getElementById('flagsScore').textContent = flagsScore;
  document.getElementById('flagsTotal').textContent = flagsShuffledCountries.length;
  document.getElementById('flagsCoins').textContent = flagsTotalCoins;
}

async function endFlagsQuiz() {
  flagsGameActive = false;
  
  document.getElementById('flagsInput').disabled = true;
  document.getElementById('flagsSubmitBtn').disabled = true;
  document.getElementById('flagsSkipBtn').disabled = true;
  document.getElementById('flagDisplay').textContent = '🏆';
  
  const percentage = Math.round((flagsScore / flagsShuffledCountries.length) * 100);
  document.getElementById('flagsFeedback').innerHTML = `
    <div style=\"background:#28a745; color:#fff; padding:15px; border-radius:8px; margin-top:10px;\">
      <h3 style=\"margin:0 0 10px 0;\">🎉 Quiz beendet!</h3>
      <p style=\"margin:5px 0;\"><strong>${flagsScore}</strong> / ${flagsShuffledCountries.length} richtig (${percentage}%)</p>
      <p style=\"margin:5px 0;\">Verdient: <strong>${flagsTotalCoins} 🪙</strong></p>
    </div>
  `;
  
  playGameSound('win', 'flags');
  
  // Add coins
  if (flagsTotalCoins > 0) {
    await addCoins(flagsTotalCoins);
  }
  
  // Save to Firestore
  await saveFlagsHighscore(flagsScore);
  
  // Quest progress
  await updateBPQuestProgress('gamesPlayed', 1);
  await trackGamePlayed('flags');
}

async function saveFlagsHighscore(score) {
  if (!currentUser) return;
  try {
    // Reference to user's career stats document
    const userStatsRef = doc(db, 'flagsCareerStats', currentUser.uid);
    const userStatsSnap = await getDoc(userStatsRef);
    
    if (userStatsSnap.exists()) {
      // Update existing career stats
      const currentTotal = userStatsSnap.data().totalScore || 0;
      await updateDoc(userStatsRef, {
        totalScore: currentTotal + score,
        nickname: currentNickname || 'Unbekannt',
        lastPlayed: Date.now()
      });
    } else {
      // Create new career stats document
      await setDoc(userStatsRef, {
        uid: currentUser.uid,
        nickname: currentNickname || 'Unbekannt',
        totalScore: score,
        lastPlayed: Date.now()
      });
    }
  } catch(e){ console.error('Flags Highscore Fehler', e); }
}

// Ranking
window.openFlagsRanking = async function() {
  document.getElementById('flagsRankingModal').style.display = 'flex';
  await loadFlagsRankings('all');
};

window.closeFlagsRanking = function() {
  document.getElementById('flagsRankingModal').style.display = 'none';
};

window.switchFlagsRankingTab = async function(mode) {
  currentFlagsRankingMode = mode;
  document.getElementById('flagsRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('flagsRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  await loadFlagsRankings(mode);
};

async function loadFlagsRankings(mode) {
  try {
    const snapshot = await getDocs(query(collection(db,'flagsCareerStats'), orderBy('totalScore','desc'), limit(50)));
    let entries = [];
    snapshot.forEach(docSnap => {
      const d = docSnap.data();
      if (typeof d.totalScore === 'number') {
        entries.push({ 
          nickname: d.nickname || 'Unbekannt', 
          score: d.totalScore, 
          uid: d.uid 
        });
      }
    });
    
    if (mode === 'friends') entries = filterFriendsOnly(entries);
    entries = entries.slice(0,10);
    
    const listEl = document.getElementById('flagsRankingList');
    if (!listEl) return;
    
    if (entries.length === 0) { 
      listEl.innerHTML = '<p style=\"opacity:0.6;\">Keine Einträge</p>'; 
      return; 
    }
    
    let html = '<table style=\"width:100%; border-collapse:collapse;\">';
    html += '<tr style=\"background:#007bff; color:#fff;\"><th style=\"text-align:left; padding:6px;\">#</th><th style=\"text-align:left; padding:6px;\">Spieler</th><th style=\"text-align:right; padding:6px;\">Karriere-Punkte</th></tr>';
    entries.forEach((s,i)=>{
      html += `<tr style=\"border-bottom:1px solid #ddd;\"><td style=\"padding:5px;\">${i+1}</td><td style=\"padding:5px;\">${s.nickname}</td><td style=\"padding:5px; text-align:right; font-weight:bold;\">${s.score} 🌍</td></tr>`;
    });
    html += '</table>';
    listEl.innerHTML = html;
  } catch(e){ console.error('Flags Ranking Fehler', e); }
}

// Enter key support
document.addEventListener('DOMContentLoaded', () => {
  const flagsInput = document.getElementById('flagsInput');
  if (flagsInput) {
    flagsInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !flagsInput.disabled) {
        submitFlagsAnswer();
      }
    });
  }
  
    // Matchday Tips: no Enter handler needed (buttons per fixture)
});

///////////////////////////////////////////////////////////////////////////////
// FOOTBALL QUIZ GAME ⚽ (Vereine, Spieler, Trainer, Wettbewerbe)
/////////////////////////////////////////////////////////////////////////////

// Nur URLs die funktionieren!
const FOOTBALL_QUIZ_DATA = [
  // === VEREINE ===
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/5/53/Arsenal_FC.svg', name: 'Arsenal', alt: ['Arsenal', 'Arsenal FC', 'Gunners'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/c/cc/Chelsea_FC.svg', name: 'Chelsea', alt: ['Chelsea', 'Chelsea FC', 'Blues'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/7/7a/Manchester_United_FC_crest.svg', name: 'Manchester United', alt: ['Manchester United', 'Man United', 'ManU', 'United'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/e/eb/Manchester_City_FC_badge.svg', name: 'Manchester City', alt: ['Manchester City', 'Man City', 'City'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/0/0c/Liverpool_FC.svg', name: 'Liverpool', alt: ['Liverpool', 'Liverpool FC', 'LFC'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/4/47/FC_Barcelona_%28crest%29.svg', name: 'FC Barcelona', alt: ['Barcelona', 'Barca', 'FCB'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/5/56/Real_Madrid_CF.svg', name: 'Real Madrid', alt: ['Real Madrid', 'Madrid', 'Real'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/commons/1/1b/FC_Bayern_M%C3%BCnchen_logo_%282017%29.svg', name: 'Bayern München', alt: ['Bayern', 'Bayern München', 'Bayern Munich', 'FCB'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/commons/6/67/Borussia_Dortmund_logo.svg', name: 'Borussia Dortmund', alt: ['Dortmund', 'BVB'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/d/d3/Juventus_FC_-_pictogram_black_%28italy%29.svg', name: 'Juventus', alt: ['Juventus', 'Juve'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/commons/0/05/FC_Internazionale_Milano_2021.svg', name: 'Inter Mailand', alt: ['Inter', 'Inter Milan', 'Inter Mailand'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/commons/d/d0/Logo_of_AC_Milan.svg', name: 'AC Mailand', alt: ['Milan', 'AC Milan', 'AC Mailand'] },
  { type: 'club', img: 'https://upload.wikimedia.org/wikipedia/en/c/c1/Paris_Saint-Germain_F.C..svg', name: 'Paris Saint-Germain', alt: ['PSG', 'Paris'] },
  
  // === SPIELER (Fotos) ===
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Lionel-Messi-Argentina-2022-FIFA-World-Cup_%28cropped%29.jpg/330px-Lionel-Messi-Argentina-2022-FIFA-World-Cup_%28cropped%29.jpg', name: 'Lionel Messi', alt: ['Messi', 'Lionel Messi'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Cristiano_Ronaldo_playing_for_Al_Nassr_FC_against_Persepolis%2C_September_2023_%28cropped%29.jpg/330px-Cristiano_Ronaldo_playing_for_Al_Nassr_FC_against_Persepolis%2C_September_2023_%28cropped%29.jpg', name: 'Cristiano Ronaldo', alt: ['Ronaldo', 'Cristiano Ronaldo', 'CR7'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Neymar_Jr._with_Al_Hilal%2C_3_October_2023_-_3_%28cropped%29.jpg/330px-Neymar_Jr._with_Al_Hilal%2C_3_October_2023_-_3_%28cropped%29.jpg', name: 'Neymar', alt: ['Neymar', 'Neymar Jr'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Mbapp%C3%A9_WC2022.jpg/330px-Mbapp%C3%A9_WC2022.jpg', name: 'Kylian Mbappé', alt: ['Mbappe', 'Mbappé', 'Kylian Mbappe'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Erling_Haaland_2023_%28cropped%29.jpg/330px-Erling_Haaland_2023_%28cropped%29.jpg', name: 'Erling Haaland', alt: ['Haaland', 'Erling Haaland'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Kevin_De_Bruyne_202201_%28cropped%29.jpg/330px-Kevin_De_Bruyne_202201_%28cropped%29.jpg', name: 'Kevin De Bruyne', alt: ['De Bruyne', 'Kevin De Bruyne'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Mohamed_Salah_2018.jpg/330px-Mohamed_Salah_2018.jpg', name: 'Mohamed Salah', alt: ['Salah', 'Mohamed Salah', 'Mo Salah'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/Robert_Lewandowski_2018_%28cropped%29.jpg/330px-Robert_Lewandowski_2018_%28cropped%29.jpg', name: 'Robert Lewandowski', alt: ['Lewandowski', 'Robert Lewandowski'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Luka_Modric_2018_%28cropped%29.jpg/330px-Luka_Modric_2018_%28cropped%29.jpg', name: 'Luka Modrić', alt: ['Modric', 'Luka Modric', 'Modrić'] },
  { type: 'player', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Toni_Kroos_2018_%28cropped%29.jpg/330px-Toni_Kroos_2018_%28cropped%29.jpg', name: 'Toni Kroos', alt: ['Kroos', 'Toni Kroos'] },
  
  // === TRAINER ===
  { type: 'coach', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Pep_2017_%28cropped%29.jpg/330px-Pep_2017_%28cropped%29.jpg', name: 'Pep Guardiola', alt: ['Guardiola', 'Pep', 'Pep Guardiola'] },
  { type: 'coach', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/J%C3%BCrgen_Klopp%2C_Liverpool_vs._Chelsea%2C_UEFA_Super_Cup_2019-08-14_03_%28cropped%29.jpg/330px-J%C3%BCrgen_Klopp%2C_Liverpool_vs._Chelsea%2C_UEFA_Super_Cup_2019-08-14_03_%28cropped%29.jpg', name: 'Jürgen Klopp', alt: ['Klopp', 'Jürgen Klopp', 'Jurgen Klopp'] },
  { type: 'coach', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Carlo_Ancelotti_-_Portugal_vs._Italy%2C_10th_September_2018_%28cropped%29.jpg/330px-Carlo_Ancelotti_-_Portugal_vs._Italy%2C_10th_September_2018_%28cropped%29.jpg', name: 'Carlo Ancelotti', alt: ['Ancelotti', 'Carlo Ancelotti'] },
  { type: 'coach', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Xavi_Hern%C3%A1ndez_in_2022.jpg/330px-Xavi_Hern%C3%A1ndez_in_2022.jpg', name: 'Xavi', alt: ['Xavi', 'Xavi Hernandez', 'Xavi Hernández'] },
  { type: 'coach', img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Thomas_Tuchel_2018.jpg/330px-Thomas_Tuchel_2018.jpg', name: 'Thomas Tuchel', alt: ['Tuchel', 'Thomas Tuchel'] },
  
  // === WETTBEWERBE (Logos) ===
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/b/bf/UEFA_Champions_League_logo_2.svg', name: 'Champions League', alt: ['Champions League', 'UCL', 'CL'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/f/f2/Premier_League_Logo.svg', name: 'Premier League', alt: ['Premier League', 'EPL'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/commons/1/13/Laliga-logo-2023.svg', name: 'La Liga', alt: ['La Liga', 'LaLiga'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/d/df/Bundesliga_logo_%282017%29.svg', name: 'Bundesliga', alt: ['Bundesliga'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/e/e1/Serie_A_logo_2022.svg', name: 'Serie A', alt: ['Serie A'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/b/ba/Ligue_1_Logo.svg', name: 'Ligue 1', alt: ['Ligue 1'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/f/f2/UEFA_Euro_2024_Logo.svg', name: 'EM', alt: ['EM', 'Euro', 'Europameisterschaft', 'UEFA Euro'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/6/67/2022_FIFA_World_Cup.svg', name: 'WM', alt: ['WM', 'Weltmeisterschaft', 'World Cup', 'FIFA WM'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/1/15/DFB-Pokal_logo.svg', name: 'DFB Pokal', alt: ['DFB Pokal', 'DFB-Pokal', 'Pokal'] },
  { type: 'competition', img: 'https://upload.wikimedia.org/wikipedia/en/2/23/FA_Cup_logo_2023.svg', name: 'FA Cup', alt: ['FA Cup', 'FA-Cup'] }
];

const FOOTBALL_TYPE_LABELS = {
  club: '🏟️ VEREIN',
  player: '👤 SPIELER',
  coach: '📋 TRAINER',
  competition: '🏆 WETTBEWERB'
};

let footballCurrentIndex = 0;
let footballShuffled = [];
let footballScore = 0;
let footballTotalCoins = 0;
let footballGameActive = false;

function startFootballQuiz() {
  footballShuffled = [...FOOTBALL_QUIZ_DATA].sort(() => Math.random() - 0.5);
  footballCurrentIndex = 0;
  footballScore = 0;
  footballTotalCoins = 0;
  footballGameActive = true;
  
  document.getElementById('footballInput').disabled = false;
  document.getElementById('footballSubmitBtn').disabled = false;
  document.getElementById('footballSkipBtn').disabled = false;
  document.getElementById('footballReloadBtn').disabled = false;
  document.getElementById('footballFeedback').textContent = '';
  
  updateFootballDisplay();
  showNextFootball();
}
window.startFootballQuiz = startFootballQuiz;

function showNextFootball() {
  if (footballCurrentIndex >= footballShuffled.length) {
    endFootballQuiz();
    return;
  }
  
  const current = footballShuffled[footballCurrentIndex];
  displayFootballImage(current);
  document.getElementById('footballInput').value = '';
  document.getElementById('footballInput').focus();
  document.getElementById('footballFeedback').textContent = '';
  document.getElementById('footballTypeLabel').textContent = FOOTBALL_TYPE_LABELS[current.type] || '';
  updateFootballDisplay();
}

function displayFootballImage(item) {
  const displayEl = document.getElementById('footballDisplay');
  displayEl.innerHTML = '<div style="font-size:14px; opacity:0.7; padding:80px 0;">⚽ Lade Bild...</div>';
  
  const img = document.createElement('img');
  img.style.cssText = 'max-width:300px; max-height:300px; object-fit:contain; display:block; margin:0 auto; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.2);';
  img.alt = item.name;
  
  img.onload = () => {
    displayEl.innerHTML = '';
    displayEl.appendChild(img);
  };
  
  img.onerror = () => {
    displayEl.innerHTML = `
      <div style="
        width: 250px;
        height: 250px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        margin: 0 auto;
      ">
        <div style="font-size: 80px; color: white;">⚽</div>
      </div>
      <div style="font-size:14px; margin-top:10px; opacity:0.7;">Bild konnte nicht geladen werden</div>
    `;
  };
  
  img.src = item.img;
}

function reloadFootballImage() {
  if (!footballGameActive || footballCurrentIndex >= footballShuffled.length) return;
  
  const current = footballShuffled[footballCurrentIndex];
  displayFootballImage(current);
  
  document.getElementById('footballFeedback').innerHTML = '<span style="color:#17a2b8;">🔄 Bild wird neu geladen...</span>';
  setTimeout(() => {
    if (document.getElementById('footballFeedback').textContent.includes('neu geladen')) {
      document.getElementById('footballFeedback').textContent = '';
    }
  }, 1500);
}
window.reloadFootballImage = reloadFootballImage;

function updateFootballDisplay() {
  document.getElementById('footballScore').textContent = footballScore;
  document.getElementById('footballTotal').textContent = footballShuffled.length;
  document.getElementById('footballCoins').textContent = footballTotalCoins;
}

function submitFootballAnswer() {
  if (!footballGameActive) return;
  
  const userAnswer = document.getElementById('footballInput').value.trim().toLowerCase();
  if (!userAnswer) {
    document.getElementById('footballFeedback').innerHTML = '<span style="color:#e74c3c;">⚠️ Bitte eine Antwort eingeben!</span>';
    return;
  }
  
  const current = footballShuffled[footballCurrentIndex];
  const isCorrect = current.alt.some(alt => alt.toLowerCase() === userAnswer);
  
  const feedbackEl = document.getElementById('footballFeedback');
  
  if (isCorrect) {
    footballScore++;
    const coinReward = Math.floor(Math.random() * 3) + 3;
    footballTotalCoins += coinReward;
    feedbackEl.innerHTML = `<span style="color:#28a745;">✅ Richtig! +${coinReward} 🪙</span>`;
    playGameSound('success', 'football');
    
    setTimeout(() => {
      footballCurrentIndex++;
      showNextFootball();
    }, 800);
  } else {
    feedbackEl.innerHTML = `<span style="color:#e74c3c;">❌ Falsch! Das war: ${current.name}</span>`;
    playGameSound('fail', 'football');
    
    setTimeout(() => {
      footballCurrentIndex++;
      showNextFootball();
    }, 1500);
  }
  
  updateFootballDisplay();
}
window.submitFootballAnswer = submitFootballAnswer;

function skipFootball() {
  if (!footballGameActive) return;
  
  const current = footballShuffled[footballCurrentIndex];
  document.getElementById('footballFeedback').innerHTML = `<span style="color:#ffc107;">⏭️ Übersprungen: ${current.name}</span>`;
  
  setTimeout(() => {
    footballCurrentIndex++;
    showNextFootball();
  }, 800);
}
window.skipFootball = skipFootball;

async function endFootballQuiz() {
  footballGameActive = false;
  
  document.getElementById('footballInput').disabled = true;
  document.getElementById('footballSubmitBtn').disabled = true;
  document.getElementById('footballSkipBtn').disabled = true;
  document.getElementById('footballReloadBtn').disabled = true;
  
  const displayEl = document.getElementById('footballDisplay');
  displayEl.innerHTML = `
    <div style="padding:40px 20px; text-align:center;">
      <h3 style="font-size:24px; margin-bottom:15px;">🎉 Quiz beendet!</h3>
      <p style="font-size:18px; margin:10px 0;">Score: <strong>${footballScore}</strong> / ${footballShuffled.length}</p>
      <p style="font-size:18px; margin:10px 0;">Münzen verdient: <strong>${footballTotalCoins}</strong> 🪙</p>
    </div>
  `;
  
  document.getElementById('footballFeedback').innerHTML = '<span style="color:#28a745; font-size:16px;">Speichere Ergebnis...</span>';
  
  if (currentUser) {
    await addCoins(footballTotalCoins);
    await saveFootballHighscore(footballScore);
    await updateBPQuestProgress('gamesPlayed');
    await trackGamePlayed('football_quiz');
  }
  
  document.getElementById('footballFeedback').innerHTML = '<span style="color:#28a745; font-size:16px;">✅ Gespeichert!</span>';
  
  setTimeout(() => {
    document.getElementById('footballFeedback').textContent = '';
  }, 2000);
}

async function saveFootballHighscore(score) {
  if (!currentUser) return;
  
  try {
    const docRef = doc(db, 'footballCareerStats', currentUser.uid);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      await updateDoc(docRef, {
        totalScore: increment(score),
        lastPlayed: serverTimestamp()
      });
    } else {
      await setDoc(docRef, {
        uid: currentUser.uid,
        nickname: currentNickname || 'Anonym',
        totalScore: score,
        lastPlayed: serverTimestamp()
      });
    }
  } catch (err) {
    console.error('Football highscore error:', err);
  }
}

let currentFootballRankingMode = 'all';

window.openFootballRanking = async function() {
  document.getElementById('footballRankingModal').style.display = 'flex';
  currentFootballRankingMode = 'all';
  await loadFootballRankings();
};

window.closeFootballRanking = function() {
  document.getElementById('footballRankingModal').style.display = 'none';
};

window.switchFootballRankingTab = async function(mode) {
  currentFootballRankingMode = mode;
  document.getElementById('footballRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('footballRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  await loadFootballRankings();
};

async function loadFootballRankings() {
  const listEl = document.getElementById('footballRankingList');
  listEl.innerHTML = '<p style="text-align:center; padding:20px;">Lade Rangliste...</p>';
  
  try {
    let rankings = [];
    
    if (currentFootballRankingMode === 'all') {
      const q = query(collection(db, 'footballCareerStats'), orderBy('totalScore', 'desc'), limit(10));
      const snapshot = await getDocs(q);
      rankings = snapshot.docs.map(doc => doc.data());
    } else {
      if (!currentUser) {
        listEl.innerHTML = '<p style="text-align:center; padding:20px;">Bitte einloggen für Freundesliste.</p>';
        return;
      }
      
      const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
      const friendsList = userDoc.data()?.friends || [];
      
      if (friendsList.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; padding:20px;">Keine Freunde gefunden.</p>';
        return;
      }
      
      const friendsData = await Promise.all(
        friendsList.map(async (friendUid) => {
          const docSnap = await getDoc(doc(db, 'footballCareerStats', friendUid));
          return docSnap.exists() ? docSnap.data() : null;
        })
      );
      
      rankings = friendsData.filter(d => d !== null).sort((a, b) => b.totalScore - a.totalScore).slice(0, 10);
    }
    
    if (rankings.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; padding:20px;">Noch keine Einträge.</p>';
      return;
    }
    
    let html = '<table style="width:100%; border-collapse:collapse;">';
    html += '<thead><tr style="background:#f8f9fa;"><th style="padding:10px; text-align:left;">#</th><th style="padding:10px; text-align:left;">Spieler</th><th style="padding:10px; text-align:right;">⚽ Karriere-Punkte</th></tr></thead><tbody>';
    
    rankings.forEach((r, i) => {
      const medal = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : '';
      html += `<tr style="border-bottom:1px solid #dee2e6;"><td style="padding:10px;">${medal} ${i + 1}</td><td style="padding:10px;">${r.nickname}</td><td style="padding:10px; text-align:right; font-weight:bold;">${r.totalScore}</td></tr>`;
    });
    
    html += '</tbody></table>';
    listEl.innerHTML = html;
    
  } catch (err) {
    console.error('Football ranking error:', err);
    listEl.innerHTML = '<p style="text-align:center; padding:20px; color:red;">Fehler beim Laden.</p>';
  }
}

// OLD CLUBS QUIZ CODE - TO BE REMOVED
// Lines below contain old clubs quiz functions that are no longer used
const FOOTBALL_CLUBS = [
  // Premier League
  { emoji: '🔴⚪', colors: ['#EF0107', '#FFFFFF'], club: 'Arsenal', alt: ['Arsenal', 'Arsenal FC', 'Arsenal London', 'Gunners'] },
  { emoji: '🔵⚪', colors: ['#034694', '#FFFFFF'], club: 'Chelsea', alt: ['Chelsea', 'Chelsea FC', 'Chelsea London', 'Blues'] },
  { emoji: '🔴⚫', colors: ['#DA291C', '#000000'], club: 'Manchester United', alt: ['Manchester United', 'Man United', 'ManU', 'United', 'Red Devils'] },
  { emoji: '🔵⚪', colors: ['#6CABDD', '#FFFFFF'], club: 'Manchester City', alt: ['Manchester City', 'Man City', 'City', 'Citizens'] },
  { emoji: '🔴⚪', colors: ['#C8102E', '#FFFFFF'], club: 'Liverpool', alt: ['Liverpool', 'Liverpool FC', 'Reds', 'LFC'] },
  { emoji: '⚪🔵', colors: ['#FFFFFF', '#132257'], club: 'Tottenham', alt: ['Tottenham', 'Spurs', 'Tottenham Hotspur'] },
  { emoji: '🔵⚪', colors: ['#003090', '#FDBE11'], club: 'Leicester City', alt: ['Leicester', 'Leicester City', 'Foxes'] },
  { emoji: '⚫⚪', colors: ['#241F20', '#FFFFFF'], club: 'Newcastle United', alt: ['Newcastle', 'Newcastle United', 'Magpies'] },
  { emoji: '🔴🔵', colors: ['#7A263A', '#1BB1E7'], club: 'West Ham United', alt: ['West Ham', 'West Ham United', 'Hammers'] },
  { emoji: '🟠⚫', colors: ['#FDB913', '#231F20'], club: 'Wolverhampton', alt: ['Wolverhampton', 'Wolves', 'Wanderers'] },
  { emoji: '🔵⚪', colors: ['#003399', '#FFFFFF'], club: 'Everton', alt: ['Everton', 'Everton FC', 'Toffees'] },
  { emoji: '🔴⚪', colors: ['#D71920', '#FFFFFF'], club: 'Southampton', alt: ['Southampton', 'Saints', 'Southampton FC'] },
  { emoji: '🔴🔵', colors: ['#95BFE5', '#670E36'], club: 'Aston Villa', alt: ['Villa', 'Aston Villa', 'AVFC'] },
  { emoji: '🔴🔵', colors: ['#1B458F', '#C4122E'], club: 'Crystal Palace', alt: ['Palace', 'Crystal Palace'] },
  { emoji: '🔵⚪', colors: ['#0057B8', '#FFCD00'], club: 'Brighton', alt: ['Brighton', 'Brighton & Hove Albion', 'Seagulls'] },
  { emoji: '🔴⚪', colors: ['#D20000', '#FFFFFF'], club: 'Brentford', alt: ['Brentford', 'Brentford FC', 'Bees'] },
  { emoji: '⚪🔵', colors: ['#FFFFFF', '#1D428A'], club: 'Leeds United', alt: ['Leeds', 'Leeds United', 'LUFC'] },
  { emoji: '🔴⚪', colors: ['#DD0000', '#FFFFFF'], club: 'Nottingham Forest', alt: ['Nottingham', 'Forest', 'Nottingham Forest', 'NFFC'] },
  { emoji: '⚪⚫', colors: ['#FFFFFF', '#000000'], club: 'Fulham', alt: ['Fulham', 'Fulham FC'] },
  { emoji: '🔴⚫', colors: ['#DA291C', '#000000'], club: 'AFC Bournemouth', alt: ['Bournemouth', 'AFC Bournemouth', 'Cherries'] },
  
  // La Liga
  { emoji: '🔵🔴', colors: ['#004D98', '#A50044'], club: 'FC Barcelona', alt: ['Barcelona', 'Barca', 'FC Barcelona', 'FCB'] },
  { emoji: '⚪💜', colors: ['#FFFFFF', '#00529F'], club: 'Real Madrid', alt: ['Real Madrid', 'Madrid', 'Los Blancos'] },
  { emoji: '🔴⚪', colors: ['#CB3524', '#FFFFFF'], club: 'Atletico Madrid', alt: ['Atletico', 'Atletico Madrid', 'Atleti'] },
  { emoji: '🔵⚪', colors: ['#0064B5', '#FFFFFF'], club: 'Real Sociedad', alt: ['Real Sociedad', 'Sociedad'] },
  { emoji: '⚪🔴', colors: ['#FFFFFF', '#F43333'], club: 'Sevilla FC', alt: ['Sevilla', 'Sevilla FC'] },
  { emoji: '🟡🔵', colors: ['#FFED00', '#005187'], club: 'Villarreal', alt: ['Villarreal', 'Yellow Submarine'] },
  { emoji: '🔴⚪', colors: ['#EE2523', '#FFFFFF'], club: 'Athletic Bilbao', alt: ['Athletic', 'Bilbao', 'Athletic Bilbao'] },
  { emoji: '⚪🟠', colors: ['#FFFFFF', '#EE3524'], club: 'Valencia CF', alt: ['Valencia', 'Valencia CF'] },
  { emoji: '🟢⚪', colors: ['#00954C', '#FFFFFF'], club: 'Real Betis', alt: ['Betis', 'Real Betis'] },
  { emoji: '⚪💜', colors: ['#FFFFFF', '#A66AB8'], club: 'Real Valladolid', alt: ['Valladolid', 'Real Valladolid'] },
  { emoji: '🔴🔵', colors: ['#CA2C2B', '#00205B'], club: 'CA Osasuna', alt: ['Osasuna', 'CA Osasuna'] },
  { emoji: '🔵⚪', colors: ['#005999', '#FFFFFF'], club: 'Getafe CF', alt: ['Getafe', 'Getafe CF'] },
  
  // Bundesliga
  { emoji: '🔴⚪', colors: ['#DC052D', '#FFFFFF'], club: 'Bayern München', alt: ['Bayern', 'Bayern München', 'Bayern Munich', 'FCB'] },
  { emoji: '🟡⚫', colors: ['#FDE100', '#000000'], club: 'Borussia Dortmund', alt: ['Dortmund', 'BVB', 'Borussia Dortmund'] },
  { emoji: '🔴⚪', colors: ['#DD0741', '#FFFFFF'], club: 'RB Leipzig', alt: ['Leipzig', 'RB Leipzig', 'RasenBallsport'] },
  { emoji: '🔵⚪', colors: ['#004D9D', '#FFFFFF'], club: 'Schalke 04', alt: ['Schalke', 'S04', 'Schalke 04'] },
  { emoji: '🔴⚫', colors: ['#E32221', '#000000'], club: 'Bayer Leverkusen', alt: ['Leverkusen', 'Bayer', 'Bayer 04'] },
  { emoji: '🟢⚪', colors: ['#1D9053', '#FFFFFF'], club: 'Werder Bremen', alt: ['Bremen', 'Werder', 'Werder Bremen'] },
  { emoji: '🔵⚪', colors: ['#005CA9', '#FFFFFF'], club: 'Hertha BSC', alt: ['Hertha', 'Hertha Berlin', 'Hertha BSC'] },
  { emoji: '⚪🔴', colors: ['#FFFFFF', '#E30613'], club: 'VfB Stuttgart', alt: ['Stuttgart', 'VfB', 'VfB Stuttgart'] },
  { emoji: '⚫🟢', colors: ['#000000', '#00B140'], club: 'Borussia Mönchengladbach', alt: ['Gladbach', 'Mönchengladbach', 'BMG'] },
  { emoji: '🔴⚪', colors: ['#ED1C24', '#FFFFFF'], club: 'FC Köln', alt: ['Köln', 'FC Köln', 'Cologne'] },
  { emoji: '🔵⚪', colors: ['#005CA9', '#FFFFFF'], club: 'Hoffenheim', alt: ['Hoffenheim', 'TSG', 'TSG Hoffenheim'] },
  { emoji: '🔴⚫', colors: ['#E1000F', '#000000'], club: 'Eintracht Frankfurt', alt: ['Frankfurt', 'Eintracht', 'Eintracht Frankfurt'] },
  { emoji: '🟢⚪', colors: ['#65B32E', '#FFFFFF'], club: 'VfL Wolfsburg', alt: ['Wolfsburg', 'VfL', 'VfL Wolfsburg'] },
  { emoji: '🔴⚪', colors: ['#BA3733', '#FFFFFF'], club: 'FC Augsburg', alt: ['Augsburg', 'FC Augsburg', 'FCA'] },
  { emoji: '🔴⚫', colors: ['#E3000F', '#000000'], club: 'SC Freiburg', alt: ['Freiburg', 'SC Freiburg', 'SCF'] },
  { emoji: '🔴⚪', colors: ['#C3011E', '#FFFFFF'], club: 'FSV Mainz 05', alt: ['Mainz', 'FSV Mainz', 'Mainz 05'] },
  { emoji: '🔴⚪', colors: ['#EB1923', '#FFFFFF'], club: 'Union Berlin', alt: ['Union', 'Union Berlin', 'FC Union'] },
  
  // Serie A
  { emoji: '⚪⚫', colors: ['#FFFFFF', '#000000'], club: 'Juventus', alt: ['Juventus', 'Juve', 'Vecchia Signora'] },
  { emoji: '🔵⚫', colors: ['#0068A8', '#000000'], club: 'Inter Mailand', alt: ['Inter', 'Inter Milan', 'Inter Mailand', 'Internazionale'] },
  { emoji: '🔴⚫', colors: ['#FB090B', '#000000'], club: 'AC Mailand', alt: ['Milan', 'AC Milan', 'AC Mailand', 'Rossoneri'] },
  { emoji: '🔵⚪', colors: ['#00A3DD', '#FFFFFF'], club: 'SSC Neapel', alt: ['Napoli', 'Neapel', 'SSC Napoli'] },
  { emoji: '🟡🔴', colors: ['#FFC627', '#C8102E'], club: 'AS Rom', alt: ['Roma', 'AS Roma', 'AS Rom'] },
  { emoji: '🔵⚪', colors: ['#87D8F7', '#FFFFFF'], club: 'Lazio Rom', alt: ['Lazio', 'Lazio Roma', 'Lazio Rom'] },
  { emoji: '🔵⚫', colors: ['#1A8FD7', '#000000'], club: 'Atalanta', alt: ['Atalanta', 'Bergamo', 'Atalanta Bergamo'] },
  { emoji: '🔴🔵', colors: ['#001E62', '#9B2B3B'], club: 'FC Bologna', alt: ['Bologna', 'FC Bologna'] },
  { emoji: '🔵🔴', colors: ['#00529F', '#E72B1E'], club: 'Sampdoria', alt: ['Sampdoria', 'Samp'] },
  { emoji: '💜⚪', colors: ['#5F259F', '#FFFFFF'], club: 'AC Florenz', alt: ['Fiorentina', 'Florenz', 'AC Florenz'] },
  { emoji: '🔴⚪', colors: ['#8B1A10', '#FFFFFF'], club: 'FC Turin', alt: ['Torino', 'Turin', 'FC Torino'] },
  { emoji: '⚪⚫', colors: ['#FFFFFF', '#000000'], club: 'Udinese Calcio', alt: ['Udinese', 'Udinese Calcio'] },
  { emoji: '🔴🔵', colors: ['#972529', '#022969'], club: 'Genua CFC', alt: ['Genoa', 'Genua', 'Genoa CFC'] },
  { emoji: '🔴🔵', colors: ['#BF0F2C', '#0E2C60'], club: 'Cagliari Calcio', alt: ['Cagliari', 'Cagliari Calcio'] },
  
  // Ligue 1
  { emoji: '🔵🔴', colors: ['#004170', '#DA0037'], club: 'Paris Saint-Germain', alt: ['PSG', 'Paris', 'Paris Saint-Germain'] },
  { emoji: '🔵⚪', colors: ['#2FAEE0', '#FFFFFF'], club: 'Olympique Marseille', alt: ['Marseille', 'OM', 'Olympique Marseille'] },
  { emoji: '🔵🔴', colors: ['#DA0812', '#00387C'], club: 'Olympique Lyon', alt: ['Lyon', 'OL', 'Olympique Lyon'] },
  { emoji: '🔴⚪', colors: ['#E02028', '#FFFFFF'], club: 'AS Monaco', alt: ['Monaco', 'AS Monaco'] },
  { emoji: '🔴⚪', colors: ['#E30613', '#FFFFFF'], club: 'OSC Lille', alt: ['Lille', 'OSC', 'OSC Lille'] },
  { emoji: '🔴⚫', colors: ['#E2001A', '#000000'], club: 'Stade Rennes', alt: ['Rennes', 'Stade Rennes'] },
  { emoji: '🔴⚫', colors: ['#ED1C24', '#000000'], club: 'OGC Nice', alt: ['Nice', 'OGC Nice'] },
  { emoji: '🟡🔴', colors: ['#FFC500', '#CC0000'], club: 'RC Lens', alt: ['Lens', 'RC Lens'] },
  
  // Eredivisie
  { emoji: '🔴⚪', colors: ['#D2122E', '#FFFFFF'], club: 'Ajax Amsterdam', alt: ['Ajax', 'AFC Ajax', 'Amsterdam'] },
  { emoji: '🔴⚪', colors: ['#ED1B2E', '#FFFFFF'], club: 'PSV Eindhoven', alt: ['PSV', 'Eindhoven', 'PSV Eindhoven'] },
  { emoji: '🔴⚪', colors: ['#E30613', '#FFFFFF'], club: 'Feyenoord Rotterdam', alt: ['Feyenoord', 'Rotterdam'] },
  { emoji: '🔴⚪', colors: ['#C8102E', '#FFFFFF'], club: 'AZ Alkmaar', alt: ['AZ', 'Alkmaar', 'AZ Alkmaar'] },
  { emoji: '🔴⚪', colors: ['#E2001A', '#FFFFFF'], club: 'FC Twente', alt: ['Twente', 'FC Twente'] },
  
  // Liga Portugal
  { emoji: '🔴⚪', colors: ['#DA291C', '#FFFFFF'], club: 'Benfica Lissabon', alt: ['Benfica', 'SL Benfica', 'Benfica Lissabon'] },
  { emoji: '🔵⚪', colors: ['#003F87', '#FFFFFF'], club: 'FC Porto', alt: ['Porto', 'FC Porto', 'FCP'] },
  { emoji: '🟢⚪', colors: ['#00914A', '#FFFFFF'], club: 'Sporting Lissabon', alt: ['Sporting', 'Sporting CP', 'Sporting Lissabon'] },
  { emoji: '🔴⚪', colors: ['#AD162C', '#FFFFFF'], club: 'Sporting Braga', alt: ['Braga', 'Sporting Braga', 'SC Braga'] },
  
  // Other European Clubs
  { emoji: '🟢⚪', colors: ['#009966', '#FFFFFF'], club: 'Celtic Glasgow', alt: ['Celtic', 'Celtic Glasgow', 'Celtic FC'] },
  { emoji: '🔵🔴', colors: ['#0E4595', '#DB0032'], club: 'Rangers Glasgow', alt: ['Rangers', 'Rangers FC', 'Glasgow Rangers'] },
  { emoji: '🟡🔴', colors: ['#FBB800', '#A4113A'], club: 'Galatasaray', alt: ['Galatasaray', 'Gala', 'Galatasaray Istanbul'] },
  { emoji: '🟡🔵', colors: ['#FFED00', '#0B1E60'], club: 'Fenerbahce', alt: ['Fenerbahce', 'Fenerbahçe', 'Fener'] },
  { emoji: '⚫⚪', colors: ['#000000', '#FFFFFF'], club: 'Besiktas', alt: ['Besiktas', 'Beşiktaş', 'BJK'] },
  { emoji: '🔴🔵', colors: ['#ED1C24', '#002D72'], club: 'FC Basel', alt: ['Basel', 'FCB', 'FC Basel'] },
  { emoji: '🔴⚪', colors: ['#C50E2E', '#FFFFFF'], club: 'Red Bull Salzburg', alt: ['Salzburg', 'RB Salzburg', 'Red Bull Salzburg'] },
  { emoji: '⚫⚪', colors: ['#000000', '#FFFFFF'], club: 'SK Sturm Graz', alt: ['Sturm Graz', 'Sturm', 'SK Sturm'] },
  { emoji: '⚪💙', colors: ['#FFFFFF', '#002F6C'], club: 'FC Kopenhagen', alt: ['Kopenhagen', 'FC Kopenhagen', 'FCK'] },
  
  // South American Clubs
  { emoji: '🔴⚪', colors: ['#D6001C', '#FFFFFF'], club: 'River Plate', alt: ['River', 'River Plate', 'River Plate Buenos Aires'] },
  { emoji: '🔵🟡', colors: ['#00358E', '#FFDF00'], club: 'Boca Juniors', alt: ['Boca', 'Boca Juniors'] },
  { emoji: '⚪⚫', colors: ['#FFFFFF', '#000000'], club: 'Corinthians', alt: ['Corinthians', 'SC Corinthians'] },
  { emoji: '⚪⚫', colors: ['#FFFFFF', '#000000'], club: 'Santos FC', alt: ['Santos', 'Santos FC'] },
  { emoji: '🔴⚫', colors: ['#E20E16', '#000000'], club: 'Flamengo', alt: ['Flamengo', 'CR Flamengo'] },
  { emoji: '🔴⚫', colors: ['#DA020E', '#000000'], club: 'São Paulo FC', alt: ['São Paulo', 'Sao Paulo', 'SPFC'] },
  { emoji: '🔵⚪', colors: ['#033E8C', '#FFFFFF'], club: 'Cruzeiro', alt: ['Cruzeiro', 'Cruzeiro EC'] },
  { emoji: '🟢⚪', colors: ['#006437', '#FFFFFF'], club: 'Palmeiras', alt: ['Palmeiras', 'SE Palmeiras'] },
  { emoji: '🟡🔵', colors: ['#FBE117', '#004D98'], club: 'Club América', alt: ['America', 'Club America', 'América'] },
  { emoji: '🔴⚪', colors: ['#E1282B', '#FFFFFF'], club: 'Chivas Guadalajara', alt: ['Chivas', 'Guadalajara', 'Chivas Guadalajara'] },
  { emoji: '🔵🟡', colors: ['#041E42', '#FFCB05'], club: 'UNAM Pumas', alt: ['Pumas', 'UNAM', 'Pumas UNAM'] }
];

let clubsCurrentIndex = 0;
let clubsShuffledClubs = [];
let clubsScore = 0;
let clubsTotalCoins = 0;
let clubsGameActive = false;

function startClubsQuiz() {
  clubsShuffledClubs = [...FOOTBALL_CLUBS].sort(() => Math.random() - 0.5);
  clubsCurrentIndex = 0;
  clubsScore = 0;
  clubsTotalCoins = 0;
  clubsGameActive = true;
  
  document.getElementById('clubsInput').disabled = false;
  document.getElementById('clubsSubmitBtn').disabled = false;
  document.getElementById('clubsSkipBtn').disabled = false;
  document.getElementById('clubsReloadBtn').disabled = false;
  document.getElementById('clubsFeedback').textContent = '';
  
  updateClubsDisplay();
  showNextClub();
}
window.startClubsQuiz = startClubsQuiz;

function showNextClub() {
  if (clubsCurrentIndex >= clubsShuffledClubs.length) {
    endClubsQuiz();
    return;
  }
  
  const current = clubsShuffledClubs[clubsCurrentIndex];
  displayClubBadge(current);
  document.getElementById('clubsInput').value = '';
  document.getElementById('clubsInput').focus();
  document.getElementById('clubsFeedback').textContent = '';
  updateClubsDisplay();
}

function displayClubBadge(club) {
  const clubDisplayEl = document.getElementById('clubDisplay');
  
  // Erstelle ein stylisches Badge mit den Vereinsfarben und Emoji
  clubDisplayEl.innerHTML = `
    <div style="
      width: 200px;
      height: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, ${club.colors[0]} 0%, ${club.colors[1]} 100%);
      border-radius: 50%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      margin: 20px auto;
      position: relative;
      overflow: hidden;
    ">
      <div style="
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2) 0%, transparent 60%);
      "></div>
      <div style="
        font-size: 72px;
        margin-bottom: 10px;
        position: relative;
        z-index: 1;
        text-shadow: 2px 2px 8px rgba(0,0,0,0.4);
      ">${club.emoji}</div>
    </div>
  `;
}

function reloadClubLogo() {
  if (!clubsGameActive || clubsCurrentIndex >= clubsShuffledClubs.length) return;
  
  const current = clubsShuffledClubs[clubsCurrentIndex];
  displayClubBadge(current);
  
  document.getElementById('clubsFeedback').innerHTML = '<span style="color:#17a2b8;">🔄 Wappen neu geladen!</span>';
  setTimeout(() => {
    if (document.getElementById('clubsFeedback').textContent.includes('neu geladen')) {
      document.getElementById('clubsFeedback').textContent = '';
    }
  }, 1500);
}
window.reloadClubLogo = reloadClubLogo;

function submitClubsAnswer() {
  if (!clubsGameActive) return;
  
  const userAnswer = document.getElementById('clubsInput').value.trim().toLowerCase();
  if (!userAnswer) {
    document.getElementById('clubsFeedback').innerHTML = '<span style=\"color:#e74c3c;\">⚠️ Bitte einen Verein eingeben!</span>';
    return;
  }
  
  const current = clubsShuffledClubs[clubsCurrentIndex];
  const isCorrect = current.alt.some(alt => alt.toLowerCase() === userAnswer);
  
  const feedbackEl = document.getElementById('clubsFeedback');
  
  if (isCorrect) {
    clubsScore++;
    const coinReward = Math.floor(Math.random() * 3) + 3; // Random 3-5 coins
    clubsTotalCoins += coinReward;
    feedbackEl.innerHTML = `<span style=\"color:#28a745;\">✅ Richtig! +${coinReward} 🪙</span>`;
    playGameSound('success', 'clubs');
    
    setTimeout(() => {
      clubsCurrentIndex++;
      showNextClub();
    }, 800);
  } else {
    feedbackEl.innerHTML = `<span style=\"color:#e74c3c;\">❌ Falsch! Das war ${current.club}</span>`;
    playGameSound('fail', 'clubs');
    
    setTimeout(() => {
      clubsCurrentIndex++;
      showNextClub();
    }, 1500);
  }
  
  updateClubsDisplay();
}
window.submitClubsAnswer = submitClubsAnswer;

function skipClub() {
  if (!clubsGameActive) return;
  
  const current = clubsShuffledClubs[clubsCurrentIndex];
  document.getElementById('clubsFeedback').innerHTML = `<span style=\"color:#ffc107;\">⏭️ Übersprungen: ${current.club}</span>`;
  
  setTimeout(() => {
    clubsCurrentIndex++;
    showNextClub();
  }, 800);
}
window.skipClub = skipClub;

function updateClubsDisplay() {
  document.getElementById('clubsScore').textContent = clubsScore;
  document.getElementById('clubsTotal').textContent = clubsShuffledClubs.length;
  document.getElementById('clubsCoins').textContent = clubsTotalCoins;
}

async function endClubsQuiz() {
  clubsGameActive = false;
  
  document.getElementById('clubsInput').disabled = true;
  document.getElementById('clubsSubmitBtn').disabled = true;
  document.getElementById('clubsSkipBtn').disabled = true;
  document.getElementById('clubDisplay').textContent = '🏆';
  
  const percentage = Math.round((clubsScore / clubsShuffledClubs.length) * 100);
  document.getElementById('clubsFeedback').innerHTML = `
    <div style=\"background:#28a745; color:#fff; padding:15px; border-radius:8px; margin-top:10px;\">
      <h3 style=\"margin:0 0 10px 0;\">🎉 Quiz beendet!</h3>
      <p style=\"margin:5px 0;\"><strong>${clubsScore}</strong> / ${clubsShuffledClubs.length} richtig (${percentage}%)</p>
      <p style=\"margin:5px 0;\">Verdient: <strong>${clubsTotalCoins} 🪙</strong></p>
    </div>
  `;
  
  playGameSound('win', 'clubs');
  
  // Add coins
  if (clubsTotalCoins > 0) {
    await addCoins(clubsTotalCoins);
  }
  
  // Save to Firestore
  await saveClubsHighscore(clubsScore);
  
  // Quest progress
  await updateBPQuestProgress('gamesPlayed', 1);
  await trackGamePlayed('clubs');
}

async function saveClubsHighscore(score) {
  if (!currentUser) return;
  try {
    // Reference to user's career stats document
    const userStatsRef = doc(db, 'clubsCareerStats', currentUser.uid);
    const userStatsSnap = await getDoc(userStatsRef);
    
    if (userStatsSnap.exists()) {
      // Update existing career stats
      const currentTotal = userStatsSnap.data().totalScore || 0;
      await updateDoc(userStatsRef, {
        totalScore: currentTotal + score,
        nickname: currentNickname || 'Unbekannt',
        lastPlayed: Date.now()
      });
    } else {
      // Create new career stats document
      await setDoc(userStatsRef, {
        uid: currentUser.uid,
        nickname: currentNickname || 'Unbekannt',
        totalScore: score,
        lastPlayed: Date.now()
      });
    }
  } catch(e){ console.error('Clubs Highscore Fehler', e); }
}

// Ranking
window.openClubsRanking = async function() {
  document.getElementById('clubsRankingModal').style.display = 'flex';
  await loadClubsRankings('all');
};

window.closeClubsRanking = function() {
  document.getElementById('clubsRankingModal').style.display = 'none';
};

window.switchClubsRankingTab = async function(mode) {
  currentClubsRankingMode = mode;
  document.getElementById('clubsRankingTabAll').style.background = mode === 'all' ? '#007bff' : '#6c757d';
  document.getElementById('clubsRankingTabFriends').style.background = mode === 'friends' ? '#007bff' : '#6c757d';
  await loadClubsRankings(mode);
};

async function loadClubsRankings(mode) {
  try {
    const snapshot = await getDocs(query(collection(db,'clubsCareerStats'), orderBy('totalScore','desc'), limit(50)));
    let entries = [];
    snapshot.forEach(docSnap => {
      const d = docSnap.data();
      if (typeof d.totalScore === 'number') {
        entries.push({ 
          nickname: d.nickname || 'Unbekannt', 
          score: d.totalScore, 
          uid: d.uid 
        });
      }
    });
    
    if (mode === 'friends') entries = filterFriendsOnly(entries);
    entries = entries.slice(0,10);
    
    const listEl = document.getElementById('clubsRankingList');
    if (!listEl) return;
    
    if (entries.length === 0) { 
      listEl.innerHTML = '<p style=\"opacity:0.6;\">Keine Einträge</p>'; 
      return; 
    }
    
    let html = '<table style=\"width:100%; border-collapse:collapse;\">';
    html += '<tr style=\"background:#007bff; color:#fff;\"><th style=\"text-align:left; padding:6px;\">#</th><th style=\"text-align:left; padding:6px;\">Spieler</th><th style=\"text-align:right; padding:6px;\">Karriere-Punkte</th></tr>';
    entries.forEach((s,i)=>{
      html += `<tr style=\"border-bottom:1px solid #ddd;\"><td style=\"padding:5px;\">${i+1}</td><td style=\"padding:5px;\">${s.nickname}</td><td style=\"padding:5px; text-align:right; font-weight:bold;\">${s.score} ⚽</td></tr>`;
    });
    html += '</table>';
    listEl.innerHTML = html;
  } catch(e){ console.error('Clubs Ranking Fehler', e); }
}

/////////////////////////////////////////////////////////////////////////////

window.startMemory = startMemory;
window.resetMemory = resetMemory;

if (document.getElementById('memoryGrid')) { startMemory(); }

const BP_TIERS = [
  { tier: 1, pointsNeeded: 100, freeReward: { type: 'coins', value: 50 }, paidReward: { type: 'coins', value: 100 } },
  { tier: 2, pointsNeeded: 250, freeReward: { type: 'coins', value: 75 }, paidReward: { type: 'exclusive-color', value: { id: 'santa_red', name: 'Santa Red', color: '#D32F2F' } } },
  { tier: 3, pointsNeeded: 450, freeReward: { type: 'coins', value: 100 }, paidReward: { type: 'coins', value: 200 } },
  { tier: 4, pointsNeeded: 700, freeReward: { type: 'badge', value: { id: 'december_bronze', name: 'Dezember Bronze', icon: '❄️' } }, paidReward: { type: 'exclusive-theme', value: { id: 'winter_wonderland', name: 'Winter Wonderland' } } },
  { tier: 5, pointsNeeded: 1000, freeReward: { type: 'coins', value: 150 }, paidReward: { type: 'coins', value: 300 } },
  { tier: 6, pointsNeeded: 1400, freeReward: { type: 'coins', value: 200 }, paidReward: { type: 'exclusive-color', value: { id: 'holly_green', name: 'Holly Green', color: '#1B5E20' } } },
  { tier: 7, pointsNeeded: 1900, freeReward: { type: 'badge', value: { id: 'december_silver', name: 'Dezember Silber', icon: '🎄' } }, paidReward: { type: 'coins', value: 400 } },
  { tier: 8, pointsNeeded: 2500, freeReward: { type: 'coins', value: 250 }, paidReward: { type: 'exclusive-theme', value: { id: 'candy_cane', name: 'Candy Cane' } } },
  { tier: 9, pointsNeeded: 3200, freeReward: { type: 'badge', value: { id: 'december_gold', name: 'Dezember Gold', icon: '⭐' } }, paidReward: { type: 'exclusive-color', value: { id: 'icy_blue', name: 'Icy Blue', color: '#B3E5FC' } } },
  { tier: 10, pointsNeeded: 4000, freeReward: { type: 'exclusive-theme', value: { id: 'frosty_night', name: 'Frosty Night' } }, paidReward: { type: 'badge', value: { id: 'december_legend', name: 'Dezember Legende', icon: '🎅' } } }
];

const DAILY_QUEST_POOL = [
  // Snake Quests
  { id: 'snake50', name: 'Snake Anfänger', description: 'Erreiche 50+ Punkte in Snake', target: 50, points: 50, type: 'snakeScore', questType: 'daily' },
  { id: 'snake30', name: 'Schnelle Schlange', description: 'Erreiche 30+ Punkte in Snake', target: 30, points: 40, type: 'snakeScore', questType: 'daily' },
  { id: 'snake75', name: 'Snake Fortgeschritten', description: 'Erreiche 75+ Punkte in Snake', target: 75, points: 65, type: 'snakeScore', questType: 'daily' },
  
  // Flappy Bird Quests
  { id: 'flappy20', name: 'Flappy Start', description: 'Erreiche 20+ Punkte in Flappy Bird', target: 20, points: 50, type: 'flappyScore', questType: 'daily' },
  { id: 'flappy15', name: 'Flatternder Vogel', description: 'Erreiche 15+ Punkte in Flappy Bird', target: 15, points: 40, type: 'flappyScore', questType: 'daily' },
  { id: 'flappy35', name: 'Flappy Talent', description: 'Erreiche 35+ Punkte in Flappy Bird', target: 35, points: 60, type: 'flappyScore', questType: 'daily' },
  
  // Chat Quests
  { id: 'chat5', name: 'Chatterer', description: 'Schreibe 5 Chat-Nachrichten', target: 5, points: 40, type: 'chatMessages', questType: 'daily' },
  { id: 'chat3', name: 'Gesprächig', description: 'Schreibe 3 Chat-Nachrichten', target: 3, points: 30, type: 'chatMessages', questType: 'daily' },
  { id: 'chat10', name: 'Viel-Schreiber', description: 'Schreibe 10 Chat-Nachrichten', target: 10, points: 60, type: 'chatMessages', questType: 'daily' },
  
  // Slot Machine Quests
  { id: 'slot100', name: 'Slot Spieler', description: 'Gewinne 100 Münzen an Slots', target: 100, points: 60, type: 'slotWins', questType: 'daily' },
  { id: 'slot50', name: 'Glückspilz', description: 'Gewinne 50 Münzen an Slots', target: 50, points: 45, type: 'slotWins', questType: 'daily' },
  { id: 'slot200', name: 'Slot Ass', description: 'Gewinne 200 Münzen an Slots', target: 200, points: 70, type: 'slotWins', questType: 'daily' },
  
  // TicTacToe Quests
  { id: 'ttt2', name: 'TicTacToe Starter', description: 'Gewinne 2 KI-Spiele', target: 2, points: 50, type: 'tttWins', questType: 'daily' },
  { id: 'ttt1', name: 'Erster Sieg', description: 'Gewinne 1 KI-Spiel', target: 1, points: 35, type: 'tttWins', questType: 'daily' },
  { id: 'ttt3', name: 'TicTacToe Fan', description: 'Gewinne 3 KI-Spiele', target: 3, points: 65, type: 'tttWins', questType: 'daily' },
  
  // Coin Collection Quests
  { id: 'coins100', name: 'Münzsammler', description: 'Verdiene 100 Münzen', target: 100, points: 60, type: 'coinsEarned', questType: 'daily' },
  { id: 'coins50', name: 'Kleine Kasse', description: 'Verdiene 50 Münzen', target: 50, points: 40, type: 'coinsEarned', questType: 'daily' },
  { id: 'coins150', name: 'Geldjäger', description: 'Verdiene 150 Münzen', target: 150, points: 70, type: 'coinsEarned', questType: 'daily' },
  
  // Tower Stack Quests
  { id: 'tower5', name: 'Stapel-Start', description: 'Erreiche Score 5 in Tower Stack', target: 5, points: 50, type: 'towerScore', questType: 'daily' },
  { id: 'tower3', name: 'Bauanfänger', description: 'Erreiche Score 3 in Tower Stack', target: 3, points: 35, type: 'towerScore', questType: 'daily' },
  { id: 'tower8', name: 'Stapelmeister', description: 'Erreiche Score 8 in Tower Stack', target: 8, points: 65, type: 'towerScore', questType: 'daily' },
  
  // Sudoku Quests
  { id: 'sudoku1', name: 'Sudoku Löser', description: 'Löse 1 Sudoku', target: 1, points: 70, type: 'sudoku', questType: 'daily' },
  { id: 'sudoku2', name: 'Rätsel-Fan', description: 'Löse 2 Sudokus', target: 2, points: 90, type: 'sudoku', questType: 'daily' },
  
  // Penalty Quests
  { id: 'penalty3', name: 'Elfmeter-Schütze', description: 'Erziele 3 Tore in einem Spiel', target: 3, points: 55, type: 'penaltyGoals', questType: 'daily' },
  { id: 'penalty4', name: 'Torgefährlich', description: 'Erziele 4 Tore in einem Spiel', target: 4, points: 70, type: 'penaltyGoals', questType: 'daily' },
  
  // Mixed Quests
  { id: 'games3', name: 'Vielspieler', description: 'Spiele 3 verschiedene Spiele', target: 3, points: 55, type: 'gamesPlayed', questType: 'daily' },
  { id: 'games2', name: 'Abwechslung', description: 'Spiele 2 verschiedene Spiele', target: 2, points: 40, type: 'gamesPlayed', questType: 'daily' }
];

const WEEKLY_QUEST_POOL = [
  // Snake Quests
  { id: 'snake200', name: 'Snake Meister', description: 'Erreiche 200+ Punkte in Snake', target: 200, points: 200, type: 'snakeScore', questType: 'weekly' },
  { id: 'snake150', name: 'Schlangen-König', description: 'Erreiche 150+ Punkte in Snake', target: 150, points: 180, type: 'snakeScore', questType: 'weekly' },
  { id: 'snake300', name: 'Snake Legende', description: 'Erreiche 300+ Punkte in Snake', target: 300, points: 250, type: 'snakeScore', questType: 'weekly' },
  
  // Flappy Bird Quests
  { id: 'flappy100', name: 'Flappy Experte', description: 'Erreiche 100+ Punkte in Flappy Bird', target: 100, points: 200, type: 'flappyScore', questType: 'weekly' },
  { id: 'flappy75', name: 'Flappy Ass', description: 'Erreiche 75+ Punkte in Flappy Bird', target: 75, points: 180, type: 'flappyScore', questType: 'weekly' },
  { id: 'flappy150', name: 'Flugmeister', description: 'Erreiche 150+ Punkte in Flappy Bird', target: 150, points: 250, type: 'flappyScore', questType: 'weekly' },
  
  // Chat Quests
  { id: 'chat30', name: 'Plaudertasche', description: 'Schreibe 30 Chat-Nachrichten', target: 30, points: 180, type: 'chatMessages', questType: 'weekly' },
  { id: 'chat50', name: 'Kommunikations-Profi', description: 'Schreibe 50 Chat-Nachrichten', target: 50, points: 220, type: 'chatMessages', questType: 'weekly' },
  
  // Slot Machine Quests
  { id: 'slot1000', name: 'Slot Champion', description: 'Gewinne 1000 Münzen an Slots', target: 1000, points: 250, type: 'slotWins', questType: 'weekly' },
  { id: 'slot600', name: 'Casino Stammgast', description: 'Gewinne 600 Münzen an Slots', target: 600, points: 200, type: 'slotWins', questType: 'weekly' },
  { id: 'slot1500', name: 'Jackpot König', description: 'Gewinne 1500 Münzen an Slots', target: 1500, points: 280, type: 'slotWins', questType: 'weekly' },
  { id: 'jackpot', name: 'Jackpot-Jäger', description: 'Treffe einen Jackpot an Slots', target: 1, points: 300, type: 'jackpot', questType: 'weekly' },
  
  // TicTacToe Quests
  { id: 'ttt10', name: 'TicTacToe Profi', description: 'Gewinne 10 Spiele', target: 10, points: 200, type: 'tttWins', questType: 'weekly' },
  { id: 'ttt7', name: 'Strategie-Experte', description: 'Gewinne 7 Spiele', target: 7, points: 170, type: 'tttWins', questType: 'weekly' },
  { id: 'ttt15', name: 'TicTacToe Champion', description: 'Gewinne 15 Spiele', target: 15, points: 240, type: 'tttWins', questType: 'weekly' },
  
  // Coin Collection Quests
  { id: 'coins500', name: 'Münz-Magnat', description: 'Verdiene 500 Münzen', target: 500, points: 250, type: 'coinsEarned', questType: 'weekly' },
  { id: 'coins300', name: 'Reich werden', description: 'Verdiene 300 Münzen', target: 300, points: 190, type: 'coinsEarned', questType: 'weekly' },
  { id: 'coins800', name: 'Münz-Imperium', description: 'Verdiene 800 Münzen', target: 800, points: 280, type: 'coinsEarned', questType: 'weekly' },
  
  // Tower Stack Quests
  { id: 'tower20', name: 'Turmbauer', description: 'Erreiche Score 20 in Tower Stack', target: 20, points: 200, type: 'towerScore', questType: 'weekly' },
  { id: 'tower15', name: 'Hoher Turm', description: 'Erreiche Score 15 in Tower Stack', target: 15, points: 180, type: 'towerScore', questType: 'weekly' },
  { id: 'tower25', name: 'Wolkenkratzer', description: 'Erreiche Score 25 in Tower Stack', target: 25, points: 240, type: 'towerScore', questType: 'weekly' },
  
  // Sudoku Quests
  { id: 'sudoku3', name: 'Sudoku Meister', description: 'Löse 3 Sudokus', target: 3, points: 220, type: 'sudoku', questType: 'weekly' },
  { id: 'sudoku5', name: 'Rätsel-Champion', description: 'Löse 5 Sudokus', target: 5, points: 270, type: 'sudoku', questType: 'weekly' },
  
  // Penalty Quests
  { id: 'penalty5', name: 'Elfmeter-Perfektionist', description: 'Erziele 5/5 Tore', target: 5, points: 220, type: 'penaltyGoals', questType: 'weekly' },
  { id: 'penalty15', name: 'Straf-König', description: 'Erziele 15 Tore total', target: 15, points: 250, type: 'penaltyGoals', questType: 'weekly' },
  
  // Mixed Quests
  { id: 'games5', name: 'Allrounder', description: 'Spiele 5 verschiedene Spiele', target: 5, points: 200, type: 'gamesPlayed', questType: 'weekly' }
];

let battlePassData = {
  isPremium: false,
  currentTier: 0,
  points: 0,
  claimedTiers: [],
  dailyQuests: [],
  weeklyQuests: [],
  questProgress: {},
  claimedQuests: [],
  lastQuestRefresh: null,
  lastWeeklyRefresh: null,
  currentMonth: null,
  currentYear: null
};

// Generiere 3 zufällige Daily Quests
function generateDailyQuests() {
  const shuffled = [...DAILY_QUEST_POOL].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, 3);
}

// Generiere 3 zufällige Weekly Quests
function generateWeeklyQuests() {
  const shuffled = [...WEEKLY_QUEST_POOL].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, 3);
}

// Prüfe ob Quests um 15:00 deutscher Zeit refreshed werden sollen
function shouldRefreshQuests() {
  if (!battlePassData.lastQuestRefresh) return true;
  
  const now = new Date();
  const lastRefresh = new Date(battlePassData.lastQuestRefresh);
  
  // Deutsche Zeit: UTC+1 (Winterzeit) oder UTC+2 (Sommerzeit)
  const germanTime = new Date(now.toLocaleString('en-US', { timeZone: 'Europe/Berlin' }));
  const lastRefreshGerman = new Date(lastRefresh.toLocaleString('en-US', { timeZone: 'Europe/Berlin' }));
  
  // Prüfe ob es ein neuer Tag ist UND es nach 15:00 Uhr ist
  const isDifferentDay = germanTime.getDate() !== lastRefreshGerman.getDate() || 
                         germanTime.getMonth() !== lastRefreshGerman.getMonth() ||
                         germanTime.getFullYear() !== lastRefreshGerman.getFullYear();
  
  if (isDifferentDay && germanTime.getHours() >= 15) {
    return true;
  }
  
  return false;
}

// Prüfe ob wöchentliche Quests refreshed werden sollen (jeden Montag)
function shouldRefreshWeeklyQuests() {
  if (!battlePassData.lastWeeklyRefresh) return true;
  
  const now = new Date();
  const lastRefresh = new Date(battlePassData.lastWeeklyRefresh);
  
  // Deutsche Zeit
  const germanTime = new Date(now.toLocaleString('en-US', { timeZone: 'Europe/Berlin' }));
  const lastRefreshGerman = new Date(lastRefresh.toLocaleString('en-US', { timeZone: 'Europe/Berlin' }));
  
  // Prüfe ob es eine neue Woche ist (Montag = 1)
  const currentWeekDay = germanTime.getDay();
  const lastWeekDay = lastRefreshGerman.getDay();
  
  // Wenn heute Montag ist und letzter Refresh nicht diese Woche war
  if (currentWeekDay === 1 && germanTime.getTime() - lastRefreshGerman.getTime() > 24 * 60 * 60 * 1000) {
    return true;
  }
  
  // Oder wenn mehr als 7 Tage vergangen sind
  if (germanTime.getTime() - lastRefreshGerman.getTime() > 7 * 24 * 60 * 60 * 1000) {
    return true;
  }
  
  return false;
}

// Lade Battle Pass Daten und prüfe monatlichen Reset
async function loadBattlePassData() {
  if (!currentUser) return;
  
  try {
    const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
    if (userDoc.exists() && userDoc.data().battlePass) {
      battlePassData = userDoc.data().battlePass;
    }
    
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    // Monatlicher Reset
    if (battlePassData.currentMonth !== currentMonth || battlePassData.currentYear !== currentYear) {
      battlePassData = {
        isPremium: false,
        currentTier: 0,
        points: 0,
        claimedTiers: [],
        dailyQuests: generateDailyQuests(),
        weeklyQuests: generateWeeklyQuests(),
        questProgress: {},
        claimedQuests: [],
        lastQuestRefresh: now.toISOString(),
        lastWeeklyRefresh: now.toISOString(),
        currentMonth: currentMonth,
        currentYear: currentYear
      };
      await saveBattlePassData();
    }
    
    // Daily Quest Refresh um 15:00 deutsche Zeit
    if (shouldRefreshQuests()) {
      battlePassData.dailyQuests = generateDailyQuests();
      // Lösche nur tägliche Quest Progress und Claims
      const dailyQuestIds = battlePassData.dailyQuests.map(q => q.id);
      Object.keys(battlePassData.questProgress).forEach(key => {
        if (!key.startsWith('weekly_')) {
          delete battlePassData.questProgress[key];
        }
      });
      // Lösche auch tägliche Quest Claims
      if (!battlePassData.claimedQuests) battlePassData.claimedQuests = [];
      battlePassData.claimedQuests = battlePassData.claimedQuests.filter(qid => qid.startsWith('weekly_'));
      battlePassData.lastQuestRefresh = now.toISOString();
      await saveBattlePassData();
    }
    
    // Weekly Quest Refresh (jeden Montag)
    if (shouldRefreshWeeklyQuests()) {
      battlePassData.weeklyQuests = generateWeeklyQuests();
      // Lösche nur wöchentliche Quest Progress und Claims
      Object.keys(battlePassData.questProgress).forEach(key => {
        if (key.startsWith('weekly_')) {
          delete battlePassData.questProgress[key];
        }
      });
      // Lösche auch wöchentliche Quest Claims
      if (!battlePassData.claimedQuests) battlePassData.claimedQuests = [];
      battlePassData.claimedQuests = battlePassData.claimedQuests.filter(qid => !qid.startsWith('weekly_'));
      battlePassData.lastWeeklyRefresh = now.toISOString();
      await saveBattlePassData();
    }
    
    // Initiale Quests wenn keine vorhanden
    if (!battlePassData.dailyQuests || battlePassData.dailyQuests.length === 0) {
      battlePassData.dailyQuests = generateDailyQuests();
      battlePassData.lastQuestRefresh = now.toISOString();
      await saveBattlePassData();
    }
    
    if (!battlePassData.weeklyQuests || battlePassData.weeklyQuests.length === 0) {
      battlePassData.weeklyQuests = generateWeeklyQuests();
      battlePassData.lastWeeklyRefresh = now.toISOString();
      await saveBattlePassData();
    }
    
    displayBattlePass();
  } catch (e) {
    console.error('Battle Pass Ladefehler:', e);
  }
}

// Speichere Battle Pass Daten
async function saveBattlePassData() {
  if (!currentUser) return;
  
  try {
    await setDoc(doc(db, 'users', currentUser.uid), {
      battlePass: battlePassData
    }, { merge: true });
  } catch (e) {
    console.error('Battle Pass Speicherfehler:', e);
  }
}

// Aktiviere Premium für 500 Coins
window.activateBattlePassPremium = async function() {
  if (!currentUser) {
    showNotification('Fehler', 'Bitte einloggen!');
    return;
  }
  
  if (battlePassData.isPremium) {
    showNotification('Bereits Premium', 'Du hast bereits Premium aktiviert!');
    return;
  }
  
  if (userCoins < 500) {
    showNotification('Nicht genug Münzen', 'Du brauchst 500 Münzen für Premium!');
    return;
  }
  
  await addCoins(-500);
  battlePassData.isPremium = true;
  await saveBattlePassData();
  displayBattlePass();
  
  showNotification('Premium aktiviert! 💎', 'Du hast jetzt Zugriff auf alle Premium-Belohnungen!');
};

// Quest abschließen
window.completeBPQuest = async function(questId) {
  if (!currentUser) return;
  
  const quest = battlePassData.dailyQuests.find(q => q.id === questId);
  if (!quest) return;
  
  if (battlePassData.questProgress[questId] >= quest.target) {
    showNotification('Quest erledigt', 'Diese Quest ist bereits abgeschlossen!');
    return;
  }
  
  // Markiere Quest als abgeschlossen
  battlePassData.questProgress[questId] = quest.target;
  battlePassData.points += quest.points;
  
  // Berechne aktuelles Tier
  let newTier = 0;
  for (let i = BP_TIERS.length - 1; i >= 0; i--) {
    if (battlePassData.points >= BP_TIERS[i].pointsNeeded) {
      newTier = i + 1;
      break;
    }
  }
  battlePassData.currentTier = newTier;
  
  await saveBattlePassData();
  displayBattlePass();
  
  showNotification('Quest abgeschlossen! 🎉', `+${quest.points} Battle Pass Punkte!`);
};

// Belohnung claimen
window.claimBPReward = async function(tier, track) {
  if (!currentUser) return;
  
  const tierData = BP_TIERS[tier - 1];
  if (!tierData) return;
  
  const claimKey = `${tier}-${track}`;
  if (battlePassData.claimedTiers.includes(claimKey)) {
    showNotification('Bereits beansprucht', 'Diese Belohnung wurde bereits beansprucht!');
    return;
  }
  
  if (battlePassData.points < tierData.pointsNeeded) {
    showNotification('Noch nicht freigeschaltet', `Du brauchst ${tierData.pointsNeeded} Punkte!`);
    return;
  }
  
  if (track === 'paid' && !battlePassData.isPremium) {
    showNotification('Premium benötigt', 'Du brauchst Premium für diese Belohnung!');
    return;
  }
  
  const reward = track === 'free' ? tierData.freeReward : tierData.paidReward;
  battlePassData.claimedTiers.push(claimKey);
  
  // Belohnung verteilen
  if (reward.type === 'coins') {
    await addCoins(reward.value);
    showNotification('Belohnung erhalten! 🪙', `+${reward.value} Münzen!`);
  } else if (reward.type === 'exclusive-color') {
    const colorData = reward.value; // value ist jetzt ein Objekt mit id, name, color
    console.log('🎨 Exclusive Color claimen:', colorData);
    
    // Füge exklusive Farbe zu CHAT_COLORS hinzu falls nicht vorhanden
    const colorExists = CHAT_COLORS.find(c => c.id === colorData.id);
    if (!colorExists) {
      CHAT_COLORS.push({ 
        id: colorData.id, 
        name: colorData.name, 
        color: colorData.color, 
        price: 0, 
        exclusive: true 
      });
      console.log('✅ Farbe zu CHAT_COLORS hinzugefügt');
    }
    
    // Füge zur Inventory hinzu
    if (!userInventory.chatColorsOwned.includes(colorData.id)) {
      userInventory.chatColorsOwned.push(colorData.id);
      await saveInventory();
      console.log('✅ Farbe zu Inventar hinzugefügt');
    }
    showNotification('Exklusive Farbe freigeschaltet! 🎨', `${colorData.name} ist jetzt verfügbar!`);
  } else if (reward.type === 'exclusive-theme') {
    const themeData = reward.value; // value ist jetzt ein Objekt mit id, name
    console.log('🎨 Exclusive Theme claimen:', themeData);
    
    // Füge zur Inventory hinzu
    if (!userInventory.themesOwned.includes(themeData.id)) {
      userInventory.themesOwned.push(themeData.id);
      await saveInventory();
      console.log('✅ Theme zu Inventar hinzugefügt');
    }
    showNotification('Exklusives Theme freigeschaltet! 🎨', `${themeData.name} ist jetzt verfügbar!`);
  } else if (reward.type === 'badge') {
    const badge = reward.value; // value ist jetzt ein Badge-Objekt
    console.log("🏆 Badge claimen:", badge);
    console.log("📦 userInventory.badges vorher:", userInventory.badges);
    
    // Prüfe ob Badge bereits existiert (per ID)
    const badgeExists = userInventory.badges.find(b => b.id === badge.id);
    if (!badgeExists) {
      userInventory.badges.push(badge);
      console.log("✅ Badge hinzugefügt zu userInventory.badges");
      await saveInventory();
      console.log("💾 Inventar gespeichert");
    } else {
      console.log("⚠️ Badge existiert bereits");
    }
    console.log("📦 userInventory.badges nachher:", userInventory.badges);
    showNotification('Badge erhalten! 🏆', `${badge.name} freigeschaltet!`);
  }
  
  await saveBattlePassData();
  displayBattlePass();
  displayInventory();
};

// Battle Pass anzeigen
function displayBattlePass() {
  ensureBattlePassStyles();
  const isDark = document.body.classList.contains('dark-mode');
  const statusBoxBg = isDark ? '#2a2a2a' : '#f0f0f0';
  const textColor = isDark ? '#f2f4f8' : '#111';
  
  // Update Status Box Hintergrund
  const statusBox = document.querySelector('#battlepass .card > div[style*="background:#f0f0f0"]');
  if (statusBox) {
    statusBox.style.background = statusBoxBg;
    statusBox.style.color = textColor;
    // Update alle p und strong Tags in der Box
    statusBox.querySelectorAll('p, strong, span').forEach(el => {
      el.style.color = textColor;
    });
  }
  
  // Status
  const statusEl = document.getElementById('bpStatus');
  const activateBtn = document.getElementById('bpActivateBtn');
  
  if (battlePassData.isPremium) {
    statusEl.textContent = 'Premium aktiv ✅';
    statusEl.style.color = '#28a745';
    if (activateBtn) activateBtn.style.display = 'none';
  } else {
    statusEl.textContent = 'Free';
    statusEl.style.color = '#ff6b6b';
    if (activateBtn) activateBtn.style.display = 'block';
  }
  
  // Monat + Jahr
  const months = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
  const monthName = months[battlePassData.currentMonth] || months[new Date().getMonth()];
  const year = battlePassData.currentYear || new Date().getFullYear();
  document.getElementById('bpMonth').textContent = `${monthName} ${year}`;
  
  // Fortschritt
  const maxPoints = BP_TIERS[BP_TIERS.length - 1].pointsNeeded;
  document.getElementById('bpProgress').textContent = battlePassData.points;
  document.getElementById('bpMaxPoints').textContent = maxPoints;
  
  const progress = Math.min(100, (battlePassData.points / maxPoints) * 100);
  document.getElementById('bpBar').style.width = progress + '%';
  
  // Nächste Belohnungen anzeigen
  displayNextRewards();
  
  // Daily Quests anzeigen
  displayDailyQuests();
  
  // Weekly Quests anzeigen
  displayWeeklyQuests();
  
  // Tiers anzeigen
  displayBPTiers();
}

// Zeige nächste Free und Paid Belohnungen
function displayNextRewards() {
  const nextFreeEl = document.getElementById('nextFreeReward');
  const nextPaidEl = document.getElementById('nextPaidReward');
  
  // Finde nächstes nicht-beanspruchtes Free Tier
  let nextFreeTier = null;
  for (let i = 0; i < BP_TIERS.length; i++) {
    if (!battlePassData.claimedTiers.includes(`${i + 1}-free`)) {
      nextFreeTier = BP_TIERS[i];
      break;
    }
  }
  
  // Finde nächstes nicht-beanspruchtes Paid Tier
  let nextPaidTier = null;
  for (let i = 0; i < BP_TIERS.length; i++) {
    if (!battlePassData.claimedTiers.includes(`${i + 1}-paid`)) {
      nextPaidTier = BP_TIERS[i];
      break;
    }
  }
  
  if (nextFreeTier) {
    const reward = nextFreeTier.freeReward;
    const textHtml = getRewardText(reward, false);
    nextFreeEl.innerHTML = `<strong>Tier ${nextFreeTier.tier}</strong><br>${textHtml}<br><small>${nextFreeTier.pointsNeeded} Punkte benötigt</small>`;
  } else {
    nextFreeEl.innerHTML = '<strong>Alle Free Belohnungen erhalten!</strong> 🎉';
  }
  
  if (nextPaidTier) {
    const reward = nextPaidTier.paidReward;
    const textHtml = getRewardText(reward, true);
    nextPaidEl.innerHTML = `<strong>Tier ${nextPaidTier.tier}</strong><br>${textHtml}<br><small>${nextPaidTier.pointsNeeded} Punkte benötigt</small>`;
  } else {
    nextPaidEl.innerHTML = '<strong>Alle Premium Belohnungen erhalten!</strong> 💎';
  }
}

// Zeige Daily Quests
function displayDailyQuests() {
  const questsEl = document.getElementById('dailyQuestsList');
  if (!questsEl) return;
  
  const isDark = document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#f2f4f8' : '#111';
  const cardBg = isDark ? '#2a2a2a' : '#f8f9fa';
  const completedBg = isDark ? '#1e4620' : '#d4edda';
  const borderColor = isDark ? '#444' : '#ddd';
  const progressBg = isDark ? '#444' : '#ddd';
  
  let html = '';
  battlePassData.dailyQuests.forEach(quest => {
    const progress = battlePassData.questProgress[quest.id] || 0;
    const completed = progress >= quest.target;
    const progressPercent = Math.min(100, (progress / quest.target) * 100);
    
    html += `
      <div class="quest-card" style="background:${completed ? completedBg : cardBg}; border:2px solid ${completed ? '#28a745' : borderColor}; border-radius:8px; padding:15px; color:${textColor};">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="flex:1;">
            <h4 style="margin:0 0 5px 0; color:${textColor};">${quest.name} ${completed ? '✅' : ''}</h4>
            <p style="margin:0; font-size:14px; opacity:0.8; color:${textColor};">${quest.description}</p>
            <div style="background:${progressBg}; height:8px; border-radius:4px; margin:10px 0 5px 0; overflow:hidden;">
              <div style="background:#667eea; height:100%; width:${progressPercent}%; transition:width 0.3s;"></div>
            </div>
            <small style="color:${textColor};">${progress} / ${quest.target}</small>
          </div>
          <div style="text-align:center; margin-left:15px;">
            <div style="font-size:18px; font-weight:bold; color:#667eea;">+${quest.points}</div>
            <small style="opacity:0.7; color:${textColor};">Punkte</small>
          </div>
        </div>
      </div>
    `;
  });
  
  questsEl.innerHTML = html;
}

// Zeige wöchentliche Quests
function displayWeeklyQuests() {
  const questsEl = document.getElementById('weeklyQuestsList');
  if (!questsEl) return;
  
  const isDark = document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#f2f4f8' : '#111';
  const cardBg = isDark ? '#2a2a2a' : '#f8f9fa';
  const completedBg = isDark ? '#1e4620' : '#d4edda';
  const borderColor = isDark ? '#444' : '#ddd';
  const progressBg = isDark ? '#444' : '#ddd';
  
  let html = '';
  battlePassData.weeklyQuests.forEach(quest => {
    const questId = 'weekly_' + quest.id;
    const progress = battlePassData.questProgress[questId] || 0;
    const completed = progress >= quest.target;
    const progressPercent = Math.min(100, (progress / quest.target) * 100);
    
    html += `
      <div class="quest-card" style="background:${completed ? completedBg : cardBg}; border:2px solid ${completed ? '#ffd700' : borderColor}; border-radius:8px; padding:15px; color:${textColor}; box-shadow:0 2px 8px rgba(255,215,0,0.2);">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="flex:1;">
            <h4 style="margin:0 0 5px 0; color:${textColor};">⭐ ${quest.name} ${completed ? '✅' : ''}</h4>
            <p style="margin:0; font-size:14px; opacity:0.8; color:${textColor};">${quest.description}</p>
            <div style="background:${progressBg}; height:10px; border-radius:5px; margin:10px 0 5px 0; overflow:hidden;">
              <div style="background:linear-gradient(90deg, #ffd700, #ffed4e); height:100%; width:${progressPercent}%; transition:width 0.3s;"></div>
            </div>
            <small style="color:${textColor}; font-weight:bold;">${progress} / ${quest.target}</small>
          </div>
          <div style="text-align:center; margin-left:15px;">
            <div style="font-size:20px; font-weight:bold; color:#ffd700;">+${quest.points}</div>
            <small style="opacity:0.7; color:${textColor};">Punkte</small>
          </div>
        </div>
      </div>
    `;
  });
  
  questsEl.innerHTML = html;
}

// Zeige Battle Pass Tiers
function displayBPTiers() {
  const tiersEl = document.getElementById('bpTiersList');
  if (!tiersEl) return;
  
  const isDark = document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#f2f4f8' : '#111';
  const tierBg = isDark ? '#2a2a2a' : '#f8f9fa';
  const tierBgUnlocked = isDark ? '#1a2332' : '#f0f4ff';
  const borderColor = isDark ? '#444' : '#ddd';
  const rewardBg = isDark ? '#1a1a1a' : 'white';
  
  let html = '';
  BP_TIERS.forEach((tierData, idx) => {
    const tier = idx + 1;
    const unlocked = battlePassData.points >= tierData.pointsNeeded;
    const freeReward = tierData.freeReward;
    const paidReward = tierData.paidReward;
    const freeClaimed = battlePassData.claimedTiers.includes(`${tier}-free`);
    const paidClaimed = battlePassData.claimedTiers.includes(`${tier}-paid`);
    
    html += `
      <div class="bp-tier" style="border:2px solid ${unlocked ? '#667eea' : borderColor}; border-radius:10px; padding:15px; background:${unlocked ? tierBgUnlocked : tierBg}; color:${textColor};">
        <h4 style="margin:0 0 10px 0; color:${textColor};">Tier ${tier} ${unlocked ? '🔓' : '🔒'}</h4>
        <p style="margin:0 0 15px 0; font-size:13px; opacity:0.7; color:${textColor};">${tierData.pointsNeeded} Punkte benötigt</p>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
          <!-- Free Reward -->
          <div style="background:${rewardBg}; border:2px solid #28a745; border-radius:8px; padding:10px;">
            <div style="font-weight:bold; color:#28a745; margin-bottom:5px;">🎁 Free</div>
            <div style="font-size:13px; color:${textColor};">${getRewardText(freeReward, false)}</div>
            ${freeClaimed ? '<div style="color:#28a745; font-weight:bold; margin-top:5px;">✓ Beansprucht</div>' : 
              unlocked ? `<button onclick="claimBPReward(${tier}, 'free')" style="width:100%; margin-top:8px; padding:6px; font-size:12px;">Claimen</button>` : 
              `<div style="opacity:0.5; margin-top:5px; font-size:11px; color:${textColor};">Noch nicht freigeschaltet</div>`}
          </div>
          
          <!-- Paid Reward -->
          <div style="background:${rewardBg}; border:2px solid #764ba2; border-radius:8px; padding:10px;">
            <div style="font-weight:bold; color:#764ba2; margin-bottom:5px;">💎 Premium</div>
            <div style="font-size:13px; color:${textColor};">${getRewardText(paidReward, true)}</div>
            ${!battlePassData.isPremium ? '<div style="color:#ff6b6b; font-size:11px; margin-top:5px;">Premium benötigt</div>' :
              paidClaimed ? '<div style="color:#764ba2; font-weight:bold; margin-top:5px;">✓ Beansprucht</div>' :
              unlocked ? `<button onclick="claimBPReward(${tier}, 'paid')" style="width:100%; margin-top:8px; padding:6px; font-size:12px; background:#764ba2; color:white; border:none;">Claimen</button>` :
              '<div style="opacity:0.5; margin-top:5px; font-size:11px;">Noch nicht freigeschaltet</div>'}
          </div>
        </div>
      </div>
    `;
  });
  
  tiersEl.innerHTML = html;
}

// Hilfs-Funktion für Reward-Text
function getRewardText(reward, isPaid = false) {
  if (reward.type === 'coins') {
    if (isPaid) {
      return `🪙 <span class="bp-premium-wrap"><span class="bp-premium-name" style="--bp-premium-color:#ffd54f">${reward.value} Münzen</span></span>`;
    }
    return `🪙 ${reward.value} Münzen`;
  }
  if (reward.type === 'badge') {
    if (isPaid) {
      return `${reward.value.icon} <span class="bp-premium-wrap"><span class="bp-premium-name" style="--bp-premium-color:#ffd54f">${reward.value.name}</span></span>`;
    }
    return `${reward.value.icon} <span class="bp-special-name">${reward.value.name}</span>`;
  }
  if (reward.type === 'exclusive-color') {
    if (isPaid) {
      return `🎨 <span class="bp-premium-wrap"><span class="bp-premium-name" style="--bp-premium-color: ${reward.value.color};">${reward.value.name}</span></span> <span style="display:inline-block; width:15px; height:15px; background:${reward.value.color}; border-radius:50%; vertical-align:middle; margin-left:4px;"></span><br><small style="opacity:0.7;">(EXKLUSIV)</small>`;
    }
    return `🎨 <span class="bp-special-name">${reward.value.name}</span> <span style="display:inline-block; width:15px; height:15px; background:${reward.value.color}; border-radius:50%; vertical-align:middle; margin-left:4px;"></span><br><small style="opacity:0.7;">(EXKLUSIV)</small>`;
  }
  if (reward.type === 'exclusive-theme') {
    let accent = '#ffd54f';
    try {
      const th = (typeof WEBSITE_THEMES !== 'undefined') ? WEBSITE_THEMES.find(t => t.id === reward.value.id) : null;
      if (th && th.accent) accent = th.accent;
    } catch(e) {}
    if (isPaid) {
      return `✨ <span class="bp-premium-wrap"><span class="bp-premium-name" style="--bp-premium-color: ${accent};">${reward.value.name}</span></span> <br><small style="opacity:0.7;">(EXKLUSIV)</small>`;
    }
    return `✨ <span class="bp-special-name">${reward.value.name}</span> <br><small style="opacity:0.7;">(EXKLUSIV)</small>`;
  }
  return reward.value;
}

// Inject bold BP name effect styles once
let __bpStylesInjected = false;
function ensureBattlePassStyles() {
  if (__bpStylesInjected) return;
  const style = document.createElement('style');
  style.id = 'bp-name-effects';
  style.textContent = `
    .bp-special-name {
      font-weight: 700;
      letter-spacing: 0.4px;
      text-shadow: 0 0 8px rgba(255,255,255,0.6), 0 0 14px rgba(255,215,0,0.35);
    }
    .bp-premium-wrap {
      position: relative;
      display: inline-block;
    }
    .bp-premium-wrap::after {
      content: '';
      position: absolute;
      inset: -4px;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(255,255,255,0.95) 0 2px, transparent 3px),
        radial-gradient(circle at 60% 30%, rgba(255,255,255,0.8) 0 1.5px, transparent 2.5px),
        radial-gradient(circle at 80% 70%, rgba(255,255,255,0.9) 0 2px, transparent 3px),
        radial-gradient(circle at 30% 80%, rgba(255,255,255,0.7) 0 1.5px, transparent 3px);
      background-repeat: no-repeat;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.8));
      opacity: .75;
      animation: bpSparkles 2.4s linear infinite;
      mix-blend-mode: screen;
    }
    .bp-premium-name {
      font-weight: 800;
      letter-spacing: 0.6px;
      background: linear-gradient(90deg, #ffffff, var(--bp-premium-color,#ffd54f), #ffffff);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: bpShimmer 2.2s linear infinite, bpPulse 1.8s ease-in-out infinite;
      text-shadow: 0 0 10px rgba(255,255,255,0.9), 0 0 28px var(--bp-premium-color,#ffd54f), 0 0 54px var(--bp-premium-color,#ffd54f);
    }
    @keyframes bpShimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    @keyframes bpPulse {
      0%,100% { filter: drop-shadow(0 0 0 var(--bp-premium-color,#ffd54f)); }
      50% { filter: drop-shadow(0 0 12px var(--bp-premium-color,#ffd54f)); }
    }
    @keyframes bpSparkles {
      0% { transform: translateX(-8%); opacity: .65; }
      50% { opacity: .95; }
      100% { transform: translateX(8%); opacity: .65; }
    }
  `;
  document.head.appendChild(style);
  __bpStylesInjected = true;
}

/////////////////////////////////////////////////////////////////////////////

// Game Scroller
/////////////////////////////////////////////////////////////////////////////
window.scrollGames = function(direction) {
  const container = document.getElementById("gamesContainer");
  const scrollAmount = 380; // 360px + 20px gap
  
  if (direction === "left") {
    container.scrollBy({ left: -scrollAmount, behavior: "smooth" });
  } else if (direction === "right") {
    container.scrollBy({ left: scrollAmount, behavior: "smooth" });
  }
};

// Spiele filtern
window.filterGames = function() {
  const searchInput = document.getElementById("gameSearchInput");
  const filter = searchInput.value.toLowerCase();
  const gameItems = document.querySelectorAll(".game-item");
  
  gameItems.forEach(item => {
    const gameName = item.querySelector("h3").textContent.toLowerCase();
    if (gameName.includes(filter)) {
      item.style.display = "block";
    } else {
      item.style.display = "none";
    }
  });
};

// Optional: Pfeiltasten zum Scrollen
document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft") scrollGames("left");
  if (e.key === "ArrowRight") scrollGames("right");
});

/////////////////////////////////////////////////////////////////////////////
</script>

<!-- Easter Egg: Update Log -->
<div style="position: fixed; bottom: 5px; right: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 8px 12px; border-radius: 8px; font-size: 11px; max-width: 300px; cursor: pointer; z-index: 9999;" onclick="this.querySelector('.update-details').style.display = this.querySelector('.update-details').style.display === 'none' ? 'block' : 'none';">
  <div style="font-weight: bold; margin-bottom: 3px;">🎄 Version 2.7.0 - 02.12.2025</div>
  <div class="update-details" style="display: none; font-size: 10px; line-height: 1.4; margin-top: 5px; padding-top: 5px; border-top: 1px solid rgba(255,255,255,0.3);">
    <strong>✨ Neu:</strong><br>
    • 🎵 Musik-Shop: 8 Hintergrundmusik-Tracks (Daily Rotation)<br>
    • 🖋️ Schriftarten-Shop: 8 Custom Fonts (Daily Rotation)<br>
    • 🎶 Musik-System: 2min Loops, Lautstärkeregler, Ausrüsten<br>
    • ✍️ Font-System: Body-wide Anwendung, Live-Preview<br>
    • 🔇 Standard-Optionen für Musik & Fonts (immer verfügbar)<br>
    • 💾 Inventar-Persistenz via Firestore<br>
    • 🛒 Shop zeigt "Gekauft" für owned Items<br>
    • 🔑 Badge-Auswahl funktioniert wieder<br>
    • 🎵 8 Genre: Lofi, Jazz, Synthwave, Chill Hop, Piano, Electronic, Ambient, House<br>
    <div style="margin-top: 5px; opacity: 0.6;">Klicken zum Ein-/Ausklappen</div>
  </div>
</div>

<!-- I18N Enhancer: comprehensive site-wide translation -->
<script>
(function i18nEnhancer(){
  if (!window.applyTranslations || typeof window.applyTranslations !== 'function') return;
  
  // Merge comprehensive dictionary keys across all languages
  if (window.translations) {
    const addShared = (lang, kv) => {
      window.translations[lang] = Object.assign({}, window.translations[lang] || {}, kv);
    };
    
    const shared = {
      // Ranking modals
      ranking_title: { de: 'Rangliste', en: 'Ranking', es: 'Clasificación', ru: 'Рейтинг', fr: 'Classement', it: 'Classifica' },
      tab_all: { de: 'Alle', en: 'All', es: 'Todos', ru: 'Все', fr: 'Tous', it: 'Tutti' },
      tab_friends: { de: 'Freunde', en: 'Friends', es: 'Amigos', ru: 'Друзья', fr: 'Amis', it: 'Amici' },
      column_player: { de: 'Spieler', en: 'Player', es: 'Jugador', ru: 'Игрок', fr: 'Joueur', it: 'Giocatore' },
      column_score: { de: 'Punkte', en: 'Score', es: 'Puntos', ru: 'Очки', fr: 'Score', it: 'Punti' },
      column_time: { de: 'Zeit', en: 'Time', es: 'Tiempo', ru: 'Время', fr: 'Temps', it: 'Tempo' },
      column_wins: { de: 'Siege', en: 'Wins', es: 'Victorias', ru: 'Победы', fr: 'Victoires', it: 'Vittorie' },
      column_difficulty: { de: 'Schwierigkeit', en: 'Difficulty', es: 'Dificultad', ru: 'Сложность', fr: 'Difficulté', it: 'Difficoltà' },
      close_btn: { de: 'Schließen', en: 'Close', es: 'Cerrar', ru: 'Закрыть', fr: 'Fermer', it: 'Chiudi' },
      
      // Game status labels
      status_playing: { de: 'Spielen...', en: 'Playing...', es: 'Jugando...', ru: 'Играем...', fr: 'En jeu...', it: 'Giocando...' },
      status_paused: { de: 'Pausiert', en: 'Paused', es: 'Pausado', ru: 'Пауза', fr: 'En pause', it: 'In pausa' },
      status_gameover: { de: 'Spiel vorbei', en: 'Game Over', es: 'Juego terminado', ru: 'Игра окончена', fr: 'Jeu terminé', it: 'Fine gioco' },
      
      // Common game labels
      label_highscore_local: { de: 'Lokaler Highscore', en: 'Local Highscore', es: 'Puntuación local', ru: 'Локальный рекорд', fr: 'Meilleur score local', it: 'Punteggio locale' },
      label_highscore_global: { de: 'Globaler Highscore', en: 'Global Highscore', es: 'Puntuación global', ru: 'Мировой рекорд', fr: 'Meilleur score mondial', it: 'Punteggio mondiale' },
      label_current_score: { de: 'Aktueller Punktestand', en: 'Current Score', es: 'Puntuación actual', ru: 'Текущий счёт', fr: 'Score actuel', it: 'Punteggio attuale' },
      
      // Snake specific
      snake_title: { de: 'Snake Spiel', en: 'Snake Game', es: 'Juego Snake', ru: 'Игра Змейка', fr: 'Jeu Snake', it: 'Gioco Snake' },
      
      // Flappy Bird specific
      flappy_title: { de: 'Flappy Bird', en: 'Flappy Bird', es: 'Flappy Bird', ru: 'Flappy Bird', fr: 'Flappy Bird', it: 'Flappy Bird' },
      
      // Dino specific
      dino_title: { de: 'Dino Spiel', en: 'Dino Game', es: 'Juego Dino', ru: 'Игра Дино', fr: 'Jeu Dino', it: 'Gioco Dino' },
      
      // Tic Tac Toe specific
      ttt_title: { de: 'Tic Tac Toe vs KI', en: 'Tic Tac Toe vs AI', es: 'Tic Tac Toe vs IA', ru: 'Крестики-нолики против ИИ', fr: 'Tic Tac Toe vs IA', it: 'Tris vs IA' },
      
      // Tower Stack specific
      tower_title: { de: 'Tower Stack', en: 'Tower Stack', es: 'Torre de bloques', ru: 'Башня блоков', fr: 'Tour de blocs', it: 'Torre di blocchi' },
      
      // Sudoku specific
      sudoku_title: { de: 'Sudoku', en: 'Sudoku', es: 'Sudoku', ru: 'Судоку', fr: 'Sudoku', it: 'Sudoku' },
      
      // Penalty specific
      penalty_title: { de: 'Elfmeterschießen', en: 'Penalty Shootout', es: 'Tiros penales', ru: 'Серия пенальти', fr: 'Tirs au but', it: 'Rigori' },
      penalty_goals: { de: 'Tore', en: 'Goals', es: 'Goles', ru: 'Голы', fr: 'Buts', it: 'Gol' },
      penalty_streak: { de: 'Serie', en: 'Streak', es: 'Racha', ru: 'Серия', fr: 'Série', it: 'Serie' },
      penalty_best: { de: 'Beste Serie', en: 'Best Streak', es: 'Mejor racha', ru: 'Лучшая серия', fr: 'Meilleure série', it: 'Miglior serie' },
      
      // Chess specific
      chess_title: { de: 'Schach', en: 'Chess', es: 'Ajedrez', ru: 'Шахматы', fr: 'Échecs', it: 'Scacchi' },
      
      // Wordle specific
      wordle_title: { de: 'Wordle', en: 'Wordle', es: 'Wordle', ru: 'Wordle', fr: 'Wordle', it: 'Wordle' },
      
      // Millionaire specific
      millionaire_title: { de: 'Wer wird Millionär?', en: 'Who Wants to Be a Millionaire?', es: '¿Quién quiere ser millonario?', ru: 'Кто хочет стать миллионером?', fr: 'Qui veut gagner des millions?', it: 'Chi vuol essere milionario?' },
      
      // Slot Machine specific
      slot_title: { de: 'Slot Machine', en: 'Slot Machine', es: 'Máquina tragaperras', ru: 'Игровой автомат', fr: 'Machine à sous', it: 'Slot machine' },
      slot_balance: { de: 'Guthaben', en: 'Balance', es: 'Saldo', ru: 'Баланс', fr: 'Solde', it: 'Saldo' }
    };
    
    const langs = ['de','en','es','ru','fr','it'];
    langs.forEach(l => {
      const updates = {};
      Object.keys(shared).forEach(key => {
        updates[key] = shared[key][l];
      });
      addShared(l, updates);
    });
  }

  // Auto-tag ranking modals
  const modals = document.querySelectorAll('[id$="RankingModal"]');
  modals.forEach(modal => {
    const title = modal.querySelector('h2, .modal-title');
    if (title && !title.dataset.i18n) title.setAttribute('data-i18n', 'ranking_title');

    const textNodes = modal.querySelectorAll('button, a, span, div');
    textNodes.forEach(el => {
      const t = (el.textContent || '').trim().toLowerCase();
      if (!el.dataset.i18n) {
        if (t === 'alle' || t === 'all' || t === 'todos' || t === 'tutti' || t === 'tous' || t === 'все') {
          el.setAttribute('data-i18n', 'tab_all');
        } else if (t === 'freunde' || t === 'friends' || t === 'amigos' || t === 'amis' || t === 'amici' || t === 'друзья') {
          el.setAttribute('data-i18n', 'tab_friends');
        } else if (t === 'schließen' || t === 'close' || t === 'cerrar' || t === 'fermer' || t === 'chiudi' || t === 'закрыть') {
          el.setAttribute('data-i18n', 'close_btn');
        }
      }
    });

    const ths = modal.querySelectorAll('th');
    ths.forEach(th => {
      const tt = (th.textContent || '').trim().toLowerCase();
      if (!th.dataset.i18n) {
        if (tt.includes('spieler') || tt.includes('player') || tt.includes('jugador') || tt.includes('joueur') || tt.includes('giocatore') || tt.includes('игрок')) {
          th.setAttribute('data-i18n', 'column_player');
        } else if (tt.includes('punkte') || tt.includes('score') || tt.includes('puntos') || tt.includes('punti') || tt.includes('очки')) {
          th.setAttribute('data-i18n', 'column_score');
        } else if (tt.includes('zeit') || tt.includes('time') || tt.includes('tiempo') || tt.includes('temps') || tt.includes('tempo') || tt.includes('время')) {
          th.setAttribute('data-i18n', 'column_time');
        } else if (tt.includes('siege') || tt.includes('wins') || tt.includes('victoria') || tt.includes('victoire') || tt.includes('vittorie') || tt.includes('победы')) {
          th.setAttribute('data-i18n', 'column_wins');
        } else if (tt.includes('schwierigkeit') || tt.includes('difficulty') || tt.includes('dificultad') || tt.includes('difficulté') || tt.includes('difficoltà') || tt.includes('сложность')) {
          th.setAttribute('data-i18n', 'column_difficulty');
        }
      }
    });
  });

  // Auto-tag game cards
  const gameCards = document.querySelectorAll('.game-item .card');
  gameCards.forEach(card => {
    const h3 = card.querySelector('h3');
    if (h3 && !h3.dataset.i18n) {
      const title = h3.textContent.trim();
      if (title.includes('Snake')) h3.setAttribute('data-i18n', 'snake_title');
      else if (title.includes('Flappy')) h3.setAttribute('data-i18n', 'flappy_title');
      else if (title.includes('Dino')) h3.setAttribute('data-i18n', 'dino_title');
      else if (title.includes('Tic Tac Toe')) h3.setAttribute('data-i18n', 'ttt_title');
      else if (title.includes('Tower')) h3.setAttribute('data-i18n', 'tower_title');
      else if (title.includes('Sudoku')) h3.setAttribute('data-i18n', 'sudoku_title');
      else if (title.includes('Elfmeter')) h3.setAttribute('data-i18n', 'penalty_title');
      else if (title.includes('Schach') || title.includes('Chess')) h3.setAttribute('data-i18n', 'chess_title');
      else if (title.includes('Wordle')) h3.setAttribute('data-i18n', 'wordle_title');
      else if (title.includes('Millionär') || title.includes('Millionaire')) h3.setAttribute('data-i18n', 'millionaire_title');
      else if (title.includes('Slot')) h3.setAttribute('data-i18n', 'slot_title');
    }
  });

  // Auto-tag common game UI elements across all games
  document.querySelectorAll('p, span, label, div').forEach(el => {
    if (el.dataset.i18n) return;
    const text = (el.textContent || '').trim();
    
    if (text === 'Spielen...' || text === 'Playing...') el.setAttribute('data-i18n', 'status_playing');
    else if (text === 'Pausiert' || text === 'Paused') el.setAttribute('data-i18n', 'status_paused');
    else if (text === 'Spiel vorbei' || text === 'Game Over') el.setAttribute('data-i18n', 'status_gameover');
    else if (text.includes('Lokaler Highscore') || text.includes('Local Highscore')) el.setAttribute('data-i18n', 'label_highscore_local');
    else if (text.includes('Globaler Highscore') || text.includes('Global Highscore')) el.setAttribute('data-i18n', 'label_highscore_global');
    else if (text.includes('Aktueller Punktestand') || text.includes('Current Score')) el.setAttribute('data-i18n', 'label_current_score');
    else if (text === 'Tore:' || text === 'Goals:') el.setAttribute('data-i18n', 'penalty_goals');
    else if (text === 'Serie:' || text === 'Streak:') el.setAttribute('data-i18n', 'penalty_streak');
    else if (text === 'Beste Serie:' || text === 'Best Streak:') el.setAttribute('data-i18n', 'penalty_best');
    else if (text === 'Guthaben:' || text === 'Balance:') el.setAttribute('data-i18n', 'slot_balance');
  });

  // Apply updated translations
  try { window.applyTranslations(); } catch (e) { console.warn('i18nEnhancer applyTranslations failed:', e); }
})();
</script>
<!-- Live Spielplan – erweiterter Loader (Status & Fallback) -->
<script>
(function(){
  const leagueMap = { EPL:'PL', LL:'PD', BL:'BL1', SA:'SA', L1:'FL1' };
  const infoEl = () => document.getElementById('matchdayInfo');
  const listEl = () => document.getElementById('fixturesList');
  const selectEl = () => document.getElementById('leagueSelect');
  function setInfo(msg){ try{ if(infoEl()) infoEl().textContent = msg; }catch(e){} }
  function getToken(){
    const stored = localStorage.getItem('footballDataToken');
    // Default to provided token if none stored
    return (stored && stored.trim()) ? stored : '42525aa12c0d4f478c1627432b66b0d0';
  }
  window.setFootballDataToken = function(token){ try{ localStorage.setItem('footballDataToken', token || ''); setInfo('Token gespeichert. Bitte Aktualisieren klicken.'); }catch(e){} };
  async function fetchLiveFixtures(leagueKey){
    const token = getToken();
    if(!token){ setInfo('Kein Token gesetzt – zeige Fallback‑Spieltag.'); return []; }
    const comp = leagueMap[leagueKey];
    if(!comp){ setInfo('Unbekannte Liga – zeige Fallback‑Spieltag.'); return []; }
    const url = `https://one23-fehlstundenzettel2.onrender.com/api/football/${comp}`;
    try{
      const res = await fetch(url, { headers: { 'X-Auth-Token': token } });
      if(!res.ok){ console.warn('football-data HTTP', res.status, res.statusText); setInfo(`API-Fehler (${res.status}) – Fallback.`); return []; }
      const data = await res.json();
      const matches = Array.isArray(data.matches) ? data.matches : [];
      console.log('[LiveFetch]', leagueKey, 'matches:', matches.length);
      if(!matches.length){ setInfo('Keine kommenden Spiele gefunden – Fallback.'); return []; }
      const byMatchday = new Map();
      for(const m of matches){ const md = m.matchday ?? (m.season && m.season.currentMatchday) ?? 0; if(!byMatchday.has(md)) byMatchday.set(md, []); byMatchday.get(md).push(m); }
      const mds = [...byMatchday.keys()].filter(n => typeof n === 'number').sort((a,b)=>a-b);
      const targetMd = mds.length ? mds[0] : null;
      const next = targetMd != null ? byMatchday.get(targetMd) : matches.slice(0, 10);
      return next.map(m => ({ id: m.id, home: m.homeTeam?.name || 'Heim', away: m.awayTeam?.name || 'Auswärts', kickoff: m.utcDate || null }));
    }catch(err){ console.error('LiveFetch error', err); setInfo('API nicht erreichbar – Fallback.'); return []; }
  }
  function renderLive(fixtures){
    const ul = listEl(); if(!ul) return;
    ul.innerHTML = '';
    if(!fixtures.length){ setInfo('Live leer – Fallback-Spieltag.'); return; }
    setInfo('Live‑Spielplan geladen.');
    for(const f of fixtures){ const li = document.createElement('li'); const dt = f.kickoff ? new Date(f.kickoff) : null; const timeStr = dt ? dt.toLocaleString() : ''; li.textContent = `${f.home} vs ${f.away}${timeStr ? ' – ' + timeStr : ''}`; ul.appendChild(li); }
  }
  const __origLoad = window.loadMatchday;
  window.loadMatchday = async function(){
    const sel = selectEl(); const leagueKey = sel && sel.value ? sel.value : 'EPL'; if(sel && !sel.value){ sel.value = 'EPL'; }
    const live = await fetchLiveFixtures(leagueKey);
    if(live && live.length){ renderLive(live); } else { if(typeof __origLoad === 'function'){ __origLoad(); } }
  };
  document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('refreshLocksBtn'); const sel = selectEl();
    if(sel){ sel.addEventListener('change', () => window.loadMatchday()); }
    if(refreshBtn){ refreshBtn.addEventListener('click', () => window.loadMatchday()); }
  });
})();
</script>
<!-- Auto-apply chat glow effects based on computed color -->
<script>
  (function(){
    function colorToId(rgb){
      // Normalize input
      const v = (rgb||'').replace(/\s+/g,'').toLowerCase();
      // Map known RGBs
      if (v === 'rgb(211,47,47)' || v === 'rgba(211,47,47,1)') return 'santa';
      if (v === 'rgb(27,94,32)' || v === 'rgba(27,94,32,1)') return 'holly';
      if (v === 'rgb(179,229,252)' || v === 'rgba(179,229,252,1)') return 'icy';
      return null;
    }

    function applyIds(){
      try {
        const names = document.querySelectorAll('.message .name');
        names.forEach(el => {
          const cs = getComputedStyle(el);
          const id = colorToId(cs.color);
          if (id) el.setAttribute('data-color-id', id);
        });
        const labels = document.querySelectorAll('.color-preview .color-preview-label');
        labels.forEach(el => {
          const cs = getComputedStyle(el);
          const id = colorToId(cs.color);
          if (id) el.setAttribute('data-color-id', id);
        });
      } catch(e) {}
    }

    document.addEventListener('DOMContentLoaded', function(){
      applyIds();
      const obs = new MutationObserver(applyIds);
      obs.observe(document.body, { childList:true, subtree:true });
    });
  })();
</script>
</body>
</html>
<!-- Advent enhancements: badge + confetti + toast -->
<style>
  .confetti { position: fixed; top: -10px; width: 8px; height: 14px; background: hsl(calc(360*var(--h, 0.5)), 80%, 60%); left: 0; z-index: 9999; transform: rotate(15deg); animation: confettiFall 1.2s linear forwards; }
  .confetti:nth-child(3n) { --h: 0.1; }
  .confetti:nth-child(3n+1) { --h: 0.6; }
  .confetti:nth-child(3n+2) { --h: 0.85; }
  @keyframes confettiFall { to { top: 105vh; transform: rotate(360deg); opacity: 0.9; } }
  #nav button[data-advent] { position: relative; }
  #nav button.advent-available::after { content: ''; position: absolute; top: 6px; right: 6px; width: 8px; height: 8px; background: #e53935; border-radius: 50%; box-shadow: 0 0 0 2px rgba(255,255,255,0.9); }

  /* Door hover snow effect (softer, layered, drifting) */
  .advent-door { overflow: hidden; position: relative; }
  .advent-door:not(.locked):hover::before,
  .advent-door:not(.locked):hover::after {
    content: '';
    position: absolute;
    inset: -10% -5% -10% -5%;
    pointer-events: none;
    mix-blend-mode: screen;
  }
  /* Front layer: small flakes with subtle blur */
  .advent-door:not(.locked):hover::before {
    background-image:
      radial-gradient(closest-side, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.0) 70%);
    background-size: 6px 6px, 7px 7px, 5px 5px, 6px 6px, 7px 7px;
    background-repeat: repeat;
    background-position: 0 0, 30px -20px, 60px -40px, 90px -10px, 120px -30px;
    filter: blur(0.3px);
    animation: doorSnowFront 1.8s linear infinite;
    opacity: 0.85;
  }
  @keyframes doorSnowFront {
    0% { transform: translateY(-5%) translateX(0); }
    50% { transform: translateY(45%) translateX(-1.5%); }
    100% { transform: translateY(95%) translateX(0); }
  }
  /* Back layer: larger, softer flakes with gentle drift */
  .advent-door:not(.locked):hover::after {
    background-image:
      radial-gradient(closest-side, rgba(255,255,255,0.65) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.55) 0%, rgba(255,255,255,0.0) 70%),
      radial-gradient(closest-side, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.0) 70%);
    background-size: 10px 10px, 12px 12px, 11px 11px, 13px 13px;
    background-repeat: repeat;
    background-position: 10px -10px, 40px -30px, 80px -20px, 110px -40px;
    filter: blur(0.8px);
    animation: doorSnowBack 2.4s linear infinite;
    opacity: 0.55;
  }
  @keyframes doorSnowBack {
    0% { transform: translateY(-8%) translateX(0.8%); }
    50% { transform: translateY(50%) translateX(1.2%); }
    100% { transform: translateY(100%) translateX(0.8%); }
  }
</style>
<script>
  function showToast(msg) {
    let t = document.getElementById('toast');
<!-- (Removed temporary animated effects script; will integrate inline) -->
    if (!t) {
      t = document.createElement('div');
      t.id = 'toast';
      t.style.position = 'fixed';
      t.style.bottom = '20px';
      t.style.left = '50%';
      t.style.transform = 'translateX(-50%)';
      // Colors are set in setToastTheme()
      t.style.padding = '10px 16px';
      t.style.borderRadius = '8px';
      t.style.zIndex = '9999';
      t.style.opacity = '0';
      t.style.transition = 'opacity 200ms ease';
      document.body.appendChild(t);
    }
    setToastTheme(t);
    t.textContent = msg;
    t.style.opacity = '1';
    setTimeout(() => { t.style.opacity = '0'; }, 1800);
  }
  function setToastTheme(el) {
    const isDark = document.body.classList.contains('frosty-night') || document.body.classList.contains('dark') || document.documentElement.classList.contains('dark');
    if (isDark) {
      el.style.background = 'rgba(0,0,0,0.75)';
      el.style.color = '#fff';
      el.style.boxShadow = '0 6px 16px rgba(0,0,0,0.35)';
      el.style.backdropFilter = 'blur(6px)';
    } else {
      el.style.background = 'rgba(255,255,255,0.92)';
      el.style.color = '#111';
      el.style.boxShadow = '0 6px 16px rgba(0,0,0,0.2)';
      el.style.backdropFilter = 'blur(6px)';
    }
  }
  function spawnConfettiBurst() {
    const count = 24;
    for (let i = 0; i < count; i++) {
      const c = document.createElement('div');
      c.className = 'confetti';
      c.style.left = Math.random()*100 + 'vw';
      c.style.animationDelay = (Math.random()*0.3) + 's';
      document.body.appendChild(c);
      setTimeout(() => c.remove(), 1500);
    }
  }
  async function updateAdventNavBadge() {
    const btn = document.querySelector('#nav button[data-advent]');
    if (!btn) return;
    const today = new Date();
    let available = false;
    if (today.getMonth() === 11 && today.getDate() <= 24) {
      const year = today.getFullYear();
      const id = `${year}-12-${String(today.getDate()).padStart(2,'0')}`;
      try {
        if (window.currentUser && window.db && window.getDoc && window.doc) {
          const docRef = doc(db, 'adventClaims', currentUser.uid, 'claims', id);
          const snap = await getDoc(docRef);
          available = !snap.exists();
        } else {
          available = true;
        }
      } catch(e) {}
    }
    btn.classList.toggle('advent-available', available);
  }
  // Daily Shop: Background Music + Font Styles
  const SHOP_MUSIC = [
    { id: 'jingle_bells', name: 'Jingle Bells', demo: '🔔', price: 200 },
    { id: 'silent_night', name: 'Stille Nacht', demo: '🌙', price: 200 },
    { id: 'winter_waltz', name: 'Winter Waltz', demo: '❄️', price: 200 },
    { id: 'candy_cane_groove', name: 'Candy Cane Groove', demo: '🍬', price: 200 },
    { id: 'deck_the_halls', name: 'Deck The Halls', demo: '🎄', price: 250 },
    { id: 'frosty_beats', name: 'Frosty Beats', demo: '⛄', price: 250 },
    { id: 'sleigh_ride', name: 'Sleigh Ride', demo: '🛷', price: 300 },
    { id: 'winter_jazz', name: 'Winter Jazz', demo: '🎷', price: 300 }
  ];
  const SHOP_FONTS = [
    { id: 'frost_script', name: 'Frost Script', css: 'font-family: "Trebuchet MS", cursive; letter-spacing: 0.6px;', price: 200 },
    { id: 'snow_caps', name: 'Snow Caps', css: 'font-family: "Arial Black", sans-serif; letter-spacing: 1px; text-transform: uppercase;', price: 200 },
    { id: 'ginger_hand', name: 'Gingerbread Hand', css: 'font-family: "Comic Sans MS", cursive; letter-spacing: 0.3px;', price: 200 },
    { id: 'ice_modern', name: 'Ice Modern', css: 'font-family: "Segoe UI", sans-serif; letter-spacing: 0.4px;', price: 200 },
    { id: 'candy_cane_bold', name: 'Candy Cane Bold', css: 'font-family: Impact, sans-serif; letter-spacing: 2px; font-weight: bold;', price: 250 },
    { id: 'winter_elegant', name: 'Winter Elegant', css: 'font-family: Georgia, serif; letter-spacing: 0.5px; font-style: italic;', price: 250 },
    { id: 'snow_storm', name: 'Snow Storm', css: 'font-family: "Courier New", monospace; letter-spacing: 1.5px;', price: 300 },
    { id: 'festive_fancy', name: 'Festive Fancy', css: 'font-family: "Times New Roman", serif; letter-spacing: 1px; text-decoration: underline;', price: 300 }
  ];

  function seededPick(array, seed, count) {
    const rng = mulberry32(seed);
    const idxs = array.map((_, i) => i).sort(() => rng() - 0.5);
    return idxs.slice(0, count).map(i => array[i]);
  }
  function mulberry32(a){ return function(){ var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

  function getDailyShopItems(date = new Date()) {
    const seed = parseInt(`${date.getFullYear()}${String(date.getMonth()+1).padStart(2,'0')}${String(date.getDate()).padStart(2,'0')}`);
    const music = seededPick(SHOP_MUSIC, seed, 2);
    const fonts = seededPick(SHOP_FONTS, seed * 7, 2);
    return { music, fonts };
  }

  document.addEventListener('DOMContentLoaded', async () => {
    console.log('🎯 DOMContentLoaded - Shop wird initialisiert...');
    console.log('🎵 SHOP_MUSIC:', SHOP_MUSIC);
    console.log('🖋️ SHOP_FONTS:', SHOP_FONTS);
    updateAdventNavBadge();
    if (window.claimTodayAdvent) {
      const orig = window.claimTodayAdvent;
      window.claimTodayAdvent = async function(...args) {
        const before = new Date();
        const wasMonth = before.getMonth() === 11;
        const wasDay = before.getDate();
        await orig.apply(this, args);
        const after = new Date();
        if (wasMonth && after.getMonth() === 11 && after.getDate() === wasDay) {
          spawnConfettiBurst();
          showToast('Tür geöffnet!');
          updateAdventNavBadge();
        }
      }
    }
  });

  // Alte renderDailyShop Funktionen entfernt - displayShop() übernimmt jetzt alles

  async function isItemOwned(item) {
    if (!currentUser) return false;
    const invPath = item.type === 'music' ? 'music' : 'fonts';
    try {
      const ownedRef = doc(db, 'inventory', currentUser.uid, invPath, item.id);
      const snap = await getDoc(ownedRef);
      return snap.exists();
    } catch(e) { return false; }
  }
  async function isItemEquipped(item) {
    try {
      if (item.type === 'music') return window.currentMusicTrack === item.id || (typeof getUserSetting === 'function' && await getUserSetting('musicTrack') === item.id);
      if (item.type === 'font') return (document.body.getAttribute('style')||'').includes(item.css) || (typeof getUserSetting === 'function' && await getUserSetting('fontStyle') === item.id);
      return false;
    } catch(e) { return false; }
  }

  async function purchaseDailyItem(item, price) {
    if (!currentUser) { showNotification('Bitte einloggen'); return; }
    const invPath = item.type === 'music' ? 'music' : 'fonts';
    const ownedRef = doc(db, 'inventory', currentUser.uid, invPath, item.id);
    const snap = await getDoc(ownedRef);
    if (snap.exists()) { showNotification('Bereits im Inventar'); return; }
    const coinsOk = await decrementUserCoins(price);
    if (!coinsOk) { showNotification('Nicht genug Münzen'); return; }
    await setDoc(ownedRef, { ts: Date.now() });
    pushNotification({ type: 'rewards', text: `Gekauft: ${item.name}` });
    showToast('Gekauft!');
  }
  async function equipDailyItem(item) {
    if (item.type === 'music') {
      applyBackgroundMusic(item.id);
      showToast('Musik aktiviert');
    } else {
      applyFontStyle(item.id);
      showToast('Schrift aktiviert');
    }
  }
  function demoDailyMusic(item) {
    // Track-specific short preview using Web Audio
    if (typeof playChristmasMusicDemo === 'function') { playChristmasMusicDemo(item.id); return; }
    const motifs = {
      jingle_bells: [
        { f: 784, d: 220 }, { f: 784, d: 220 }, { f: 784, d: 440 },
        { f: 784, d: 220 }, { f: 784, d: 220 }, { f: 784, d: 440 },
        { f: 784, d: 220 }, { f: 988, d: 220 }, { f: 659, d: 660 }
      ],
      silent_night: [
        { f: 659, d: 300 }, { f: 587, d: 300 }, { f: 523, d: 600 },
        { f: 659, d: 300 }, { f: 587, d: 300 }, { f: 523, d: 600 }
      ],
      winter_waltz: [
        { f: 523, d: 240 }, { f: 659, d: 240 }, { f: 783, d: 480 },
        { f: 659, d: 240 }, { f: 523, d: 240 }, { f: 659, d: 480 }
      ],
      candy_cane_groove: [
        { f: 440, d: 180 }, { f: 554, d: 180 }, { f: 659, d: 360 },
        { f: 554, d: 180 }, { f: 440, d: 180 }, { f: 554, d: 360 }
      ]
    };
    const seq = motifs[item.id] || [{ f: 660, d: 400 }];
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const gain = ctx.createGain(); gain.gain.value = 0.04; gain.connect(ctx.destination);
      let t = ctx.currentTime;
      seq.forEach(n => {
        const osc = ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(n.f, t);
        const g = ctx.createGain(); g.gain.value = 0.0001; g.gain.linearRampToValueAtTime(0.06, t + 0.02); g.gain.linearRampToValueAtTime(0.0001, t + n.d/1000);
        osc.connect(g); g.connect(gain);
        osc.start(t); osc.stop(t + n.d/1000);
        t += (n.d + 30)/1000;
      });
      setTimeout(() => { ctx.close(); }, (t - ctx.currentTime + 0.4) * 1000);
    } catch(e) {}
  }
  function applyBackgroundMusic(id) {
    // Hook into existing music system; fallback stub
    if (typeof setChristmasMusicTrack === 'function') { setChristmasMusicTrack(id); return; }
    window.currentMusicTrack = id;
    if (typeof saveUserSetting === 'function' && currentUser) {
      saveUserSetting('musicTrack', id);
    }
  }
  function applyFontStyle(id) {
    const map = Object.fromEntries(SHOP_FONTS.map(f => [f.id, f.css]));
    const css = map[id] || '';
    document.documentElement.style.setProperty('--shop-font-css', css);
    document.body.setAttribute('style', css);
    if (typeof saveUserSetting === 'function' && currentUser) {
      saveUserSetting('fontStyle', id);
    }
  }
</script>
